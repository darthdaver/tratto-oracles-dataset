[ {
  "id" : 10734,
  "oracle" : "true ? methodResultID.size() >= objs.size() : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@return list of lists of length dims, each of which combines elements from objs",
  "methodJavadoc" : "    /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */",
  "methodSourceCode" : "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs){\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "1", "int" ], [ "0", "int" ], [ "2", "int" ], [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "dims", "", "int" ], [ "start", "", "int" ], [ "objs", "java.util.List", "List<T>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10743,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "UtilMDE",
  "javadocTag" : "@param val a numeric value",
  "methodJavadoc" : "    /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */",
  "methodSourceCode" : "public static String abbreviateNumber(long val){\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n        // nothing to do\n    } else if (val < 1000000) {\n        dval = val / 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val / 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val / 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    // format string computed from precision and mag\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}",
  "classJavadoc" : "/** Utility functions that do not belong elsewhere in the plume package. */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.checker.regex.qual.*;\nimport org.checkerframework.checker.signature.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/** Utility functions that do not belong elsewhere in the plume package. */\npublic final class UtilMDE {\n\n  /** This class is a collection of methods; it does not represent anything. */\n  private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  private static final String lineSep = System.getProperty(\"line.separator\");\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array\n  ///\n\n  // For arrays, see ArraysMDE.java.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BitSet\n  ///\n\n  /**\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    // Here are three implementation strategies to determine the\n    // cardinality of the intersection:\n    // 1. a.clone().and(b).cardinality()\n    // 2. do the above, but copy only a subset of the bits initially -- enough\n    //    that it should exceed the given number -- and if that fails, do the\n    //    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    //    for the case where the indices line up, so I'm not sure at what\n    //    point this approach begins to dominate #1.\n    // 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }\n\n  /**\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    // See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    // This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      // The size is more than 10 times the limit.  So first try processing\n      // just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }\n\n  /** Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }\n\n  /** Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (BitSet)\n  /*@Pure*/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// BufferedFileReader\n  ///\n\n  // Convenience methods for creating InputStreams, Readers, BufferedReaders, and LineNumberReaders.\n\n  /**\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   */\n  public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    // return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }\n\n  /**\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static InputStreamReader fileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(String filename, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }\n\n  /**\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static BufferedReader bufferedFileReader(File file, /*@Nullable*/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }\n\n  /**\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }\n\n  /**\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedWriter appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  // Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?\n  public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }\n\n  /**\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   */\n  public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Class\n  ///\n\n  /**\n   * Return true iff sub is a subtype of sup.\n   * If sub == sup, then sub is considered a subtype of sub and this method\n   * returns true.\n   * @param sub class to test for being a subtype\n   * @param sup class to test for being a supertype\n   * @return true iff sub is a subtype of sup\n   */\n  /*@Pure*/\n  public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    // Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    // If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    // Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);\n\n  static {\n    primitiveClasses.put(\"boolean\", Boolean.TYPE);\n    primitiveClasses.put(\"byte\", Byte.TYPE);\n    primitiveClasses.put(\"char\", Character.TYPE);\n    primitiveClasses.put(\"double\", Double.TYPE);\n    primitiveClasses.put(\"float\", Float.TYPE);\n    primitiveClasses.put(\"int\", Integer.TYPE);\n    primitiveClasses.put(\"long\", Long.TYPE);\n    primitiveClasses.put(\"short\", Short.TYPE);\n  }\n\n  /**\n   * Like {@link Class#forName(String)}, but also works when the string\n   * represents a primitive type or a fully-qualified name (as opposed to a binary name).\n   * <p>\n   * If the given name can't be found, this method changes the last '.'  to\n   * a dollar sign ($) and tries again.  This accounts for inner classes\n   * that are incorrectly passed in in fully-qualified format instead of\n   * binary format.\n   * <p>\n   * Recall the rather odd specification for {@link Class#forName(String)}:\n   * the argument is a binary name for non-arrays, but a field descriptor\n   * for arrays.  This method uses the same rules, but additionally handles\n   * primitive types and, for non-arrays, fully-qualified names.\n   * @param className name of the class\n   * @return the Class corresponding to className\n   * @throws ClassNotFoundException if the class is not found\n   */\n  // The annotation encourages proper use, even though this can take a\n  // fully-qualified name (only for a non-array).\n  public static Class<?> classForName(\n      /*@ClassGetName*/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") // checked below & exception is handled\n        /*@ClassGetName*/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  private static HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>\n      primitiveClassesJvm =\n          new HashMap</*@SourceNameForNonArrayNonInner*/ String, /*@FieldDescriptor*/ String>(8);\n\n  static {\n    primitiveClassesJvm.put(\"boolean\", \"Z\");\n    primitiveClassesJvm.put(\"byte\", \"B\");\n    primitiveClassesJvm.put(\"char\", \"C\");\n    primitiveClassesJvm.put(\"double\", \"D\");\n    primitiveClassesJvm.put(\"float\", \"F\");\n    primitiveClassesJvm.put(\"int\", \"I\");\n    primitiveClassesJvm.put(\"long\", \"J\");\n    primitiveClassesJvm.put(\"short\", \"S\");\n  }\n\n  /**\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava/lang/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@FieldDescriptor*/ String binaryNameToFieldDescriptor(\n      /*@BinaryName*/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '/');\n  }\n\n  /**\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   */\n  public static /*@FieldDescriptor*/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }\n\n  /** Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String binaryNameToClassGetName(/*BinaryName*/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('/', '.');\n    } else {\n      return bn;\n    }\n  }\n\n  /** Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@ClassGetName*/ String fieldDescriptorToClassGetName(\n      /*FieldDescriptor*/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }\n\n  /**\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   */\n  public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") // substring\n      /*@BinaryName*/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    // System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }\n\n  private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);\n\n  static {\n    primitiveClassesFromJvm.put(\"Z\", \"boolean\");\n    primitiveClassesFromJvm.put(\"B\", \"byte\");\n    primitiveClassesFromJvm.put(\"C\", \"char\");\n    primitiveClassesFromJvm.put(\"D\", \"double\");\n    primitiveClassesFromJvm.put(\"F\", \"float\");\n    primitiveClassesFromJvm.put(\"I\", \"int\");\n    primitiveClassesFromJvm.put(\"J\", \"long\");\n    primitiveClassesFromJvm.put(\"S\", \"short\");\n  }\n\n  // does not convert \"V\" to \"void\".  Should it?\n  /**\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava/lang/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   */\n  @SuppressWarnings(\"signature\") // conversion routine\n  public static /*@BinaryName*/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('/', '.');\n  }\n\n  /**\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava/lang/Integer;I[[Ljava/lang/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   */\n  public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          // return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ClassLoader\n  ///\n\n  /**\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   */\n  private static class PromiscuousLoader extends ClassLoader {\n    /**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class</code> object that was created\n     */\n    public Class<?> defineClassFromFile(\n        /*@BinaryName*/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); // link the class\n      return return_class;\n    }\n  }\n\n  private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();\n\n  /**\n   * Converts the bytes in a file into an instance of class Class, and\n   * resolves (links) the class.\n   * Like {@link ClassLoader#defineClass(String,byte[],int,int)}, but takes a\n   * file name rather than an array of bytes as an argument, and also resolves\n   * (links) the class.\n   * @see ClassLoader#defineClass(String,byte[],int,int)\n   * @param className the name of the class to define, or null if not known\n   * @param pathname the pathname of a .class file\n   * @return a Java Object corresponding to the Class defined in the .class file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   */\n  // Also throws UnsupportedClassVersionError and some other exceptions.\n  public static Class<?> defineClassFromFile(\n      /*@BinaryName*/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Classpath\n  ///\n\n  // Perhaps abstract out the simpler addToPath from this\n  /** Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   */\n  public static void addToClasspath(String dir) {\n    // If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    // what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// File\n  ///\n\n  /** Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }\n\n  /** Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   */\n  public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          // This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      // The two non-preferred line endings are tied and have more votes than\n      // the preferred line ending.  Give up and return the line separator\n      // for the system on which Java is currently running.\n      return lineSep;\n    }\n  }\n\n  /**\n   * Return true iff files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @return true iff the files have the same contents\n   */\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }\n\n  /**\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   */\n  @SuppressWarnings(\"purity\") // reads files, side effects local state\n  /*@Pure*/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   */\n  public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      // Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    /// Old implementation; is this equivalent to the new one, above??\n    // try {\n    //   if (file.exists()) {\n    //     return file.canWrite();\n    //   } else {\n    //     file.createNewFile();\n    //     file.delete();\n    //     return true;\n    //   }\n    // } catch (IOException e) {\n    //   return false;\n    // }\n  }\n\n  ///\n  /// Directories\n  ///\n\n  /**\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory/myUserName/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   */\n  public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    // Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    // Now that we have created our directory, we should get rid\n    // of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }\n\n  /**\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }\n\n  /**\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   */\n  public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }\n\n  ///\n  /// File names (aka filenames)\n  ///\n\n  // Someone must have already written this.  Right?\n\n  /**\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   */\n  public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }\n\n  static final String userHome = System.getProperty(\"user.home\");\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   */\n  public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   */\n  public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }\n\n  /**\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   */\n  public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }\n\n  ///\n  /// Reading and writing\n  ///\n\n  /**\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   */\n  public static void writeObject(Object o, File file) throws IOException {\n    // 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }\n\n  /**\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   */\n  public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    // 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }\n\n  /**\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }\n\n  // an alternate name would be \"fileContents\".\n  /**\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   */\n  public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        // Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }\n\n  /**\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   */\n  public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Hashing\n  ///\n\n  // In hashing, there are two separate issues.  First, one must convert\n  // the input datum into an integer.  Then, one must transform the\n  // resulting integer in a pseudorandom way so as to result in a number\n  // that is far separated from other values that may have been near it to\n  // begin with.  Often these two steps are combined, particularly if\n  // one wishes to avoid creating too large an integer (losing information\n  // off the top bits).\n\n  // http://burtleburtle.net/bob/hash/hashfaq.html says (of combined methods):\n  //  * for (h=0, i=0; i<len; ++i) { h += key[i]; h += (h<<10); h ^= (h>>6); }\n  //    h += (h<<3); h ^= (h>>11); h += (h<<15);\n  //    is good.\n  //  * for (h=0, i=0; i<len; ++i) h = tab[(h^key[i])&0xff]; may be good.\n  //  * for (h=0, i=0; i<len; ++i) h = (h>>8)^tab[(key[i]+h)&0xff]; may be good.\n\n  // In this part of the file, perhaps I will eventually write good hash\n  // functions.  For now, write cheesy ones that primarily deal with the\n  // first issue, transforming a data structure into a single number.  This\n  // is also known as fingerprinting.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /// Don't define hash with int args; use the long versions instead.\n\n  /**\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long l) {\n    // If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    return hash(hash(a), hash(b));\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String a, /*@Nullable*/ String b, /*@Nullable*/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }\n\n  /** Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   */\n  public static int hash(/*@Nullable*/ String /*@Nullable*/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Iterator\n  ///\n\n  // Making these classes into functions didn't work because I couldn't get\n  // their arguments into a scope that Java was happy with.\n\n  /** Converts an Enumeration into an Iterator. */\n  public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** Converts an Iterator into an Enumeration. */\n  public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   */\n  public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  // This must already be implemented someplace else.  Right??\n  /**\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   */\n  public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    // an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); // for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /** An iterator that only returns elements that match the given Filter. */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   */\n  @SuppressWarnings(\"assignment.type.incompatible\") // problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    // I don't think this works, because the iterator might itself return null\n    // /*@Nullable*/ T nothing = (/*@Nullable*/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") // check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    // Throws an error unless the RemoveFirstAndLastIterator has already\n    // been iterated all the way to its end (so the delegate is pointing to\n    // the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }\n\n  private static Random r = new Random();\n\n  /**\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   */\n  public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    // The elements are chosen with the following probabilities,\n    // where n == num_elts:\n    //   n n/2 n/3 n/4 n/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    /*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      // test random < num_elts/i\n      if (random.nextDouble() * i < num_elts) {\n        // This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    */\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Map\n  ///\n\n  // In Python, inlining this gave a 10x speed improvement.\n  // Will the same be true for Java?\n  /**\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   */\n  public static <T> /*@Nullable*/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }\n\n  /** Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   */\n  public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }\n\n  /**\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   */\n  public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   */\n  public static <K extends Comparable<? super K>, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }\n\n  /** Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   */\n  public static <K, V> Collection</*@KeyFor(\"#1\")*/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList</*@KeyFor(\"#1\")*/ K> theKeys = new ArrayList</*@KeyFor(\"#1\")*/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Method\n  ///\n\n  /**\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   */\n  static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();\n\n  /**\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * </pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") // throws exception if class does not exist\n    /*@BinaryNameForNonArray*/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      /*@MonotonicNonNull*/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        /*@ClassGetName*/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (/*@NonNull*/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }\n\n  /** Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   */\n  public static Method methodForName(\n      /*@BinaryNameForNonArray*/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// ProcessBuilder\n  ///\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   */\n  public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }\n\n  /**\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   */\n  public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    // TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") // input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Properties\n  ///\n\n  /**\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   */\n  @SuppressWarnings(\"purity\") // does not depend on object identity\n  /*@Pure*/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }\n\n  /**\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   */\n  public static /*@Nullable*/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }\n\n  /**\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   */\n  public static /*@Nullable*/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Regexp (regular expression)\n  ///\n\n  // See RegexUtil class.\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Reflection\n  ///\n\n  // TODO: make these leave the access the same as it was before?\n\n  // TODO: add method invokeMethod; see\n  // java/Translation/src/graph/tests/Reflect.java (but handle returning a\n  // value).\n\n  /**\n   * Sets the given field, which may be final and/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static void setFinalField(Object o, String fieldName, /*@Nullable*/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  // TODO: set the field back to private after is is accessed.\n  /**\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   */\n  public static /*@Nullable*/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { // Class is interned\n      // System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { // Class is interned\n          throw e;\n        }\n        // nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set\n  ///\n\n  /**\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   */\n  public static /*@Nullable*/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Stream\n  ///\n\n  /** Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   */\n  public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }\n\n  /** Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   */\n  public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// String\n  ///\n\n  /**\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   */\n  public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   */\n  public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") // Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new /*@NonNull*/ String[result_list.size()]);\n    return result;\n  }\n\n  /**\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   */\n  public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }\n\n  /**\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   */\n  public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    // This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   */\n  public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }\n\n  /**\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': // not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); // not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          // Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // The overhead of this is too high to call in escapeNonJava(String), so\n  // it is inlined there.\n  /** Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   */\n  public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': // not lineSep\n        return \"\\\\n\"; // not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }\n\n  /**\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   */\n  public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   */\n  private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { // not lineSep\n      return \"\\\\n\"; // not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }\n\n  /**\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   */\n  public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    // The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); // not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          // This is not in the default case because the search would find\n          // the quoted backslash.  Here we incluce the first backslash in\n          // the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          // In the default case, retain the character following the backslash,\n          // but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }\n\n  // Use the built-in String.trim()!\n  // /** Return the string with all leading and trailing whitespace stripped. */\n  // public static String trimWhitespace(String s) {\n  //   int len = s.length();\n  //   if (len == 0)\n  //     return s;\n  //   int first_non_ws = 0;\n  //   int last_non_ws = len-1;\n  //   while ((first_non_ws < len) && Character.isWhitespace(s.charAt(first_non_ws)))\n  //     first_non_ws++;\n  //   if (first_non_ws == len)\n  //     return \"\";\n  //   while (Character.isWhitespace(s.charAt(last_non_ws)))\n  //     last_non_ws--;\n  //   if ((first_non_ws == 0) && (last_non_ws == len)) {\n  //     return s;\n  //   } else {\n  //     return s.substring(first_non_ws, last_non_ws+1);\n  //   }\n  // }\n  // // // Testing:\n  // // assert(UtilMDE.trimWhitespace(\"foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\" foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"    foo\").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"foo    \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo   \").equals(\"foo\"));\n  // // assert(UtilMDE.trimWhitespace(\"  foo  bar   \").equals(\"foo  bar\"));\n  // // assert(UtilMDE.trimWhitespace(\"\").equals(\"\"));\n  // // assert(UtilMDE.trimWhitespace(\"   \").equals(\"\"));\n\n  /** Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   */\n  public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }\n\n  /** Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   */\n  public static String removeWhitespaceAfter(String arg, String delimiter) {\n    // String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      // if (non_ws_index == arg.length()) {\n      //   System.out.println(\"No nonspace character at end of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }\n\n  /** Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   */\n  public static String removeWhitespaceBefore(String arg, String delimiter) {\n    // System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    // String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      // if (non_ws_index == -1) {\n      //   System.out.println(\"No nonspace character at front of: \" + arg);\n      // } else {\n      //   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      // }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }\n\n  /**\n   * Return either \"n <em>noun</em>\" or \"n <em>noun</em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   */\n  public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /**\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   */\n  public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }\n\n  /** Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /** Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   */\n  public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }\n\n  /**\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   */\n  public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /*@Pure*/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }\n\n  /** Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   */\n  public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }\n\n  /** Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   */\n  public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// StringTokenizer\n  ///\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }\n\n  /**\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   */\n  public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Throwable\n  ///\n\n  /**\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   */\n  public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Collections\n  ///\n\n  /**\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   */\n  public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }\n\n  // This should perhaps be named withoutDuplicates to emphasize that\n  // it does not side-effect its argument.\n  /**\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   */\n  public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }\n\n  /**\n   * All calls to deepEquals that are currently underway.\n   */\n  private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();\n\n  /**\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * </ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   */\n  @SuppressWarnings(\"purity\") // side effect to static field deepEqualsUnderway\n  /*@Pure*/\n  public static boolean deepEquals(/*@Nullable*/ Object o1, /*@Nullable*/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") // creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Vector\n  ///\n\n  /** Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   */\n  public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }\n\n  // Rather than writing something like VectorToStringArray, use\n  //   v.toArray(new String[0])\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * </pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * </pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   */\n  public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * </pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * </pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   */\n  public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    // Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(\n      /*@FullyQualifiedName*/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   */\n  // TODO: does not follow the specification for inner classes (where the\n  // type name should be empty), but I think this is more informative anyway.\n  @SuppressWarnings(\"signature\") // string conversion\n  public static /*@ClassGetSimpleName*/ String fullyQualifiedNameToSimpleName(\n      /*@FullyQualifiedName*/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }\n\n  /**\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   */\n  @Deprecated\n  public static /*@ClassGetSimpleName*/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }\n\n  /**\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   */\n  public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      // nothing to do\n    } else if (val < 1000000) {\n      dval = val / 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val / 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val / 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") // format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "5.0", "double" ], [ "5000", "int" ], [ "65.0", "double" ], [ "65000000", "int" ], [ "1000", "int" ], [ "1024", "int" ], [ "1000000", "int" ], [ "1048576", "int" ], [ "3", "int" ], [ "\"5.00K\"", "String" ], [ "\"65.0M\"", "String" ] ],
  "tokensMethodArguments" : [ [ "val", "", "long" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "length", "java.lang", "String", "public int length()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10753,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "LimitedSizeIntSet",
  "javadocTag" : "@param slist a list of LimitedSizeIntSet, whose elements will be merged",
  "methodJavadoc" : "    /**\n   * Merges a list of LimitedSizeIntSet objects into a single object that\n   * represents the values seen by the entire list.  Returns the new\n   * object, whose max_values is the given integer.\n   * @param max_values the maximum size for the returned LimitedSizeIntSet\n   * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n   * @return a LimitedSizeIntSet that merges the elements of slist\n   */",
  "methodSourceCode" : "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist){\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}",
  "classJavadoc" : "/**\n * LimitedSizeIntSet stores up to some maximum number of unique\n * integer values, at which point its rep is nulled, in order to save space.\n * <p>\n * The advantage of this class over LimitedSizeSet&lt;Integer&gt; is that\n * it does not autobox the int values, so it takes less memory.\n *\n * @see LimitedSizeSet\n */",
  "classSourceCode" : "package plume;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/*>>>\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * LimitedSizeIntSet stores up to some maximum number of unique\n * integer values, at which point its rep is nulled, in order to save space.\n * <p>\n * The advantage of this class over LimitedSizeSet&lt;Integer&gt; is that\n * it does not autobox the int values, so it takes less memory.\n *\n * @see LimitedSizeSet\n */\n// Consider adding:\n//  * @deprecated Use LimitedSizeSet instead\n// @Deprecated\npublic class LimitedSizeIntSet implements Serializable, Cloneable {\n  // We are Serializable, so we specify a version to allow changes to\n  // method signatures without breaking serialization.  If you add or\n  // remove fields, you should change this number to the current date.\n  static final long serialVersionUID = 20031021L;\n\n  // public final int max_values;\n\n  /**\n   * If null, then at least num_values distinct values have been seen.\n   * The size is not separately stored, because that would take extra space.\n   */\n  protected int /*@Nullable*/ [] values;\n  /** The number of active elements (equivalently, the first unused index). */\n  int num_values;\n\n  /**\n   * Create a new LimitedSizeIntSet that can hold max_values values.\n   * @param max_values the maximum number of values this set will be able to hold\n   */\n  public LimitedSizeIntSet(int max_values) {\n    assert max_values > 0;\n    // this.max_values = max_values;\n    values = new int[max_values];\n    num_values = 0;\n  }\n\n  public void add(int elt) {\n    if (values == null) {\n      return;\n    }\n\n    if (contains(elt)) {\n      return;\n    }\n    if (num_values == values.length) {\n      values = null;\n      num_values++;\n      return;\n    }\n    values[num_values] = elt;\n    num_values++;\n  }\n\n  public void addAll(LimitedSizeIntSet s) {\n    @SuppressWarnings(\"interning\") // optimization; not a subclass of Collection, though\n    boolean sameObject = (this == s);\n    if (sameObject) {\n      return;\n    }\n    if (repNulled()) {\n      return;\n    }\n    if (s.repNulled()) {\n      int values_length = values.length;\n      // We don't know whether the elements of this and the argument were\n      // disjoint.  There might be anywhere from max(size(), s.size()) to\n      // (size() + s.size()) elements in the resulting set.\n      if (s.size() > values_length) {\n        num_values = values_length + 1;\n        values = null;\n        return;\n      } else {\n        throw new Error(\n            \"Arg is rep-nulled, so we don't know its values and can't add them to this.\");\n      }\n    }\n    for (int i = 0; i < s.size(); i++) {\n      assert s.values != null\n          : \"@AssumeAssertion(nullness): no relevant side effect:  add's side effects do not affect s.values\";\n      add(s.values[i]);\n      if (repNulled()) {\n        return; // optimization, not necessary for correctness\n      }\n    }\n  }\n\n  @SuppressWarnings(\"deterministic\") // pure wrt equals() but not ==: throws a new exception\n  /*@Pure*/\n  public boolean contains(int elt) {\n    if (values == null) {\n      throw new UnsupportedOperationException();\n    }\n    for (int i = 0; i < num_values; i++) {\n      if (values[i] == elt) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A lower bound on the number of elements in the set.  Returns either\n   * the number of elements that have been inserted in the set, or\n   * max_size(), whichever is less.\n   * @return a number that is a lower bound on the number of elements added to the set\n   */\n  /*@Pure*/\n  public int size(/*>>>@GuardSatisfied LimitedSizeIntSet this*/) {\n    return num_values;\n  }\n\n  /**\n   * An upper bound on how many distinct elements can be individually\n   * represented in the set.\n   * Returns max_values+1 (where max_values is the argument to the constructor).\n   * @return maximum capacity of the set representation\n   */\n  public int max_size() {\n    if (values == null) {\n      return num_values;\n    } else {\n      return values.length + 1;\n    }\n  }\n\n  /*@EnsuresNonNullIf(result=false, expression=\"values\")*/\n  /*@Pure*/\n  public boolean repNulled() {\n    return values == null;\n  }\n\n  @SuppressWarnings(\"sideeffectfree\") // side effect to local state (clone)\n  /*@SideEffectFree*/\n  public LimitedSizeIntSet clone(/*>>>@GuardSatisfied LimitedSizeIntSet this*/) {\n    LimitedSizeIntSet result;\n    try {\n      result = (LimitedSizeIntSet) super.clone();\n    } catch (CloneNotSupportedException e) {\n      throw new Error(); // can't happen\n    }\n    if (values != null) {\n      result.values = values.clone();\n    }\n    return result;\n  }\n\n  /**\n   * Merges a list of LimitedSizeIntSet objects into a single object that\n   * represents the values seen by the entire list.  Returns the new\n   * object, whose max_values is the given integer.\n   * @param max_values the maximum size for the returned LimitedSizeIntSet\n   * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n   * @return a LimitedSizeIntSet that merges the elements of slist\n   */\n  public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n      result.addAll(s);\n    }\n    return result;\n  }\n\n  /*@SideEffectFree*/\n  public String toString(/*>>>@GuardSatisfied LimitedSizeIntSet this*/) {\n    return (\"[size=\"\n        + size()\n        + \"; \"\n        + ((values == null) ? \"null\" : ArraysMDE.toString(values))\n        + \"]\");\n  }\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "max_values", "", "int" ], [ "slist", "java.util.List", "List<LimitedSizeIntSet>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "size", "plume", "LimitedSizeIntSet", "public int size()" ], [ "repNulled", "plume", "LimitedSizeIntSet", "public boolean repNulled()" ], [ "toString", "plume", "LimitedSizeIntSet", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "contains", "plume", "LimitedSizeIntSet", "public boolean contains(int elt)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "max_size", "plume", "LimitedSizeIntSet", "public int max_size()" ], [ "clone", "plume", "LimitedSizeIntSet", "public LimitedSizeIntSet clone()" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "values", "plume", "LimitedSizeIntSet", "protected int[] values;" ], [ "num_values", "plume", "LimitedSizeIntSet", "int num_values;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10770,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Options",
  "javadocTag" : "@throws ArgException if the command line contains unknown option or\nmisused options.",
  "methodJavadoc" : "    /**\n   * Parses a command line and sets the options accordingly.\n   * @param args the commandline to be parsed\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains unknown option or\n   * misused options.\n   */",
  "methodSourceCode" : "public String[] parse(String[] args) throws ArgException{\n    List<String> non_options = new ArrayList<String>();\n    // If true, then \"--\" has been seen and any argument starting with \"-\"\n    // is processed as an ordinary argument, not as an option.\n    boolean ignore_options = false;\n    // Loop through each argument\n    String tail = \"\";\n    String arg;\n    for (int ii = 0; ii < args.length; ) {\n        // If there was a ',' separator in previous arg, use the tail as\n        // current arg; otherwise, fetch the next arg from args list.\n        if (tail.length() > 0) {\n            arg = tail;\n            tail = \"\";\n        } else {\n            arg = args[ii];\n        }\n        if (arg.equals(\"--\")) {\n            ignore_options = true;\n        } else if ((arg.startsWith(\"--\") || arg.startsWith(\"-\")) && !ignore_options) {\n            String arg_name;\n            String arg_value;\n            // Allow ',' as an argument separator to get around\n            // some command line quoting problems.  (markro)\n            int split_pos = arg.indexOf(\",-\");\n            if (split_pos == 0) {\n                // Just discard the ',' if \",-\" occurs at begining of string\n                arg = arg.substring(1);\n                split_pos = arg.indexOf(\",-\");\n            }\n            if (split_pos > 0) {\n                tail = arg.substring(split_pos + 1);\n                arg = arg.substring(0, split_pos);\n            }\n            int eq_pos = arg.indexOf('=');\n            if (eq_pos == -1) {\n                arg_name = arg;\n                arg_value = null;\n            } else {\n                arg_name = arg.substring(0, eq_pos);\n                arg_value = arg.substring(eq_pos + 1);\n            }\n            OptionInfo oi = name_map.get(arg_name);\n            if (oi == null) {\n                StringBuilder msg = new StringBuilder();\n                msg.append(String.format(\"unknown option name '%s' in arg '%s'\", arg_name, arg));\n                if (false) {\n                    // for debugging\n                    msg.append(\"; known options:\");\n                    for (String option_name : UtilMDE.sortedKeySet(name_map)) {\n                        msg.append(\" \");\n                        msg.append(option_name);\n                    }\n                }\n                throw new ArgException(msg.toString());\n            }\n            if (oi.argument_required() && (arg_value == null)) {\n                ii++;\n                if (ii >= args.length) {\n                    throw new ArgException(\"option %s requires an argument\", arg);\n                }\n                arg_value = args[ii];\n            }\n            // System.out.printf (\"arg_name = '%s', arg_value='%s'%n\", arg_name,\n            //                    arg_value);\n            set_arg(oi, arg_name, arg_value);\n        } else {\n            // not an option\n            if (!parse_options_after_arg) {\n                ignore_options = true;\n            }\n            non_options.add(arg);\n        }\n        // If no ',' tail, advance to next args option\n        if (tail.length() == 0) {\n            ii++;\n        }\n    }\n    String[] result = non_options.toArray(new String[non_options.size()]);\n    return result;\n}",
  "classJavadoc" : "/**\n * The Options class:\n * <ul>\n *   <li>parses command-line options and sets fields in your program accordingly,</li>\n *   <li>creates usage messages (such as printed by a <code>--help</code> option), and</li>\n *   <li>creates documentation suitable for a manual or manpage.</li>\n * </ul>\n * Thus, the programmer is freed from writing duplicative, boilerplate code\n * and documentation that could get out of sync with the rest of the program.\n * <p>\n *\n * The programmer does not have to write any code, only declare and\n * document variables.  For each field that you want to set from a\n * command-line argument, you write Javadoc and an @{@link plume.Option}\n * annotation.  Then, the field is automatically set from a command-line\n * option of the same name, and usage messages and printed documentation\n * are generated automatically.\n * <p>\n *\n * The main entry point is {@link #parse_or_usage(String[])}.\n * Typical use is:\n *\n * <!-- Example needs some more words of explanation and example command lines. -->\n * <pre>\n *  import plume.*;\n *\n *  public class MyProgram {\n *\n *    &#64;Option(\"-o &lt;filename&gt; the output file \")\n *    public static File outfile = new File(\"/tmp/foobar\");\n *\n *    &#64;Option(\"-i ignore case\")\n *    public static boolean ignore_case;\n *\n *    &#64;Option(\"set the initial temperature\")\n *    public static double temperature = 75.0;\n *\n *    public static void main(String[] args) {\n *      MyProgram myInstance = new MyProgram();\n *      Options options = new Options(\"MyProgram [options] infile outfile\",\n *                                    myInstance, MyUtilityClass.class);\n *      String[] remaining_args = options.parse_or_usage(args);\n *      ...\n *    }\n *  }</pre>\n * A user may invoke the program using the command-line arguments\n * <code>-o</code>, <code>--outfile</code>, <code>-i</code>, <code>--ignore-case</code>,\n * and <code>--temperature</code>. <p>\n *\n * The call to {@link #parse_or_usage} sets fields in object myInstance,\n * and sets static fields in class MyUtilityClass.  It returns the original\n * command line, with all options removed. <p>\n *\n * <b>@Option indicates a command-line option</b> <p>\n * The @{@link Option} annotation on a field specifies brief user documentation\n * and, optionally, a one-character short name that users may supply on the\n * command line.  The long name is taken from the name of the variable;\n * when the name contains an underscore, the user may substitute a hyphen\n * on the command line instead; for example, the --multi-word-variable\n * command-line option would set the variable multi_word_variable. <p>\n *\n * On the command line, the values for options are specified in the form\n * '--longname=value', '-shortname=value', '--longname value', or '-shortname\n * value'.  If {@link #use_single_dash(boolean)} is true, then the long names\n * take the form '-longname=value' or '-longname value'.  The value is\n * mandatory for all options except booleans.  Booleans are set to true if no\n * value is specified. <p>\n *\n * All arguments that start with '-' are processed as options.  To\n * terminate option processing at the first non-option argument, see {@link\n * #parse_options_after_arg(boolean)}.  Also, the special option '--'\n * terminates option processing; method <code>parse_or_usage</code> returns\n * all subsequent arguments (along with any preceding non-option arguments)\n * without scanning them for options. <p>\n *\n * A user may provide an option multiple times on the command line.  If the\n * field is a list, each entry is added to the list.  If the field is\n * not a list, then only the last occurrence is used (subsequent\n * occurrences overwrite the previous value). <p>\n *\n * <b>Unpublicized options</b> <p>\n * The @{@link Unpublicized} annotation causes an option not to be displayed\n * in the usage message.  This can be useful for options that are\n * preliminary, experimental, or for internal purposes only.  The @{@link\n * Unpublicized} annotation must be specified in addition to the @{@link\n * Option} annotation. <p>\n *\n * There are forms of the usage-message methods that can include even\n * unpublicized options; for example, see {@link #usage(boolean,String...)}.\n * <p>\n *\n * <b>Option groups</b> <p>\n * The @{@link OptionGroup} annotation can be used to assign a name to a set of\n * related options.  This is useful for organizing a list of\n * options.  Options in the same group are displayed under the same heading\n * in usage texts. <p>\n *\n * The @{@link OptionGroup} annotation must be specified on a field in addition\n * to an @{@link Option} annotation.  Note that, due to a deficiency in\n * Javadoc, an <code>@OptionGroup</code> annotation must appear underneath any\n * Javadoc comment for the field it applies to. <p>\n *\n * The <code>@OptionGroup</code> annotation acts like a delimiter &mdash; all\n * <code>@Option</code>-annotated fields up to the next\n * <code>@OptionGroup</code> annotation belong to the same group.  When using\n * option groups, the first <code>@Option</code>-annotated field of every class\n * and object passed to the {@link #Options(String, Object...)} constructor\n * must have an <code>@OptionGroup</code> annotation.  Furthermore, the first\n * parameter of an <code>@OptionGroup</code> annotation (the group name) must\n * be unique among all classes and objects passed to the {@link\n * #Options(String, Object...)} constructor. <p>\n *\n * If an option group itself is unpublicized:\n * <ul>\n *   <li>The default usage message omits the group and all options belonging\n *       to it.\n *   <li>An unpublicized option group (that has any publicized options) is\n *       included in documentation for a manual.\n *   <li>A field with an @{@link Unpublicized} annotation is excluded\n *       even when passing the group's name\n *       explicitly as a parameter to {@link #usage(String...)}.\n * </ul>\n *\n * If an option group is not unpublicized but contains only unpublicized\n * options, it will not be included in the default usage message. <p>\n *\n * <b>Option aliases</b> <p>\n * The @{@link Option} annotation has an optional parameter <code>aliases</code>,\n * which accepts an array of strings.  Each string in the array is an alias for\n * the option being defined and can be used in place of an option's long name\n * or short name.</p>\n *\n * For example:\n * <pre>\n *     // The user may supply --help, -h, or -help, all of which mean the same thing and set this variable\n *     &#64;Option(value=\"-h Print a help message\", aliases={\"-help\"})\n *     public static boolean help;</pre>\n *\n * Aliases should start with a single dash or double dash.\n * If there is only a single, one-character alias, it can be put at the\n * beginning of the value field without the need for an aliases field.\n * It is the user's responsibility to ensure that no alias is the same as other\n * options or aliases and that they can be parsed unambiguously. <p>\n *\n * <b>Generating documentation for a manual or manpage</b> <p>\n * The class Javadoc for a class that has a main method should generally\n * contain a summary of all command-line options.  Such a summary can also\n * be useful in other circumstances.\n * See the {@link plume.OptionsDoclet} class for instructions about generating\n * HTML documentation. <p>\n *\n * <b>Supported field types</b> <p>\n * A field with an @{@link Option} annotation may be of the following types:\n * <ul>\n *   <li>Primitive types:  boolean, int, long, float, double.\n *       (Primitives can also be represented as wrappers:  Boolean,\n *       Integer, Long, Float, Double.  Use of a wrapper type allows the\n *       argument to have no default value.)\n *   <li>Reference types that have a constructor with a single string\n *       parameter.\n *   <li>java.util.regex.Pattern.\n *   <li>enums.\n *   <li>Lists of any of the above reference types.\n * </ul> <p>\n *\n * <b>More examples</b> <p>\n *\n * Example clients of the Options library include {@link plume.Lookup},\n * <a href=\"https://randoop.github.io/randoop/manual/#command-line-options\">Randoop</a>, and\n * <a href=\"http://types.cs.washington.edu/javari/javarifier/#command-line-opts\">Javarifier</a>, among many others.  <p>\n *\n * <b>Limitations</b> <ul>\n *\n *  <li> Short options are only supported as separate entries\n *  (e.g., \"-a -b\") and not as a single group (e.g., \"-ab\").\n *\n *  <li> Not all primitive types are supported.\n *\n *  <li> Types without a constructor that takes a single <code>String</code>\n *  argument are not supported.\n *\n *  <li> The \"--no-long\" option to turn off a boolean option named \"long\"\n *  is not supported; use \"--long=false\" instead.\n *\n * </ul> <p>\n *\n * <b>Possible enhancements</b> <ul>\n *  <li> Positional arguments (non-options that must be provided in a given\n *  order) could be supported.\n * </ul>\n *\n * @see plume.Option\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n */",
  "classSourceCode" : "// The five files\n//   Option.java\n//   OptionGroup.java\n//   Options.java\n//   Unpublicized.java\n//   OptionsDoclet.java\n// together comprise the implementation of command-line processing.\n\npackage plume;\n\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.formatter.qual.*;\nimport org.checkerframework.checker.initialization.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * The Options class:\n * <ul>\n *   <li>parses command-line options and sets fields in your program accordingly,</li>\n *   <li>creates usage messages (such as printed by a <code>--help</code> option), and</li>\n *   <li>creates documentation suitable for a manual or manpage.</li>\n * </ul>\n * Thus, the programmer is freed from writing duplicative, boilerplate code\n * and documentation that could get out of sync with the rest of the program.\n * <p>\n *\n * The programmer does not have to write any code, only declare and\n * document variables.  For each field that you want to set from a\n * command-line argument, you write Javadoc and an @{@link plume.Option}\n * annotation.  Then, the field is automatically set from a command-line\n * option of the same name, and usage messages and printed documentation\n * are generated automatically.\n * <p>\n *\n * The main entry point is {@link #parse_or_usage(String[])}.\n * Typical use is:\n *\n * <!-- Example needs some more words of explanation and example command lines. -->\n * <pre>\n *  import plume.*;\n *\n *  public class MyProgram {\n *\n *    &#64;Option(\"-o &lt;filename&gt; the output file \")\n *    public static File outfile = new File(\"/tmp/foobar\");\n *\n *    &#64;Option(\"-i ignore case\")\n *    public static boolean ignore_case;\n *\n *    &#64;Option(\"set the initial temperature\")\n *    public static double temperature = 75.0;\n *\n *    public static void main(String[] args) {\n *      MyProgram myInstance = new MyProgram();\n *      Options options = new Options(\"MyProgram [options] infile outfile\",\n *                                    myInstance, MyUtilityClass.class);\n *      String[] remaining_args = options.parse_or_usage(args);\n *      ...\n *    }\n *  }</pre>\n * A user may invoke the program using the command-line arguments\n * <code>-o</code>, <code>--outfile</code>, <code>-i</code>, <code>--ignore-case</code>,\n * and <code>--temperature</code>. <p>\n *\n * The call to {@link #parse_or_usage} sets fields in object myInstance,\n * and sets static fields in class MyUtilityClass.  It returns the original\n * command line, with all options removed. <p>\n *\n * <b>@Option indicates a command-line option</b> <p>\n * The @{@link Option} annotation on a field specifies brief user documentation\n * and, optionally, a one-character short name that users may supply on the\n * command line.  The long name is taken from the name of the variable;\n * when the name contains an underscore, the user may substitute a hyphen\n * on the command line instead; for example, the --multi-word-variable\n * command-line option would set the variable multi_word_variable. <p>\n *\n * On the command line, the values for options are specified in the form\n * '--longname=value', '-shortname=value', '--longname value', or '-shortname\n * value'.  If {@link #use_single_dash(boolean)} is true, then the long names\n * take the form '-longname=value' or '-longname value'.  The value is\n * mandatory for all options except booleans.  Booleans are set to true if no\n * value is specified. <p>\n *\n * All arguments that start with '-' are processed as options.  To\n * terminate option processing at the first non-option argument, see {@link\n * #parse_options_after_arg(boolean)}.  Also, the special option '--'\n * terminates option processing; method <code>parse_or_usage</code> returns\n * all subsequent arguments (along with any preceding non-option arguments)\n * without scanning them for options. <p>\n *\n * A user may provide an option multiple times on the command line.  If the\n * field is a list, each entry is added to the list.  If the field is\n * not a list, then only the last occurrence is used (subsequent\n * occurrences overwrite the previous value). <p>\n *\n * <b>Unpublicized options</b> <p>\n * The @{@link Unpublicized} annotation causes an option not to be displayed\n * in the usage message.  This can be useful for options that are\n * preliminary, experimental, or for internal purposes only.  The @{@link\n * Unpublicized} annotation must be specified in addition to the @{@link\n * Option} annotation. <p>\n *\n * There are forms of the usage-message methods that can include even\n * unpublicized options; for example, see {@link #usage(boolean,String...)}.\n * <p>\n *\n * <b>Option groups</b> <p>\n * The @{@link OptionGroup} annotation can be used to assign a name to a set of\n * related options.  This is useful for organizing a list of\n * options.  Options in the same group are displayed under the same heading\n * in usage texts. <p>\n *\n * The @{@link OptionGroup} annotation must be specified on a field in addition\n * to an @{@link Option} annotation.  Note that, due to a deficiency in\n * Javadoc, an <code>@OptionGroup</code> annotation must appear underneath any\n * Javadoc comment for the field it applies to. <p>\n *\n * The <code>@OptionGroup</code> annotation acts like a delimiter &mdash; all\n * <code>@Option</code>-annotated fields up to the next\n * <code>@OptionGroup</code> annotation belong to the same group.  When using\n * option groups, the first <code>@Option</code>-annotated field of every class\n * and object passed to the {@link #Options(String, Object...)} constructor\n * must have an <code>@OptionGroup</code> annotation.  Furthermore, the first\n * parameter of an <code>@OptionGroup</code> annotation (the group name) must\n * be unique among all classes and objects passed to the {@link\n * #Options(String, Object...)} constructor. <p>\n *\n * If an option group itself is unpublicized:\n * <ul>\n *   <li>The default usage message omits the group and all options belonging\n *       to it.\n *   <li>An unpublicized option group (that has any publicized options) is\n *       included in documentation for a manual.\n *   <li>A field with an @{@link Unpublicized} annotation is excluded\n *       even when passing the group's name\n *       explicitly as a parameter to {@link #usage(String...)}.\n * </ul>\n *\n * If an option group is not unpublicized but contains only unpublicized\n * options, it will not be included in the default usage message. <p>\n *\n * <b>Option aliases</b> <p>\n * The @{@link Option} annotation has an optional parameter <code>aliases</code>,\n * which accepts an array of strings.  Each string in the array is an alias for\n * the option being defined and can be used in place of an option's long name\n * or short name.</p>\n *\n * For example:\n * <pre>\n *     // The user may supply --help, -h, or -help, all of which mean the same thing and set this variable\n *     &#64;Option(value=\"-h Print a help message\", aliases={\"-help\"})\n *     public static boolean help;</pre>\n *\n * Aliases should start with a single dash or double dash.\n * If there is only a single, one-character alias, it can be put at the\n * beginning of the value field without the need for an aliases field.\n * It is the user's responsibility to ensure that no alias is the same as other\n * options or aliases and that they can be parsed unambiguously. <p>\n *\n * <b>Generating documentation for a manual or manpage</b> <p>\n * The class Javadoc for a class that has a main method should generally\n * contain a summary of all command-line options.  Such a summary can also\n * be useful in other circumstances.\n * See the {@link plume.OptionsDoclet} class for instructions about generating\n * HTML documentation. <p>\n *\n * <b>Supported field types</b> <p>\n * A field with an @{@link Option} annotation may be of the following types:\n * <ul>\n *   <li>Primitive types:  boolean, int, long, float, double.\n *       (Primitives can also be represented as wrappers:  Boolean,\n *       Integer, Long, Float, Double.  Use of a wrapper type allows the\n *       argument to have no default value.)\n *   <li>Reference types that have a constructor with a single string\n *       parameter.\n *   <li>java.util.regex.Pattern.\n *   <li>enums.\n *   <li>Lists of any of the above reference types.\n * </ul> <p>\n *\n * <b>More examples</b> <p>\n *\n * Example clients of the Options library include {@link plume.Lookup},\n * <a href=\"https://randoop.github.io/randoop/manual/#command-line-options\">Randoop</a>, and\n * <a href=\"http://types.cs.washington.edu/javari/javarifier/#command-line-opts\">Javarifier</a>, among many others.  <p>\n *\n * <b>Limitations</b> <ul>\n *\n *  <li> Short options are only supported as separate entries\n *  (e.g., \"-a -b\") and not as a single group (e.g., \"-ab\").\n *\n *  <li> Not all primitive types are supported.\n *\n *  <li> Types without a constructor that takes a single <code>String</code>\n *  argument are not supported.\n *\n *  <li> The \"--no-long\" option to turn off a boolean option named \"long\"\n *  is not supported; use \"--long=false\" instead.\n *\n * </ul> <p>\n *\n * <b>Possible enhancements</b> <ul>\n *  <li> Positional arguments (non-options that must be provided in a given\n *  order) could be supported.\n * </ul>\n *\n * @see plume.Option\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n */\npublic class Options {\n\n  /** The system-dependent line separator. */\n  private static String eol = System.getProperty(\"line.separator\");\n\n  /** Information about an option. */\n  class OptionInfo {\n\n    /** What variable the option sets. */\n    Field field;\n\n    //    /** Option annotation on the field. */\n    //    Option option;\n\n    /** Object containing the field.  Null if the field is static. */\n    /*@UnknownInitialization*/ /*@Raw*/ /*@Nullable*/ Object obj;\n\n    /** Short (one-character) argument name. */\n    /*@Nullable*/ String short_name;\n\n    /** Long argument name. */\n    String long_name;\n\n    /** Aliases for this option. */\n    String[] aliases;\n\n    /** Argument description: the first line. */\n    String description;\n\n    /** Full Javadoc description. */\n    /*@Nullable*/ String jdoc;\n\n    /**\n     * Maps names of enum constants to their corresponding Javadoc.  This is\n     * used by OptionsDoclet to generate documentation for enum-type options.\n     * Null if the base_type is not an Enum.\n     */\n    /*@MonotonicNonNull*/ Map<String, String> enum_jdoc;\n\n    /**\n     * Name of the argument type.  Defaults to the type of the field, but\n     * user can override this in the option string.\n     */\n    String type_name;\n\n    /**\n     * Class type of this field.  If the field is a list, the basetype\n     * of the list.\n     */\n    Class<?> base_type;\n\n    /** Default value of the option as a string. */\n    /*@Nullable*/ String default_str = null;\n\n    /**\n     * If true, the default value string for this option will be excluded from\n     * OptionsDoclet documentation.\n     */\n    boolean no_doc_default = false;\n\n    /** If the option is a list, this references that list. */\n    /*@MonotonicNonNull*/ List<Object> list = null;\n\n    /** Constructor that takes one String for the type. */\n    /*@Nullable*/ Constructor<?> constructor = null;\n\n    /** Factory that takes a string (some classes don't have a string constructor) and always returns non-null. */\n    /*@Nullable*/ Method factory = null;\n\n    /**\n     * If true, this OptionInfo is not output when printing documentation.\n     * @see #usage()\n     */\n    boolean unpublicized;\n\n    /**\n     * Create a new OptionInfo.\n     * The short name, type name, and description are taken\n     * from the option parameter.  The long name is the name of the\n     * field.  The default value is the current value of the field.\n     * @param field the field to set\n     * @param option the option\n     * @param obj the object whose field will be set;\n     *   if obj is null, the field must be static\n     * @param unpublicized whether the option is unpublicized\n     */\n    OptionInfo(\n        Field field,\n        Option option,\n        /*@UnknownInitialization*/ /*@Raw*/ /*@Nullable*/ Object obj,\n        boolean unpublicized) {\n      this.field = field;\n      //      this.option = option;\n      this.obj = obj;\n      this.base_type = field.getType();\n      this.unpublicized = unpublicized;\n      this.aliases = option.aliases();\n      this.no_doc_default = option.noDocDefault();\n\n      // The long name is the name of the field\n      long_name = field.getName();\n      if (use_dashes) {\n        long_name = long_name.replace('_', '-');\n      }\n\n      // Get the default value (if any)\n      Object default_obj = null;\n      if (!Modifier.isPublic(field.getModifiers())) {\n        throw new Error(\"option field is not public: \" + field);\n      }\n      try {\n        default_obj = field.get(obj);\n        if (default_obj != null) {\n          default_str = default_obj.toString();\n        }\n      } catch (Exception e) {\n        throw new Error(\"Unexpected error getting default for \" + field, e);\n      }\n\n      if (field.getType().isArray()) {\n        throw new Error(\"@Option may not annotate a variable of array type: \" + field);\n      }\n\n      // Handle lists.  When a list argument is specified multiple times,\n      // each argument value is appended to the list.\n      Type gen_type = field.getGenericType();\n      if (gen_type instanceof ParameterizedType) {\n        ParameterizedType pt = (ParameterizedType) gen_type;\n        Type raw_type = pt.getRawType();\n        if (!raw_type.equals(List.class)) {\n          throw new Error(\n              \"@Option supports List<...> but no other parameterized type; it does not support type \"\n                  + pt\n                  + \" for field \"\n                  + field);\n        }\n        if (default_obj == null) {\n          List<Object> new_list = new ArrayList<Object>();\n          try {\n            field.set(obj, new_list);\n          } catch (Exception e) {\n            throw new Error(\"Unexpected error setting default for \" + field, e);\n          }\n          default_obj = new_list;\n        }\n        if (((List<?>) default_obj).isEmpty()) {\n          default_str = null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        List<Object> default_obj_as_list = (List<Object>) default_obj;\n        this.list = default_obj_as_list;\n        // System.out.printf (\"list default = %s%n\", list);\n        Type[] listTypeArgs = pt.getActualTypeArguments();\n        this.base_type = (Class<?>) (listTypeArgs.length == 0 ? Object.class : listTypeArgs[0]);\n\n        // System.out.printf (\"Param type for %s = %s%n\", field, pt);\n        // System.out.printf (\"raw type = %s, type = %s%n\", pt.getRawType(),\n        //                   pt.getActualTypeArguments()[0]);\n      }\n\n      // Get the short name, type name, and description from the annotation\n      ParseResult pr;\n      try {\n        pr = parse_option(option.value());\n      } catch (Throwable e) {\n        throw new Error(\n            \"Error while processing @Option(\\\"\" + option.value() + \"\\\") on '\" + field + \"'\", e);\n      }\n      short_name = pr.short_name;\n      if (pr.type_name != null) {\n        type_name = pr.type_name;\n      } else {\n        type_name = type_short_name(base_type);\n      }\n      description = pr.description;\n\n      // Get a constructor for non-primitive base types\n      if (!base_type.isPrimitive() && !base_type.isEnum()) {\n        try {\n          if (base_type == Pattern.class) {\n            factory = Pattern.class.getMethod(\"compile\", String.class);\n          } else { // look for a string constructor\n            constructor = base_type.getConstructor(String.class);\n          }\n        } catch (Exception e) {\n          throw new Error(\n              \"@Option does not support type \"\n                  + base_type\n                  + \" for field \"\n                  + field\n                  + \" because it does not have a string constructor\",\n              e);\n        }\n      }\n    }\n\n    /**\n     * Return whether or not this option has a required argument.\n     * @return whether or not this option has a required argument\n     */\n    public boolean argument_required() {\n      Class<?> type = field.getType();\n      return ((type != Boolean.TYPE) && (type != Boolean.class));\n    }\n\n    /**\n     * Returns a short synopsis of the option in the form\n     * <code>-s --long=&lt;type&gt;</code>\n     * <strong>or</strong> (if use_single_dash is true)\n     * <code>-s -long=&lt;type&gt;</code> .\n     */\n    public String synopsis() {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String name = prefix + long_name;\n      if (short_name != null) {\n        name = String.format(\"-%s %s\", short_name, name);\n      }\n      name += String.format(\"=<%s>\", type_name);\n      if (list != null) {\n        name += \" [+]\";\n      }\n      return (name);\n    }\n\n    /**\n     * Return a one-line description of the option.\n     * @return a one-line description of the option\n     */\n    @Override\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied OptionInfo this*/) {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String short_name_str = \"\";\n      if (short_name != null) {\n        short_name_str = \"-\" + short_name + \" \";\n      }\n      return String.format(\"%s%s%s field %s\", short_name_str, prefix, long_name, field);\n    }\n\n    /** Returns the class that declares this option.\n     * @return the class that declares this option\n     */\n    public Class<?> get_declaring_class() {\n      return field.getDeclaringClass();\n    }\n  }\n\n  /** Information about an option group. */\n  static class OptionGroupInfo {\n\n    /** The name of this option group. */\n    String name;\n\n    /**\n     * If true, this group of options will not be printed in usage output by\n     * default. However, the usage information for this option group can be\n     * printed by specifying the group explicitly in the call to {@link\n     * #usage}.\n     */\n    boolean unpublicized;\n\n    /** List of options that belong to this group. */\n    List<OptionInfo> optionList;\n\n    OptionGroupInfo(String name, boolean unpublicized) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = name;\n      this.unpublicized = unpublicized;\n    }\n\n    OptionGroupInfo(OptionGroup optionGroup) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = optionGroup.value();\n      this.unpublicized = optionGroup.unpublicized();\n    }\n\n    /**\n     * If false, this group of options does not contain any publicized options,\n     * so it will not be included in the default usage message.\n     */\n    boolean any_publicized() {\n      for (OptionInfo oi : optionList) {\n        if (!oi.unpublicized) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Whether to parse options after a non-option command-line argument.\n   * @see #parse_options_after_arg(boolean)\n   */\n  private boolean parse_options_after_arg = true;\n\n  /** All of the argument options as a single string. */\n  private String options_str = \"\";\n\n  /** First specified class.  Void stands for \"not yet initialized\". */\n  private Class<?> main_class = Void.TYPE;\n\n  /** List of all of the defined options. */\n  private final List<OptionInfo> options = new ArrayList<OptionInfo>();\n\n  /** Map from short or long option names (with leading dashes) to option information. */\n  private final Map<String, OptionInfo> name_map = new LinkedHashMap<String, OptionInfo>();\n\n  /** Map from option group name to option group information. */\n  private final Map<String, OptionGroupInfo> group_map =\n      new LinkedHashMap<String, OptionGroupInfo>();\n\n  /**\n   * If, after the Options constructor is called, use_groups is true, then the\n   * user is using @OptionGroup annotations correctly (as per the requirement\n   * specified above).  If false, then @OptionGroup annotations have not been\n   * specified on any @Option-annotated fields.  When @OptionGroup annotations\n   * are used incorrectly, an Error is thrown by the Options constructor.\n   */\n  private boolean use_groups;\n\n  /**\n   * Convert underscores to dashes in long options in usage messages.  Users\n   * may specify either the underscore or dashed name on the command line.\n   */\n  private final boolean use_dashes = true;\n\n  /**\n   * When true, long options take the form -longOption with a single dash,\n   * rather than the default --longOption with two dashes.\n   */\n  private boolean use_single_dash = false;\n\n  /**\n   * String describing \"[+]\" (copied from Mercurial).\n   */\n  private static final String LIST_HELP = \"[+] marked option can be specified multiple times\";\n\n  /**\n   * Whether printing the usage message should print LIST_HELP.  The default is\n   * to print LIST_HELP if the usage message contains an option that accepts a\n   * list as a parameter.\n   */\n  private boolean print_list_help = false;\n\n  /**\n   * When true, an argument to a option of list type is split, on\n   * whitespace, into multiple arguments each of which is added to the\n   * list.  When false, each argument to an option of list type is treated\n   * as a single element, no matter what characters it contains.\n   */\n  @Option(\"Treat arguments to lists as space-separated.\")\n  public static boolean split_lists = false;\n\n  /**\n   * Synopsis of usage.  Example:  \"prog [options] arg1 arg2 ...\"\n   * <p>\n   * This variable is public so that clients can reset it (useful for\n   * masquerading as another program, based on parsed options).\n   */\n  public /*@Nullable*/ String usage_synopsis = null;\n\n  // Debug loggers\n  // Does nothing if not enabled.\n  private final SimpleLog debug_options = new SimpleLog(false);\n\n  /**\n   * Enable or disable debug logging.\n   * @param enabled whether to enable or disable logging\n   */\n  public void enableDebugLogging(boolean enabled) {\n    debug_options.enabled = enabled;\n  }\n\n  /**\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case its static fields are set.  The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param args the classes whose options to process\n   */\n  public Options(/*@UnknownInitialization*/ /*@Raw*/ Object... args) {\n    this(\"\", args);\n  }\n\n  /**\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case it must be fully initalized and its static fields are set.\n   * The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param usage_synopsis a synopsis of how to call your program\n   * @param args the classes whose options to process\n   */\n  public Options(String usage_synopsis, /*@UnknownInitialization*/ /*@Raw*/ Object... args) {\n\n    if (args.length == 0) {\n      throw new Error(\"Must pass at least one object to Options constructor\");\n    }\n\n    this.usage_synopsis = usage_synopsis;\n\n    this.use_groups = false;\n\n    // true once the first @Option annotation is observed, false until then.\n    boolean seen_first_opt = false;\n\n    // Loop through each specified object or class\n    for (Object obj : args) {\n      boolean is_class = obj instanceof Class<?>;\n      String current_group = null;\n\n      @SuppressWarnings({\n        \"rawness\",\n        \"initialization\"\n      }) // if is_class is true, obj is a non-null initialized Class\n      /*@Initialized*/ /*@NonRaw*/ /*@NonNull*/ Class<?> clazz =\n          (is_class ? (/*@Initialized*/ /*@NonRaw*/ /*@NonNull*/ Class<?>) obj : obj.getClass());\n      if (main_class == Void.TYPE) {\n        main_class = clazz;\n      }\n      Field[] fields = clazz.getDeclaredFields();\n\n      for (Field f : fields) {\n        try {\n          // Possible exception because \"obj\" is not yet initialized; catch it and proceed\n          @SuppressWarnings(\"cast\")\n          Object obj_nonraw = (/*@Initialized*/ /*@NonRaw*/ Object) obj;\n          debug_options.log(\"Considering field %s of object %s%n\", f, obj_nonraw);\n        } catch (Throwable t) {\n          debug_options.log(\"Considering field %s of object of type %s%n\", f, obj.getClass());\n        }\n        try {\n          debug_options.log(\"  with annotations %s%n\", Arrays.toString(f.getDeclaredAnnotations()));\n        } catch (java.lang.ArrayStoreException e) {\n          if (e.getMessage() != null\n              && Objects.equals(\n                  e.getMessage(), \"sun.reflect.annotation.TypeNotPresentExceptionProxy\")) {\n            debug_options.log(\"  with TypeNotPresentExceptionProxy while getting annotations%n\");\n          } else {\n            throw e;\n          }\n        }\n        Option option = safeGetAnnotation(f, Option.class);\n        if (option == null) {\n          continue;\n        }\n\n        boolean unpublicized = safeGetAnnotation(f, Unpublicized.class) != null;\n\n        if (is_class && !Modifier.isStatic(f.getModifiers())) {\n          throw new Error(\"non-static option \" + f + \" in class \" + obj);\n        }\n\n        @SuppressWarnings(\n            \"initialization\") // \"new MyClass(underInitialization)\" yields @UnderInitialization even when @Initialized would be safe\n        /*@Initialized*/ OptionInfo oi =\n            new OptionInfo(f, option, is_class ? null : obj, unpublicized);\n        options.add(oi);\n\n        // FIXME: should also check that the option does not belong to an\n        // unpublicized option group\n        if (oi.list != null && !oi.unpublicized) {\n          print_list_help = true;\n        }\n\n        OptionGroup optionGroup = safeGetAnnotation(f, OptionGroup.class);\n\n        if (!seen_first_opt) {\n          seen_first_opt = true;\n          // This is the first @Option annotation encountered so we can decide\n          // now if the user intends to use option groups.\n          if (optionGroup != null) {\n            use_groups = true;\n          } else {\n            continue;\n          }\n        }\n\n        if (!use_groups) {\n          if (optionGroup != null) {\n            // The user included an @OptionGroup annotation in their code\n            // without including an @OptionGroup annotation on the first\n            // @Option-annotated field, hence violating the requirement.\n\n            // NOTE: changing this error string requires changes to TestPlume\n            throw new Error(\n                \"missing @OptionGroup annotation on the first \"\n                    + \"@Option-annotated field of class \"\n                    + main_class);\n          } else {\n            continue;\n          }\n        }\n\n        // use_groups is true at this point.  The variable current_group is set\n        // to null at the start of every iteration through 'args'.  This is so\n        // we can check that the first @Option-annotated field of every\n        // class/object in 'args' has an @OptionGroup annotation when use_groups\n        // is true, as required.\n        if (current_group == null && optionGroup == null) {\n          // NOTE: changing this error string requires changes to TestPlume\n          throw new Error(\"missing @OptionGroup annotation in field \" + f + \" of class \" + obj);\n        } else if (optionGroup != null) {\n          String name = optionGroup.value();\n          if (group_map.containsKey(name)) {\n            throw new Error(\"option group \" + name + \" declared twice\");\n          }\n          OptionGroupInfo gi = new OptionGroupInfo(optionGroup);\n          group_map.put(name, gi);\n          current_group = name;\n        } // current_group is non-null at this point\n        @SuppressWarnings(\"nullness\") // map key\n        /*@NonNull*/ OptionGroupInfo ogi = group_map.get(current_group);\n        ogi.optionList.add(oi);\n      } // loop through fields\n    } // loop through args\n\n    String prefix = use_single_dash ? \"-\" : \"--\";\n\n    // Add each option to the option name map\n    for (OptionInfo oi : options) {\n      if (oi.short_name != null) {\n        if (name_map.containsKey(\"-\" + oi.short_name)) {\n          throw new Error(\"short name \" + oi + \" appears twice\");\n        }\n        name_map.put(\"-\" + oi.short_name, oi);\n      }\n      if (name_map.containsKey(prefix + oi.long_name)) {\n        throw new Error(\"long name \" + oi + \" appears twice\");\n      }\n      name_map.put(prefix + oi.long_name, oi);\n      if (use_dashes && oi.long_name.contains(\"-\")) {\n        name_map.put(prefix + oi.long_name.replace('-', '_'), oi);\n      }\n      if (oi.aliases.length > 0) {\n        for (String alias : oi.aliases) {\n          if (name_map.containsKey(alias)) {\n            throw new Error(\"alias \" + oi + \" appears twice\");\n          }\n          name_map.put(alias, oi);\n        }\n      }\n    }\n  }\n\n  /**\n   * Like getAnnotation, but returns null (and prints a warning) rather\n   * than throwing an exception.\n   */\n  @SuppressWarnings(\n      \"initialization\") // bug; see test case checkers/tests/nullness/generics/OptionsTest.java\n  private static <T extends Annotation> /*@Nullable*/ T safeGetAnnotation(\n      Field f, Class<T> annotationClass) {\n    /*@Nullable*/ T annotation;\n    try {\n      @SuppressWarnings(\"cast\") // cast is redundant (except for type annotations)\n      /*@Nullable*/ T cast = f.getAnnotation((Class</*@NonNull*/ T>) annotationClass);\n      annotation = cast;\n    } catch (Exception e) {\n      // Can get\n      //   java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy\n      // when an annotation is not present at run time (example: @NonNull)\n      System.out.printf(\n          \"Exception in call to f.getAnnotation(%s)%n  for f=%s%n  %s%nClasspath =%n\",\n          annotationClass,\n          f,\n          e.getMessage());\n      //e.printStackTrace();\n      JWhich.printClasspath();\n      annotation = null;\n    }\n\n    return annotation;\n  }\n\n  /**\n   * If true, Options will parse arguments even after a non-option\n   * command-line argument.  Setting this to true is useful to permit users\n   * to write options at the end of a command line.  Setting this to false\n   * is useful to avoid processing arguments that are actually\n   * options/arguments for another program that this one will invoke.\n   * @param val whether to parse arguments after a non-option command-line argument\n   */\n  public void parse_options_after_arg(boolean val) {\n    parse_options_after_arg = val;\n  }\n\n  /**\n   * If true, long options (those derived from field names) will be parsed with\n   * a single dash prefix as in -longOption.  The default is false and long\n   * options will be parsed with a double dash prefix as in --longOption.\n   * @param val whether to parse long options with a single dash, as in -longOption\n   */\n  public void use_single_dash(boolean val) {\n    use_single_dash = val;\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.\n   * @param args the commandline to be parsed\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains unknown option or\n   * misused options.\n   */\n  public String[] parse(String[] args) throws ArgException {\n\n    List<String> non_options = new ArrayList<String>();\n    // If true, then \"--\" has been seen and any argument starting with \"-\"\n    // is processed as an ordinary argument, not as an option.\n    boolean ignore_options = false;\n\n    // Loop through each argument\n    String tail = \"\";\n    String arg;\n    for (int ii = 0; ii < args.length; ) {\n      // If there was a ',' separator in previous arg, use the tail as\n      // current arg; otherwise, fetch the next arg from args list.\n      if (tail.length() > 0) {\n        arg = tail;\n        tail = \"\";\n      } else {\n        arg = args[ii];\n      }\n\n      if (arg.equals(\"--\")) {\n        ignore_options = true;\n      } else if ((arg.startsWith(\"--\") || arg.startsWith(\"-\")) && !ignore_options) {\n        String arg_name;\n        String arg_value;\n\n        // Allow ',' as an argument separator to get around\n        // some command line quoting problems.  (markro)\n        int split_pos = arg.indexOf(\",-\");\n        if (split_pos == 0) {\n          // Just discard the ',' if \",-\" occurs at begining of string\n          arg = arg.substring(1);\n          split_pos = arg.indexOf(\",-\");\n        }\n        if (split_pos > 0) {\n          tail = arg.substring(split_pos + 1);\n          arg = arg.substring(0, split_pos);\n        }\n\n        int eq_pos = arg.indexOf('=');\n        if (eq_pos == -1) {\n          arg_name = arg;\n          arg_value = null;\n        } else {\n          arg_name = arg.substring(0, eq_pos);\n          arg_value = arg.substring(eq_pos + 1);\n        }\n        OptionInfo oi = name_map.get(arg_name);\n        if (oi == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(String.format(\"unknown option name '%s' in arg '%s'\", arg_name, arg));\n          if (false) { // for debugging\n            msg.append(\"; known options:\");\n            for (String option_name : UtilMDE.sortedKeySet(name_map)) {\n              msg.append(\" \");\n              msg.append(option_name);\n            }\n          }\n          throw new ArgException(msg.toString());\n        }\n        if (oi.argument_required() && (arg_value == null)) {\n          ii++;\n          if (ii >= args.length) {\n            throw new ArgException(\"option %s requires an argument\", arg);\n          }\n          arg_value = args[ii];\n        }\n        // System.out.printf (\"arg_name = '%s', arg_value='%s'%n\", arg_name,\n        //                    arg_value);\n        set_arg(oi, arg_name, arg_value);\n      } else { // not an option\n        if (!parse_options_after_arg) {\n          ignore_options = true;\n        }\n        non_options.add(arg);\n      }\n\n      // If no ',' tail, advance to next args option\n      if (tail.length() == 0) {\n        ii++;\n      }\n    }\n    String[] result = non_options.toArray(new String[non_options.size()]);\n    return result;\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  This method\n   * splits the argument string into command-line arguments, respecting\n   * single and double quotes, then calls {@link #parse(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]</code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain</code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains misused options or an unknown option.\n   * @see #parse(String[])\n   */\n  public String[] parse(String args) throws ArgException {\n\n    // Split the args string on whitespace boundaries accounting for quoted\n    // strings.\n    args = args.trim();\n    List<String> arg_list = new ArrayList<String>();\n    String arg = \"\";\n    char active_quote = 0;\n    for (int ii = 0; ii < args.length(); ii++) {\n      char ch = args.charAt(ii);\n      if ((ch == '\\'') || (ch == '\"')) {\n        arg += ch;\n        ii++;\n        while ((ii < args.length()) && (args.charAt(ii) != ch)) {\n          arg += args.charAt(ii++);\n        }\n        arg += ch;\n      } else if (Character.isWhitespace(ch)) {\n        // System.out.printf (\"adding argument '%s'%n\", arg);\n        arg_list.add(arg);\n        arg = \"\";\n        while ((ii < args.length()) && Character.isWhitespace(args.charAt(ii))) {\n          ii++;\n        }\n        if (ii < args.length()) {\n          // Encountered a non-whitespace character.\n          // Back up to process it on the next loop iteration.\n          ii--;\n        }\n      } else { // must be part of current argument\n        arg += ch;\n      }\n    }\n    if (!arg.equals(\"\")) {\n      arg_list.add(arg);\n    }\n\n    String[] argsArray = arg_list.toArray(new String[arg_list.size()]);\n    return parse(argsArray);\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse(String[])\n   */\n  public String[] parse_or_usage(String[] args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      // throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * <p>\n   * This method splits the argument string into command-line arguments,\n   * respecting single and double quotes, then calls\n   * {@link #parse_or_usage(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]</code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain</code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse_or_usage(String[])\n   */\n  public String[] parse_or_usage(String args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      // throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }\n\n  /// This is a lot of methods, but it does save a tad of typing for the\n  /// programmer.\n\n  /**\n   * Prints usage information.  Uses the usage synopsis passed into the\n   * constructor, if any.\n   * @param ps where to print usage information\n   */\n  public void print_usage(PrintStream ps) {\n    if (usage_synopsis != null) {\n      ps.printf(\"Usage: %s%n\", usage_synopsis);\n    }\n    ps.println(usage());\n    if (print_list_help) {\n      ps.println();\n      ps.println(LIST_HELP);\n    }\n  }\n\n  /**\n   * Prints, to standard output, usage information.\n   */\n  public void print_usage() {\n    print_usage(System.out);\n  }\n\n  // This method is distinct from\n  //   print_usage (PrintStream ps, String format, Object... args)\n  // because % characters in the message are not interpreted.\n  /**\n   * Prints a message followed by indented usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param msg message to print before usage information\n   */\n  public void print_usage(PrintStream ps, String msg) {\n    ps.println(msg);\n    print_usage(ps);\n  }\n\n  /**\n   * Prints, to standard output, a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param msg messag. to print before usage information\n   */\n  public void print_usage(String msg) {\n    print_usage(System.out, msg);\n  }\n\n  /**\n   * Prints a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   */\n  @SuppressWarnings(\"formatter\") // acts as format method wrapper\n  public void print_usage(PrintStream ps, String format, /*@Nullable*/ Object... args) {\n    ps.printf(format, args);\n    if (!format.endsWith(\"%n\")) {\n      ps.println();\n    }\n    print_usage(ps);\n  }\n\n  /**\n   * Prints, to standard output, a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   */\n  /*@FormatMethod*/\n  public void print_usage(String format, /*@Nullable*/ Object... args) {\n    print_usage(System.out, format, args);\n  }\n\n  /**\n   * Return the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   */\n  public String usage(String... group_names) {\n    return usage(false, group_names);\n  }\n\n  /**\n   * Returns the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param include_unpublicized if true, treat all unpublicized options\n   * and option groups as publicized\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   */\n  public String usage(boolean include_unpublicized, String... group_names) {\n    if (!use_groups) {\n      if (group_names.length > 0) {\n        throw new IllegalArgumentException(\n            \"This instance of Options does not have any option groups defined\");\n      }\n      return format_options(\n          options, max_opt_len(options, include_unpublicized), include_unpublicized);\n    }\n\n    List<OptionGroupInfo> groups = new ArrayList<OptionGroupInfo>();\n    if (group_names.length > 0) {\n      for (String group_name : group_names) {\n        if (!group_map.containsKey(group_name)) {\n          throw new IllegalArgumentException(\"invalid option group: \" + group_name);\n        }\n        OptionGroupInfo gi = group_map.get(group_name);\n        if (!include_unpublicized && !gi.any_publicized()) {\n          throw new IllegalArgumentException(\n              \"group does not contain any publicized options: \" + group_name);\n        } else {\n          groups.add(group_map.get(group_name));\n        }\n      }\n    } else { // return usage for all groups that are not unpublicized\n      for (OptionGroupInfo gi : group_map.values()) {\n        if ((gi.unpublicized || !gi.any_publicized()) && !include_unpublicized) {\n          continue;\n        }\n        groups.add(gi);\n      }\n    }\n\n    List<Integer> lengths = new ArrayList<Integer>();\n    for (OptionGroupInfo gi : groups) {\n      lengths.add(max_opt_len(gi.optionList, include_unpublicized));\n    }\n    int max_len = Collections.max(lengths);\n\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionGroupInfo gi : groups) {\n      buf.append(String.format(\"%n%s:\", gi.name));\n      buf.append(format_options(gi.optionList, max_len, include_unpublicized));\n    }\n\n    return buf.toString();\n  }\n\n  /**\n   * Format a list of options for use in generating usage messages.\n   */\n  private String format_options(\n      List<OptionInfo> opt_list, int max_len, boolean include_unpublicized) {\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      String default_str = \"\";\n      if (oi.default_str != null) {\n        default_str = String.format(\" [default %s]\", oi.default_str);\n      }\n\n      @SuppressWarnings(\"formatter\") // format string computed from max_len argument\n      String use =\n          String.format(\"  %-\" + max_len + \"s - %s%s\", oi.synopsis(), oi.description, default_str);\n      buf.append(use);\n    }\n    return buf.toString();\n  }\n\n  /**\n   * Return the length of the longest synopsis message in a list of options.\n   * Useful for aligning options in usage strings.\n   * @return the length of the longest synopsis message in a list of options\n   */\n  private int max_opt_len(List<OptionInfo> opt_list, boolean include_unpublicized) {\n    int max_len = 0;\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      int len = oi.synopsis().length();\n      if (len > max_len) {\n        max_len = len;\n      }\n    }\n    return max_len;\n  }\n\n  /**\n   * Package-private accessors/utility methods that are needed by the\n   * OptionsDoclet class to generate HTML documentation.\n   */\n  /*@Pure*/\n  boolean isUsingGroups() {\n    return use_groups;\n  }\n\n  /*@Pure*/\n  boolean isUsingSingleDash() {\n    return use_single_dash;\n  }\n\n  List<OptionInfo> getOptions() {\n    return options;\n  }\n\n  Collection<OptionGroupInfo> getOptionGroups() {\n    return group_map.values();\n  }\n\n  /**\n   * Set the specified option to the value specified in arg_value.  Throws\n   * an ArgException if there are any errors.\n   */\n  private void set_arg(OptionInfo oi, String arg_name, /*@Nullable*/ String arg_value)\n      throws ArgException {\n\n    Field f = oi.field;\n    Class<?> type = oi.base_type;\n\n    // Keep track of all of the options specified\n    if (options_str.length() > 0) {\n      options_str += \" \";\n    }\n    options_str += arg_name;\n    if (arg_value != null) {\n      if (!arg_value.contains(\" \")) {\n        options_str += \"=\" + arg_value;\n      } else if (!arg_value.contains(\"'\")) {\n        options_str += \"='\" + arg_value + \"'\";\n      } else if (!arg_value.contains(\"\\\"\")) {\n        options_str += \"=\\\"\" + arg_value + \"\\\"\";\n      } else {\n        throw new ArgException(\"Can't quote for internal debugging: \" + arg_value);\n      }\n    }\n    // Argument values are required for everything but booleans\n    if (arg_value == null) {\n      if ((type != Boolean.TYPE) || (type != Boolean.class)) {\n        arg_value = \"true\";\n      } else {\n        throw new ArgException(\"Value required for option \" + arg_name);\n      }\n    }\n\n    try {\n      if (type.isPrimitive()) {\n        if (type == Boolean.TYPE) {\n          boolean val;\n          String arg_value_lowercase = arg_value.toLowerCase();\n          if (arg_value_lowercase.equals(\"true\") || (arg_value_lowercase.equals(\"t\"))) {\n            val = true;\n          } else if (arg_value_lowercase.equals(\"false\") || arg_value_lowercase.equals(\"f\")) {\n            val = false;\n          } else {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a boolean\", arg_value, arg_name);\n          }\n          arg_value = (val) ? \"true\" : \"false\";\n          // System.out.printf (\"Setting %s to %s%n\", arg_name, val);\n          f.setBoolean(oi.obj, val);\n        } else if (type == Integer.TYPE) {\n          int val;\n          try {\n            val = Integer.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not an integer\", arg_value, arg_name);\n          }\n          f.setInt(oi.obj, val);\n        } else if (type == Long.TYPE) {\n          long val;\n          try {\n            val = Long.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a long integer\", arg_value, arg_name);\n          }\n          f.setLong(oi.obj, val);\n        } else if (type == Float.TYPE) {\n          Float val;\n          try {\n            val = Float.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a float\", arg_value, arg_name);\n          }\n          f.setFloat(oi.obj, val);\n        } else if (type == Double.TYPE) {\n          Double val;\n          try {\n            val = Double.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a double\", arg_value, arg_name);\n          }\n          f.setDouble(oi.obj, val);\n        } else { // unexpected type\n          throw new Error(\"Unexpected type \" + type);\n        }\n      } else { // reference type\n\n        // If the argument is a list, add repeated arguments or multiple\n        // blank separated arguments to the list, otherwise just set the\n        // argument value.\n        if (oi.list != null) {\n          if (split_lists) {\n            String[] aarr = arg_value.split(\"  *\");\n            for (String aval : aarr) {\n              Object val = get_ref_arg(oi, arg_name, aval);\n              oi.list.add(val); // uncheck cast\n            }\n          } else {\n            Object val = get_ref_arg(oi, arg_name, arg_value);\n            oi.list.add(val);\n          }\n        } else {\n          Object val = get_ref_arg(oi, arg_name, arg_value);\n          f.set(oi.obj, val);\n        }\n      }\n    } catch (ArgException ae) {\n      throw ae;\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error \", e);\n    }\n  }\n\n  /**\n   * Create an instance of the correct type by passing the argument value\n   * string to the constructor.  The only expected error is some sort\n   * of parse error from the constructor.\n   */\n  private /*@NonNull*/ Object get_ref_arg(OptionInfo oi, String arg_name, String arg_value)\n      throws ArgException {\n\n    Object val = null;\n    try {\n      if (oi.constructor != null) {\n        val = oi.constructor.newInstance(new Object[] {arg_value});\n      } else if (oi.base_type.isEnum()) {\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Object tmpVal = getEnumValue((Class<Enum>) oi.base_type, arg_value);\n        val = tmpVal;\n      } else {\n        if (oi.factory == null) {\n          throw new Error(\"No constructor or factory for argument \" + arg_name);\n        }\n        @SuppressWarnings(\"nullness\") // oi.factory is a static method, so null first argument is OK\n        Object tmpVal = oi.factory.invoke(null, arg_value);\n        val = tmpVal;\n      }\n    } catch (Exception e) {\n      throw new ArgException(\"Invalid argument (%s) for argument %s\", arg_value, arg_name);\n    }\n\n    assert val != null : \"@AssumeAssertion(nullness)\";\n    return val;\n  }\n\n  /**\n   * Behaves like {@link java.lang.Enum#valueOf}, except that <code>name</code>\n   * is case-insensitive and hyphen-insensitive (hyphens can be used in place of\n   * underscores).  This allows for greater flexibility when specifying enum\n   * types as command-line arguments.\n   * @param <T> the enum type\n   */\n  private <T extends Enum<T>> T getEnumValue(Class<T> enumType, String name) {\n    T[] constants = enumType.getEnumConstants();\n    if (constants == null) {\n      throw new IllegalArgumentException(enumType.getName() + \" is not an enum type\");\n    }\n    for (T constant : constants) {\n      if (constant.name().equalsIgnoreCase(name.replace('-', '_'))) {\n        return constant;\n      }\n    }\n    // same error that's thrown by Enum.valueOf()\n    throw new IllegalArgumentException(\n        \"No enum constant \" + enumType.getCanonicalName() + \".\" + name);\n  }\n\n  /**\n   * Return a short name for the specified type for use in messages.\n   * @return a short name for the specified type for use in messages\n   */\n  private static String type_short_name(Class<?> type) {\n\n    if (type.isPrimitive()) {\n      return type.getName();\n    } else if (type == File.class) {\n      return \"filename\";\n    } else if (type == Pattern.class) {\n      return \"regex\";\n    } else if (type.isEnum()) {\n      return (\"enum\");\n    } else {\n      return type.getSimpleName().toLowerCase();\n    }\n  }\n\n  /**\n   * Returns a string containing all of the options that were set and their\n   * arguments.  This is essentially the contents of args[] with all\n   * non-options removed.\n   * @return options, similarly to supplied on the command line\n   * @see #settings()\n   */\n  public String get_options_str() {\n    return (options_str);\n  }\n\n  /**\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   * @return options, similarly to supplied on the command line\n   */\n  public String settings() {\n    return settings(false);\n  }\n\n  /**\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   *\n   * @param include_unpublicized  if true, treat all unpublicized options\n   * and option groups as publicized\n   * @return options, similarly to supplied on the command line\n   */\n  public String settings(boolean include_unpublicized) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    // Determine the length of the longest name\n    int max_len = max_opt_len(options, include_unpublicized);\n\n    // Create the settings string\n    for (OptionInfo oi : options) {\n      @SuppressWarnings(\"formatter\") // format string computed from max_len\n      String use = String.format(\"%-\" + max_len + \"s = \", oi.long_name);\n      try {\n        use += oi.field.get(oi.obj);\n      } catch (Exception e) {\n        throw new Error(\"unexpected exception reading field \" + oi.field, e);\n      }\n      out.append(use);\n    }\n\n    return out.toString();\n  }\n\n  /**\n   * Return a description of all of the known options.\n   * Each option is described on its own line in the output.\n   * @return a description of all of the known options\n   */\n  @Override\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public String toString(/*>>>@GuardSatisfied Options this*/) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    for (OptionInfo oi : options) {\n      out.append(oi);\n    }\n\n    return out.toString();\n  }\n\n  /**\n   * Exceptions encountered during argument processing.\n   */\n  public static class ArgException extends Exception {\n    static final long serialVersionUID = 20051223L;\n\n    public ArgException(String s) {\n      super(s);\n    }\n\n    @SuppressWarnings(\"formatter\") // acts as format method wrapper\n    public ArgException(String format, /*@Nullable*/ Object... args) {\n      super(String.format(format, args));\n    }\n  }\n\n  private static class ParseResult {\n    /*@Nullable*/ String short_name;\n    /*@Nullable*/ String type_name;\n    String description;\n\n    ParseResult(\n        /*@Nullable*/ String short_name, /*@Nullable*/ String type_name, String description) {\n      this.short_name = short_name;\n      this.type_name = type_name;\n      this.description = description;\n    }\n  }\n\n  /**\n   * Parse an option value and return its three components (short_name,\n   * type_name, and description).  The short_name and type_name are null\n   * if they are not specified in the string.\n   */\n  private static ParseResult parse_option(String val) {\n\n    // Get the short name, long name, and description\n    String short_name;\n    String type_name;\n    /*@NonNull*/ String description;\n\n    // Get the short name (if any)\n    if (val.startsWith(\"-\")) {\n      if (val.length() < 4 || !val.substring(2, 3).equals(\" \")) {\n        throw new Error(\n            \"Malformed @Option argument \\\"\"\n                + val\n                + \"\\\".  An argument that starts with '-' should contain a short name, a space, and a description.\");\n      }\n      short_name = val.substring(1, 2);\n      description = val.substring(3);\n    } else {\n      short_name = null;\n      description = val;\n    }\n\n    // Get the type name (if any)\n    if (description.startsWith(\"<\")) {\n      type_name = description.substring(1).replaceFirst(\">.*\", \"\");\n      description = description.replaceFirst(\"<.*> \", \"\");\n    } else {\n      type_name = null;\n    }\n\n    // Return the result\n    return new ParseResult(short_name, type_name, description);\n  }\n\n  //   /**\n  //    * Test class with some defined arguments.\n  //    */\n  //   private static class Test {\n  //\n  //     @Option (\"generic\") List<Pattern> lp = new ArrayList<Pattern>();\n  //     @Option (\"-a <filename> argument 1\") String arg1 = \"/tmp/foobar\";\n  //     @Option (\"argument 2\") String arg2;\n  //     @Option (\"-d double value\") double temperature;\n  //     @Option (\"-f the input file\") File input_file;\n  //   }\n  //\n  //   /**\n  //    * Simple example\n  //    */\n  //   private static void main (String[] args) throws ArgException {\n  //\n  //     Options options = new Options (\"test\", new Test());\n  //     System.out.printf (\"Options:%n%s\", options);\n  //     options.parse_or_usage (args);\n  //     System.out.printf (\"Results:%n%s\", options.settings());\n  //   }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "args", "", "String[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "settings", "plume", "Options", "public String settings()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "usage", "plume", "Options", "public String usage(String... group_names)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "parse", "plume", "Options", "public String[] parse(String args) throws ArgException" ], [ "isUsingSingleDash", "plume", "Options", "boolean isUsingSingleDash()" ], [ "getOptionGroups", "plume", "Options", "Collection<OptionGroupInfo> getOptionGroups()" ], [ "settings", "plume", "Options", "public String settings(boolean include_unpublicized)" ], [ "parse_or_usage", "plume", "Options", "public String[] parse_or_usage(String args)" ], [ "toString", "plume", "Options", "public String toString()" ], [ "parse", "plume", "Options", "public String[] parse(String[] args) throws ArgException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "isUsingGroups", "plume", "Options", "boolean isUsingGroups()" ], [ "getOptions", "plume", "Options", "List<OptionInfo> getOptions()" ], [ "get_options_str", "plume", "Options", "public String get_options_str()" ], [ "usage", "plume", "Options", "public String usage(boolean include_unpublicized, String... group_names)" ], [ "parse_or_usage", "plume", "Options", "public String[] parse_or_usage(String[] args)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "java.lang.String[]", "public boolean equals(Object);" ], [ "toString", "", "java.lang.String[]", "public String toString()" ], [ "hashCode", "", "java.lang.String[]", "public native int hashCode()" ], [ "getClass", "", "java.lang.String[]", "public final native Class getClass();" ], [ "clone", "", "java.lang.String[]", "public T[] clone();" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "usage_synopsis", "plume", "Options", "public String usage_synopsis = null;" ], [ "length", "java.lang", "String[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10773,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Options",
  "javadocTag" : "@throws ArgException if the command line contains misused options or an unknown option.",
  "methodJavadoc" : "    /**\n   * Parses a command line and sets the options accordingly.  This method\n   * splits the argument string into command-line arguments, respecting\n   * single and double quotes, then calls {@link #parse(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]</code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain</code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains misused options or an unknown option.\n   * @see #parse(String[])\n   */",
  "methodSourceCode" : "public String[] parse(String args) throws ArgException{\n    // Split the args string on whitespace boundaries accounting for quoted\n    // strings.\n    args = args.trim();\n    List<String> arg_list = new ArrayList<String>();\n    String arg = \"\";\n    char active_quote = 0;\n    for (int ii = 0; ii < args.length(); ii++) {\n        char ch = args.charAt(ii);\n        if ((ch == '\\'') || (ch == '\"')) {\n            arg += ch;\n            ii++;\n            while ((ii < args.length()) && (args.charAt(ii) != ch)) {\n                arg += args.charAt(ii++);\n            }\n            arg += ch;\n        } else if (Character.isWhitespace(ch)) {\n            // System.out.printf (\"adding argument '%s'%n\", arg);\n            arg_list.add(arg);\n            arg = \"\";\n            while ((ii < args.length()) && Character.isWhitespace(args.charAt(ii))) {\n                ii++;\n            }\n            if (ii < args.length()) {\n                // Encountered a non-whitespace character.\n                // Back up to process it on the next loop iteration.\n                ii--;\n            }\n        } else {\n            // must be part of current argument\n            arg += ch;\n        }\n    }\n    if (!arg.equals(\"\")) {\n        arg_list.add(arg);\n    }\n    String[] argsArray = arg_list.toArray(new String[arg_list.size()]);\n    return parse(argsArray);\n}",
  "classJavadoc" : "/**\n * The Options class:\n * <ul>\n *   <li>parses command-line options and sets fields in your program accordingly,</li>\n *   <li>creates usage messages (such as printed by a <code>--help</code> option), and</li>\n *   <li>creates documentation suitable for a manual or manpage.</li>\n * </ul>\n * Thus, the programmer is freed from writing duplicative, boilerplate code\n * and documentation that could get out of sync with the rest of the program.\n * <p>\n *\n * The programmer does not have to write any code, only declare and\n * document variables.  For each field that you want to set from a\n * command-line argument, you write Javadoc and an @{@link plume.Option}\n * annotation.  Then, the field is automatically set from a command-line\n * option of the same name, and usage messages and printed documentation\n * are generated automatically.\n * <p>\n *\n * The main entry point is {@link #parse_or_usage(String[])}.\n * Typical use is:\n *\n * <!-- Example needs some more words of explanation and example command lines. -->\n * <pre>\n *  import plume.*;\n *\n *  public class MyProgram {\n *\n *    &#64;Option(\"-o &lt;filename&gt; the output file \")\n *    public static File outfile = new File(\"/tmp/foobar\");\n *\n *    &#64;Option(\"-i ignore case\")\n *    public static boolean ignore_case;\n *\n *    &#64;Option(\"set the initial temperature\")\n *    public static double temperature = 75.0;\n *\n *    public static void main(String[] args) {\n *      MyProgram myInstance = new MyProgram();\n *      Options options = new Options(\"MyProgram [options] infile outfile\",\n *                                    myInstance, MyUtilityClass.class);\n *      String[] remaining_args = options.parse_or_usage(args);\n *      ...\n *    }\n *  }</pre>\n * A user may invoke the program using the command-line arguments\n * <code>-o</code>, <code>--outfile</code>, <code>-i</code>, <code>--ignore-case</code>,\n * and <code>--temperature</code>. <p>\n *\n * The call to {@link #parse_or_usage} sets fields in object myInstance,\n * and sets static fields in class MyUtilityClass.  It returns the original\n * command line, with all options removed. <p>\n *\n * <b>@Option indicates a command-line option</b> <p>\n * The @{@link Option} annotation on a field specifies brief user documentation\n * and, optionally, a one-character short name that users may supply on the\n * command line.  The long name is taken from the name of the variable;\n * when the name contains an underscore, the user may substitute a hyphen\n * on the command line instead; for example, the --multi-word-variable\n * command-line option would set the variable multi_word_variable. <p>\n *\n * On the command line, the values for options are specified in the form\n * '--longname=value', '-shortname=value', '--longname value', or '-shortname\n * value'.  If {@link #use_single_dash(boolean)} is true, then the long names\n * take the form '-longname=value' or '-longname value'.  The value is\n * mandatory for all options except booleans.  Booleans are set to true if no\n * value is specified. <p>\n *\n * All arguments that start with '-' are processed as options.  To\n * terminate option processing at the first non-option argument, see {@link\n * #parse_options_after_arg(boolean)}.  Also, the special option '--'\n * terminates option processing; method <code>parse_or_usage</code> returns\n * all subsequent arguments (along with any preceding non-option arguments)\n * without scanning them for options. <p>\n *\n * A user may provide an option multiple times on the command line.  If the\n * field is a list, each entry is added to the list.  If the field is\n * not a list, then only the last occurrence is used (subsequent\n * occurrences overwrite the previous value). <p>\n *\n * <b>Unpublicized options</b> <p>\n * The @{@link Unpublicized} annotation causes an option not to be displayed\n * in the usage message.  This can be useful for options that are\n * preliminary, experimental, or for internal purposes only.  The @{@link\n * Unpublicized} annotation must be specified in addition to the @{@link\n * Option} annotation. <p>\n *\n * There are forms of the usage-message methods that can include even\n * unpublicized options; for example, see {@link #usage(boolean,String...)}.\n * <p>\n *\n * <b>Option groups</b> <p>\n * The @{@link OptionGroup} annotation can be used to assign a name to a set of\n * related options.  This is useful for organizing a list of\n * options.  Options in the same group are displayed under the same heading\n * in usage texts. <p>\n *\n * The @{@link OptionGroup} annotation must be specified on a field in addition\n * to an @{@link Option} annotation.  Note that, due to a deficiency in\n * Javadoc, an <code>@OptionGroup</code> annotation must appear underneath any\n * Javadoc comment for the field it applies to. <p>\n *\n * The <code>@OptionGroup</code> annotation acts like a delimiter &mdash; all\n * <code>@Option</code>-annotated fields up to the next\n * <code>@OptionGroup</code> annotation belong to the same group.  When using\n * option groups, the first <code>@Option</code>-annotated field of every class\n * and object passed to the {@link #Options(String, Object...)} constructor\n * must have an <code>@OptionGroup</code> annotation.  Furthermore, the first\n * parameter of an <code>@OptionGroup</code> annotation (the group name) must\n * be unique among all classes and objects passed to the {@link\n * #Options(String, Object...)} constructor. <p>\n *\n * If an option group itself is unpublicized:\n * <ul>\n *   <li>The default usage message omits the group and all options belonging\n *       to it.\n *   <li>An unpublicized option group (that has any publicized options) is\n *       included in documentation for a manual.\n *   <li>A field with an @{@link Unpublicized} annotation is excluded\n *       even when passing the group's name\n *       explicitly as a parameter to {@link #usage(String...)}.\n * </ul>\n *\n * If an option group is not unpublicized but contains only unpublicized\n * options, it will not be included in the default usage message. <p>\n *\n * <b>Option aliases</b> <p>\n * The @{@link Option} annotation has an optional parameter <code>aliases</code>,\n * which accepts an array of strings.  Each string in the array is an alias for\n * the option being defined and can be used in place of an option's long name\n * or short name.</p>\n *\n * For example:\n * <pre>\n *     // The user may supply --help, -h, or -help, all of which mean the same thing and set this variable\n *     &#64;Option(value=\"-h Print a help message\", aliases={\"-help\"})\n *     public static boolean help;</pre>\n *\n * Aliases should start with a single dash or double dash.\n * If there is only a single, one-character alias, it can be put at the\n * beginning of the value field without the need for an aliases field.\n * It is the user's responsibility to ensure that no alias is the same as other\n * options or aliases and that they can be parsed unambiguously. <p>\n *\n * <b>Generating documentation for a manual or manpage</b> <p>\n * The class Javadoc for a class that has a main method should generally\n * contain a summary of all command-line options.  Such a summary can also\n * be useful in other circumstances.\n * See the {@link plume.OptionsDoclet} class for instructions about generating\n * HTML documentation. <p>\n *\n * <b>Supported field types</b> <p>\n * A field with an @{@link Option} annotation may be of the following types:\n * <ul>\n *   <li>Primitive types:  boolean, int, long, float, double.\n *       (Primitives can also be represented as wrappers:  Boolean,\n *       Integer, Long, Float, Double.  Use of a wrapper type allows the\n *       argument to have no default value.)\n *   <li>Reference types that have a constructor with a single string\n *       parameter.\n *   <li>java.util.regex.Pattern.\n *   <li>enums.\n *   <li>Lists of any of the above reference types.\n * </ul> <p>\n *\n * <b>More examples</b> <p>\n *\n * Example clients of the Options library include {@link plume.Lookup},\n * <a href=\"https://randoop.github.io/randoop/manual/#command-line-options\">Randoop</a>, and\n * <a href=\"http://types.cs.washington.edu/javari/javarifier/#command-line-opts\">Javarifier</a>, among many others.  <p>\n *\n * <b>Limitations</b> <ul>\n *\n *  <li> Short options are only supported as separate entries\n *  (e.g., \"-a -b\") and not as a single group (e.g., \"-ab\").\n *\n *  <li> Not all primitive types are supported.\n *\n *  <li> Types without a constructor that takes a single <code>String</code>\n *  argument are not supported.\n *\n *  <li> The \"--no-long\" option to turn off a boolean option named \"long\"\n *  is not supported; use \"--long=false\" instead.\n *\n * </ul> <p>\n *\n * <b>Possible enhancements</b> <ul>\n *  <li> Positional arguments (non-options that must be provided in a given\n *  order) could be supported.\n * </ul>\n *\n * @see plume.Option\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n */",
  "classSourceCode" : "// The five files\n//   Option.java\n//   OptionGroup.java\n//   Options.java\n//   Unpublicized.java\n//   OptionsDoclet.java\n// together comprise the implementation of command-line processing.\n\npackage plume;\n\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.formatter.qual.*;\nimport org.checkerframework.checker.initialization.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * The Options class:\n * <ul>\n *   <li>parses command-line options and sets fields in your program accordingly,</li>\n *   <li>creates usage messages (such as printed by a <code>--help</code> option), and</li>\n *   <li>creates documentation suitable for a manual or manpage.</li>\n * </ul>\n * Thus, the programmer is freed from writing duplicative, boilerplate code\n * and documentation that could get out of sync with the rest of the program.\n * <p>\n *\n * The programmer does not have to write any code, only declare and\n * document variables.  For each field that you want to set from a\n * command-line argument, you write Javadoc and an @{@link plume.Option}\n * annotation.  Then, the field is automatically set from a command-line\n * option of the same name, and usage messages and printed documentation\n * are generated automatically.\n * <p>\n *\n * The main entry point is {@link #parse_or_usage(String[])}.\n * Typical use is:\n *\n * <!-- Example needs some more words of explanation and example command lines. -->\n * <pre>\n *  import plume.*;\n *\n *  public class MyProgram {\n *\n *    &#64;Option(\"-o &lt;filename&gt; the output file \")\n *    public static File outfile = new File(\"/tmp/foobar\");\n *\n *    &#64;Option(\"-i ignore case\")\n *    public static boolean ignore_case;\n *\n *    &#64;Option(\"set the initial temperature\")\n *    public static double temperature = 75.0;\n *\n *    public static void main(String[] args) {\n *      MyProgram myInstance = new MyProgram();\n *      Options options = new Options(\"MyProgram [options] infile outfile\",\n *                                    myInstance, MyUtilityClass.class);\n *      String[] remaining_args = options.parse_or_usage(args);\n *      ...\n *    }\n *  }</pre>\n * A user may invoke the program using the command-line arguments\n * <code>-o</code>, <code>--outfile</code>, <code>-i</code>, <code>--ignore-case</code>,\n * and <code>--temperature</code>. <p>\n *\n * The call to {@link #parse_or_usage} sets fields in object myInstance,\n * and sets static fields in class MyUtilityClass.  It returns the original\n * command line, with all options removed. <p>\n *\n * <b>@Option indicates a command-line option</b> <p>\n * The @{@link Option} annotation on a field specifies brief user documentation\n * and, optionally, a one-character short name that users may supply on the\n * command line.  The long name is taken from the name of the variable;\n * when the name contains an underscore, the user may substitute a hyphen\n * on the command line instead; for example, the --multi-word-variable\n * command-line option would set the variable multi_word_variable. <p>\n *\n * On the command line, the values for options are specified in the form\n * '--longname=value', '-shortname=value', '--longname value', or '-shortname\n * value'.  If {@link #use_single_dash(boolean)} is true, then the long names\n * take the form '-longname=value' or '-longname value'.  The value is\n * mandatory for all options except booleans.  Booleans are set to true if no\n * value is specified. <p>\n *\n * All arguments that start with '-' are processed as options.  To\n * terminate option processing at the first non-option argument, see {@link\n * #parse_options_after_arg(boolean)}.  Also, the special option '--'\n * terminates option processing; method <code>parse_or_usage</code> returns\n * all subsequent arguments (along with any preceding non-option arguments)\n * without scanning them for options. <p>\n *\n * A user may provide an option multiple times on the command line.  If the\n * field is a list, each entry is added to the list.  If the field is\n * not a list, then only the last occurrence is used (subsequent\n * occurrences overwrite the previous value). <p>\n *\n * <b>Unpublicized options</b> <p>\n * The @{@link Unpublicized} annotation causes an option not to be displayed\n * in the usage message.  This can be useful for options that are\n * preliminary, experimental, or for internal purposes only.  The @{@link\n * Unpublicized} annotation must be specified in addition to the @{@link\n * Option} annotation. <p>\n *\n * There are forms of the usage-message methods that can include even\n * unpublicized options; for example, see {@link #usage(boolean,String...)}.\n * <p>\n *\n * <b>Option groups</b> <p>\n * The @{@link OptionGroup} annotation can be used to assign a name to a set of\n * related options.  This is useful for organizing a list of\n * options.  Options in the same group are displayed under the same heading\n * in usage texts. <p>\n *\n * The @{@link OptionGroup} annotation must be specified on a field in addition\n * to an @{@link Option} annotation.  Note that, due to a deficiency in\n * Javadoc, an <code>@OptionGroup</code> annotation must appear underneath any\n * Javadoc comment for the field it applies to. <p>\n *\n * The <code>@OptionGroup</code> annotation acts like a delimiter &mdash; all\n * <code>@Option</code>-annotated fields up to the next\n * <code>@OptionGroup</code> annotation belong to the same group.  When using\n * option groups, the first <code>@Option</code>-annotated field of every class\n * and object passed to the {@link #Options(String, Object...)} constructor\n * must have an <code>@OptionGroup</code> annotation.  Furthermore, the first\n * parameter of an <code>@OptionGroup</code> annotation (the group name) must\n * be unique among all classes and objects passed to the {@link\n * #Options(String, Object...)} constructor. <p>\n *\n * If an option group itself is unpublicized:\n * <ul>\n *   <li>The default usage message omits the group and all options belonging\n *       to it.\n *   <li>An unpublicized option group (that has any publicized options) is\n *       included in documentation for a manual.\n *   <li>A field with an @{@link Unpublicized} annotation is excluded\n *       even when passing the group's name\n *       explicitly as a parameter to {@link #usage(String...)}.\n * </ul>\n *\n * If an option group is not unpublicized but contains only unpublicized\n * options, it will not be included in the default usage message. <p>\n *\n * <b>Option aliases</b> <p>\n * The @{@link Option} annotation has an optional parameter <code>aliases</code>,\n * which accepts an array of strings.  Each string in the array is an alias for\n * the option being defined and can be used in place of an option's long name\n * or short name.</p>\n *\n * For example:\n * <pre>\n *     // The user may supply --help, -h, or -help, all of which mean the same thing and set this variable\n *     &#64;Option(value=\"-h Print a help message\", aliases={\"-help\"})\n *     public static boolean help;</pre>\n *\n * Aliases should start with a single dash or double dash.\n * If there is only a single, one-character alias, it can be put at the\n * beginning of the value field without the need for an aliases field.\n * It is the user's responsibility to ensure that no alias is the same as other\n * options or aliases and that they can be parsed unambiguously. <p>\n *\n * <b>Generating documentation for a manual or manpage</b> <p>\n * The class Javadoc for a class that has a main method should generally\n * contain a summary of all command-line options.  Such a summary can also\n * be useful in other circumstances.\n * See the {@link plume.OptionsDoclet} class for instructions about generating\n * HTML documentation. <p>\n *\n * <b>Supported field types</b> <p>\n * A field with an @{@link Option} annotation may be of the following types:\n * <ul>\n *   <li>Primitive types:  boolean, int, long, float, double.\n *       (Primitives can also be represented as wrappers:  Boolean,\n *       Integer, Long, Float, Double.  Use of a wrapper type allows the\n *       argument to have no default value.)\n *   <li>Reference types that have a constructor with a single string\n *       parameter.\n *   <li>java.util.regex.Pattern.\n *   <li>enums.\n *   <li>Lists of any of the above reference types.\n * </ul> <p>\n *\n * <b>More examples</b> <p>\n *\n * Example clients of the Options library include {@link plume.Lookup},\n * <a href=\"https://randoop.github.io/randoop/manual/#command-line-options\">Randoop</a>, and\n * <a href=\"http://types.cs.washington.edu/javari/javarifier/#command-line-opts\">Javarifier</a>, among many others.  <p>\n *\n * <b>Limitations</b> <ul>\n *\n *  <li> Short options are only supported as separate entries\n *  (e.g., \"-a -b\") and not as a single group (e.g., \"-ab\").\n *\n *  <li> Not all primitive types are supported.\n *\n *  <li> Types without a constructor that takes a single <code>String</code>\n *  argument are not supported.\n *\n *  <li> The \"--no-long\" option to turn off a boolean option named \"long\"\n *  is not supported; use \"--long=false\" instead.\n *\n * </ul> <p>\n *\n * <b>Possible enhancements</b> <ul>\n *  <li> Positional arguments (non-options that must be provided in a given\n *  order) could be supported.\n * </ul>\n *\n * @see plume.Option\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n */\npublic class Options {\n\n  /** The system-dependent line separator. */\n  private static String eol = System.getProperty(\"line.separator\");\n\n  /** Information about an option. */\n  class OptionInfo {\n\n    /** What variable the option sets. */\n    Field field;\n\n    //    /** Option annotation on the field. */\n    //    Option option;\n\n    /** Object containing the field.  Null if the field is static. */\n    /*@UnknownInitialization*/ /*@Raw*/ /*@Nullable*/ Object obj;\n\n    /** Short (one-character) argument name. */\n    /*@Nullable*/ String short_name;\n\n    /** Long argument name. */\n    String long_name;\n\n    /** Aliases for this option. */\n    String[] aliases;\n\n    /** Argument description: the first line. */\n    String description;\n\n    /** Full Javadoc description. */\n    /*@Nullable*/ String jdoc;\n\n    /**\n     * Maps names of enum constants to their corresponding Javadoc.  This is\n     * used by OptionsDoclet to generate documentation for enum-type options.\n     * Null if the base_type is not an Enum.\n     */\n    /*@MonotonicNonNull*/ Map<String, String> enum_jdoc;\n\n    /**\n     * Name of the argument type.  Defaults to the type of the field, but\n     * user can override this in the option string.\n     */\n    String type_name;\n\n    /**\n     * Class type of this field.  If the field is a list, the basetype\n     * of the list.\n     */\n    Class<?> base_type;\n\n    /** Default value of the option as a string. */\n    /*@Nullable*/ String default_str = null;\n\n    /**\n     * If true, the default value string for this option will be excluded from\n     * OptionsDoclet documentation.\n     */\n    boolean no_doc_default = false;\n\n    /** If the option is a list, this references that list. */\n    /*@MonotonicNonNull*/ List<Object> list = null;\n\n    /** Constructor that takes one String for the type. */\n    /*@Nullable*/ Constructor<?> constructor = null;\n\n    /** Factory that takes a string (some classes don't have a string constructor) and always returns non-null. */\n    /*@Nullable*/ Method factory = null;\n\n    /**\n     * If true, this OptionInfo is not output when printing documentation.\n     * @see #usage()\n     */\n    boolean unpublicized;\n\n    /**\n     * Create a new OptionInfo.\n     * The short name, type name, and description are taken\n     * from the option parameter.  The long name is the name of the\n     * field.  The default value is the current value of the field.\n     * @param field the field to set\n     * @param option the option\n     * @param obj the object whose field will be set;\n     *   if obj is null, the field must be static\n     * @param unpublicized whether the option is unpublicized\n     */\n    OptionInfo(\n        Field field,\n        Option option,\n        /*@UnknownInitialization*/ /*@Raw*/ /*@Nullable*/ Object obj,\n        boolean unpublicized) {\n      this.field = field;\n      //      this.option = option;\n      this.obj = obj;\n      this.base_type = field.getType();\n      this.unpublicized = unpublicized;\n      this.aliases = option.aliases();\n      this.no_doc_default = option.noDocDefault();\n\n      // The long name is the name of the field\n      long_name = field.getName();\n      if (use_dashes) {\n        long_name = long_name.replace('_', '-');\n      }\n\n      // Get the default value (if any)\n      Object default_obj = null;\n      if (!Modifier.isPublic(field.getModifiers())) {\n        throw new Error(\"option field is not public: \" + field);\n      }\n      try {\n        default_obj = field.get(obj);\n        if (default_obj != null) {\n          default_str = default_obj.toString();\n        }\n      } catch (Exception e) {\n        throw new Error(\"Unexpected error getting default for \" + field, e);\n      }\n\n      if (field.getType().isArray()) {\n        throw new Error(\"@Option may not annotate a variable of array type: \" + field);\n      }\n\n      // Handle lists.  When a list argument is specified multiple times,\n      // each argument value is appended to the list.\n      Type gen_type = field.getGenericType();\n      if (gen_type instanceof ParameterizedType) {\n        ParameterizedType pt = (ParameterizedType) gen_type;\n        Type raw_type = pt.getRawType();\n        if (!raw_type.equals(List.class)) {\n          throw new Error(\n              \"@Option supports List<...> but no other parameterized type; it does not support type \"\n                  + pt\n                  + \" for field \"\n                  + field);\n        }\n        if (default_obj == null) {\n          List<Object> new_list = new ArrayList<Object>();\n          try {\n            field.set(obj, new_list);\n          } catch (Exception e) {\n            throw new Error(\"Unexpected error setting default for \" + field, e);\n          }\n          default_obj = new_list;\n        }\n        if (((List<?>) default_obj).isEmpty()) {\n          default_str = null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        List<Object> default_obj_as_list = (List<Object>) default_obj;\n        this.list = default_obj_as_list;\n        // System.out.printf (\"list default = %s%n\", list);\n        Type[] listTypeArgs = pt.getActualTypeArguments();\n        this.base_type = (Class<?>) (listTypeArgs.length == 0 ? Object.class : listTypeArgs[0]);\n\n        // System.out.printf (\"Param type for %s = %s%n\", field, pt);\n        // System.out.printf (\"raw type = %s, type = %s%n\", pt.getRawType(),\n        //                   pt.getActualTypeArguments()[0]);\n      }\n\n      // Get the short name, type name, and description from the annotation\n      ParseResult pr;\n      try {\n        pr = parse_option(option.value());\n      } catch (Throwable e) {\n        throw new Error(\n            \"Error while processing @Option(\\\"\" + option.value() + \"\\\") on '\" + field + \"'\", e);\n      }\n      short_name = pr.short_name;\n      if (pr.type_name != null) {\n        type_name = pr.type_name;\n      } else {\n        type_name = type_short_name(base_type);\n      }\n      description = pr.description;\n\n      // Get a constructor for non-primitive base types\n      if (!base_type.isPrimitive() && !base_type.isEnum()) {\n        try {\n          if (base_type == Pattern.class) {\n            factory = Pattern.class.getMethod(\"compile\", String.class);\n          } else { // look for a string constructor\n            constructor = base_type.getConstructor(String.class);\n          }\n        } catch (Exception e) {\n          throw new Error(\n              \"@Option does not support type \"\n                  + base_type\n                  + \" for field \"\n                  + field\n                  + \" because it does not have a string constructor\",\n              e);\n        }\n      }\n    }\n\n    /**\n     * Return whether or not this option has a required argument.\n     * @return whether or not this option has a required argument\n     */\n    public boolean argument_required() {\n      Class<?> type = field.getType();\n      return ((type != Boolean.TYPE) && (type != Boolean.class));\n    }\n\n    /**\n     * Returns a short synopsis of the option in the form\n     * <code>-s --long=&lt;type&gt;</code>\n     * <strong>or</strong> (if use_single_dash is true)\n     * <code>-s -long=&lt;type&gt;</code> .\n     */\n    public String synopsis() {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String name = prefix + long_name;\n      if (short_name != null) {\n        name = String.format(\"-%s %s\", short_name, name);\n      }\n      name += String.format(\"=<%s>\", type_name);\n      if (list != null) {\n        name += \" [+]\";\n      }\n      return (name);\n    }\n\n    /**\n     * Return a one-line description of the option.\n     * @return a one-line description of the option\n     */\n    @Override\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied OptionInfo this*/) {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String short_name_str = \"\";\n      if (short_name != null) {\n        short_name_str = \"-\" + short_name + \" \";\n      }\n      return String.format(\"%s%s%s field %s\", short_name_str, prefix, long_name, field);\n    }\n\n    /** Returns the class that declares this option.\n     * @return the class that declares this option\n     */\n    public Class<?> get_declaring_class() {\n      return field.getDeclaringClass();\n    }\n  }\n\n  /** Information about an option group. */\n  static class OptionGroupInfo {\n\n    /** The name of this option group. */\n    String name;\n\n    /**\n     * If true, this group of options will not be printed in usage output by\n     * default. However, the usage information for this option group can be\n     * printed by specifying the group explicitly in the call to {@link\n     * #usage}.\n     */\n    boolean unpublicized;\n\n    /** List of options that belong to this group. */\n    List<OptionInfo> optionList;\n\n    OptionGroupInfo(String name, boolean unpublicized) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = name;\n      this.unpublicized = unpublicized;\n    }\n\n    OptionGroupInfo(OptionGroup optionGroup) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = optionGroup.value();\n      this.unpublicized = optionGroup.unpublicized();\n    }\n\n    /**\n     * If false, this group of options does not contain any publicized options,\n     * so it will not be included in the default usage message.\n     */\n    boolean any_publicized() {\n      for (OptionInfo oi : optionList) {\n        if (!oi.unpublicized) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Whether to parse options after a non-option command-line argument.\n   * @see #parse_options_after_arg(boolean)\n   */\n  private boolean parse_options_after_arg = true;\n\n  /** All of the argument options as a single string. */\n  private String options_str = \"\";\n\n  /** First specified class.  Void stands for \"not yet initialized\". */\n  private Class<?> main_class = Void.TYPE;\n\n  /** List of all of the defined options. */\n  private final List<OptionInfo> options = new ArrayList<OptionInfo>();\n\n  /** Map from short or long option names (with leading dashes) to option information. */\n  private final Map<String, OptionInfo> name_map = new LinkedHashMap<String, OptionInfo>();\n\n  /** Map from option group name to option group information. */\n  private final Map<String, OptionGroupInfo> group_map =\n      new LinkedHashMap<String, OptionGroupInfo>();\n\n  /**\n   * If, after the Options constructor is called, use_groups is true, then the\n   * user is using @OptionGroup annotations correctly (as per the requirement\n   * specified above).  If false, then @OptionGroup annotations have not been\n   * specified on any @Option-annotated fields.  When @OptionGroup annotations\n   * are used incorrectly, an Error is thrown by the Options constructor.\n   */\n  private boolean use_groups;\n\n  /**\n   * Convert underscores to dashes in long options in usage messages.  Users\n   * may specify either the underscore or dashed name on the command line.\n   */\n  private final boolean use_dashes = true;\n\n  /**\n   * When true, long options take the form -longOption with a single dash,\n   * rather than the default --longOption with two dashes.\n   */\n  private boolean use_single_dash = false;\n\n  /**\n   * String describing \"[+]\" (copied from Mercurial).\n   */\n  private static final String LIST_HELP = \"[+] marked option can be specified multiple times\";\n\n  /**\n   * Whether printing the usage message should print LIST_HELP.  The default is\n   * to print LIST_HELP if the usage message contains an option that accepts a\n   * list as a parameter.\n   */\n  private boolean print_list_help = false;\n\n  /**\n   * When true, an argument to a option of list type is split, on\n   * whitespace, into multiple arguments each of which is added to the\n   * list.  When false, each argument to an option of list type is treated\n   * as a single element, no matter what characters it contains.\n   */\n  @Option(\"Treat arguments to lists as space-separated.\")\n  public static boolean split_lists = false;\n\n  /**\n   * Synopsis of usage.  Example:  \"prog [options] arg1 arg2 ...\"\n   * <p>\n   * This variable is public so that clients can reset it (useful for\n   * masquerading as another program, based on parsed options).\n   */\n  public /*@Nullable*/ String usage_synopsis = null;\n\n  // Debug loggers\n  // Does nothing if not enabled.\n  private final SimpleLog debug_options = new SimpleLog(false);\n\n  /**\n   * Enable or disable debug logging.\n   * @param enabled whether to enable or disable logging\n   */\n  public void enableDebugLogging(boolean enabled) {\n    debug_options.enabled = enabled;\n  }\n\n  /**\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case its static fields are set.  The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param args the classes whose options to process\n   */\n  public Options(/*@UnknownInitialization*/ /*@Raw*/ Object... args) {\n    this(\"\", args);\n  }\n\n  /**\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case it must be fully initalized and its static fields are set.\n   * The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param usage_synopsis a synopsis of how to call your program\n   * @param args the classes whose options to process\n   */\n  public Options(String usage_synopsis, /*@UnknownInitialization*/ /*@Raw*/ Object... args) {\n\n    if (args.length == 0) {\n      throw new Error(\"Must pass at least one object to Options constructor\");\n    }\n\n    this.usage_synopsis = usage_synopsis;\n\n    this.use_groups = false;\n\n    // true once the first @Option annotation is observed, false until then.\n    boolean seen_first_opt = false;\n\n    // Loop through each specified object or class\n    for (Object obj : args) {\n      boolean is_class = obj instanceof Class<?>;\n      String current_group = null;\n\n      @SuppressWarnings({\n        \"rawness\",\n        \"initialization\"\n      }) // if is_class is true, obj is a non-null initialized Class\n      /*@Initialized*/ /*@NonRaw*/ /*@NonNull*/ Class<?> clazz =\n          (is_class ? (/*@Initialized*/ /*@NonRaw*/ /*@NonNull*/ Class<?>) obj : obj.getClass());\n      if (main_class == Void.TYPE) {\n        main_class = clazz;\n      }\n      Field[] fields = clazz.getDeclaredFields();\n\n      for (Field f : fields) {\n        try {\n          // Possible exception because \"obj\" is not yet initialized; catch it and proceed\n          @SuppressWarnings(\"cast\")\n          Object obj_nonraw = (/*@Initialized*/ /*@NonRaw*/ Object) obj;\n          debug_options.log(\"Considering field %s of object %s%n\", f, obj_nonraw);\n        } catch (Throwable t) {\n          debug_options.log(\"Considering field %s of object of type %s%n\", f, obj.getClass());\n        }\n        try {\n          debug_options.log(\"  with annotations %s%n\", Arrays.toString(f.getDeclaredAnnotations()));\n        } catch (java.lang.ArrayStoreException e) {\n          if (e.getMessage() != null\n              && Objects.equals(\n                  e.getMessage(), \"sun.reflect.annotation.TypeNotPresentExceptionProxy\")) {\n            debug_options.log(\"  with TypeNotPresentExceptionProxy while getting annotations%n\");\n          } else {\n            throw e;\n          }\n        }\n        Option option = safeGetAnnotation(f, Option.class);\n        if (option == null) {\n          continue;\n        }\n\n        boolean unpublicized = safeGetAnnotation(f, Unpublicized.class) != null;\n\n        if (is_class && !Modifier.isStatic(f.getModifiers())) {\n          throw new Error(\"non-static option \" + f + \" in class \" + obj);\n        }\n\n        @SuppressWarnings(\n            \"initialization\") // \"new MyClass(underInitialization)\" yields @UnderInitialization even when @Initialized would be safe\n        /*@Initialized*/ OptionInfo oi =\n            new OptionInfo(f, option, is_class ? null : obj, unpublicized);\n        options.add(oi);\n\n        // FIXME: should also check that the option does not belong to an\n        // unpublicized option group\n        if (oi.list != null && !oi.unpublicized) {\n          print_list_help = true;\n        }\n\n        OptionGroup optionGroup = safeGetAnnotation(f, OptionGroup.class);\n\n        if (!seen_first_opt) {\n          seen_first_opt = true;\n          // This is the first @Option annotation encountered so we can decide\n          // now if the user intends to use option groups.\n          if (optionGroup != null) {\n            use_groups = true;\n          } else {\n            continue;\n          }\n        }\n\n        if (!use_groups) {\n          if (optionGroup != null) {\n            // The user included an @OptionGroup annotation in their code\n            // without including an @OptionGroup annotation on the first\n            // @Option-annotated field, hence violating the requirement.\n\n            // NOTE: changing this error string requires changes to TestPlume\n            throw new Error(\n                \"missing @OptionGroup annotation on the first \"\n                    + \"@Option-annotated field of class \"\n                    + main_class);\n          } else {\n            continue;\n          }\n        }\n\n        // use_groups is true at this point.  The variable current_group is set\n        // to null at the start of every iteration through 'args'.  This is so\n        // we can check that the first @Option-annotated field of every\n        // class/object in 'args' has an @OptionGroup annotation when use_groups\n        // is true, as required.\n        if (current_group == null && optionGroup == null) {\n          // NOTE: changing this error string requires changes to TestPlume\n          throw new Error(\"missing @OptionGroup annotation in field \" + f + \" of class \" + obj);\n        } else if (optionGroup != null) {\n          String name = optionGroup.value();\n          if (group_map.containsKey(name)) {\n            throw new Error(\"option group \" + name + \" declared twice\");\n          }\n          OptionGroupInfo gi = new OptionGroupInfo(optionGroup);\n          group_map.put(name, gi);\n          current_group = name;\n        } // current_group is non-null at this point\n        @SuppressWarnings(\"nullness\") // map key\n        /*@NonNull*/ OptionGroupInfo ogi = group_map.get(current_group);\n        ogi.optionList.add(oi);\n      } // loop through fields\n    } // loop through args\n\n    String prefix = use_single_dash ? \"-\" : \"--\";\n\n    // Add each option to the option name map\n    for (OptionInfo oi : options) {\n      if (oi.short_name != null) {\n        if (name_map.containsKey(\"-\" + oi.short_name)) {\n          throw new Error(\"short name \" + oi + \" appears twice\");\n        }\n        name_map.put(\"-\" + oi.short_name, oi);\n      }\n      if (name_map.containsKey(prefix + oi.long_name)) {\n        throw new Error(\"long name \" + oi + \" appears twice\");\n      }\n      name_map.put(prefix + oi.long_name, oi);\n      if (use_dashes && oi.long_name.contains(\"-\")) {\n        name_map.put(prefix + oi.long_name.replace('-', '_'), oi);\n      }\n      if (oi.aliases.length > 0) {\n        for (String alias : oi.aliases) {\n          if (name_map.containsKey(alias)) {\n            throw new Error(\"alias \" + oi + \" appears twice\");\n          }\n          name_map.put(alias, oi);\n        }\n      }\n    }\n  }\n\n  /**\n   * Like getAnnotation, but returns null (and prints a warning) rather\n   * than throwing an exception.\n   */\n  @SuppressWarnings(\n      \"initialization\") // bug; see test case checkers/tests/nullness/generics/OptionsTest.java\n  private static <T extends Annotation> /*@Nullable*/ T safeGetAnnotation(\n      Field f, Class<T> annotationClass) {\n    /*@Nullable*/ T annotation;\n    try {\n      @SuppressWarnings(\"cast\") // cast is redundant (except for type annotations)\n      /*@Nullable*/ T cast = f.getAnnotation((Class</*@NonNull*/ T>) annotationClass);\n      annotation = cast;\n    } catch (Exception e) {\n      // Can get\n      //   java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy\n      // when an annotation is not present at run time (example: @NonNull)\n      System.out.printf(\n          \"Exception in call to f.getAnnotation(%s)%n  for f=%s%n  %s%nClasspath =%n\",\n          annotationClass,\n          f,\n          e.getMessage());\n      //e.printStackTrace();\n      JWhich.printClasspath();\n      annotation = null;\n    }\n\n    return annotation;\n  }\n\n  /**\n   * If true, Options will parse arguments even after a non-option\n   * command-line argument.  Setting this to true is useful to permit users\n   * to write options at the end of a command line.  Setting this to false\n   * is useful to avoid processing arguments that are actually\n   * options/arguments for another program that this one will invoke.\n   * @param val whether to parse arguments after a non-option command-line argument\n   */\n  public void parse_options_after_arg(boolean val) {\n    parse_options_after_arg = val;\n  }\n\n  /**\n   * If true, long options (those derived from field names) will be parsed with\n   * a single dash prefix as in -longOption.  The default is false and long\n   * options will be parsed with a double dash prefix as in --longOption.\n   * @param val whether to parse long options with a single dash, as in -longOption\n   */\n  public void use_single_dash(boolean val) {\n    use_single_dash = val;\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.\n   * @param args the commandline to be parsed\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains unknown option or\n   * misused options.\n   */\n  public String[] parse(String[] args) throws ArgException {\n\n    List<String> non_options = new ArrayList<String>();\n    // If true, then \"--\" has been seen and any argument starting with \"-\"\n    // is processed as an ordinary argument, not as an option.\n    boolean ignore_options = false;\n\n    // Loop through each argument\n    String tail = \"\";\n    String arg;\n    for (int ii = 0; ii < args.length; ) {\n      // If there was a ',' separator in previous arg, use the tail as\n      // current arg; otherwise, fetch the next arg from args list.\n      if (tail.length() > 0) {\n        arg = tail;\n        tail = \"\";\n      } else {\n        arg = args[ii];\n      }\n\n      if (arg.equals(\"--\")) {\n        ignore_options = true;\n      } else if ((arg.startsWith(\"--\") || arg.startsWith(\"-\")) && !ignore_options) {\n        String arg_name;\n        String arg_value;\n\n        // Allow ',' as an argument separator to get around\n        // some command line quoting problems.  (markro)\n        int split_pos = arg.indexOf(\",-\");\n        if (split_pos == 0) {\n          // Just discard the ',' if \",-\" occurs at begining of string\n          arg = arg.substring(1);\n          split_pos = arg.indexOf(\",-\");\n        }\n        if (split_pos > 0) {\n          tail = arg.substring(split_pos + 1);\n          arg = arg.substring(0, split_pos);\n        }\n\n        int eq_pos = arg.indexOf('=');\n        if (eq_pos == -1) {\n          arg_name = arg;\n          arg_value = null;\n        } else {\n          arg_name = arg.substring(0, eq_pos);\n          arg_value = arg.substring(eq_pos + 1);\n        }\n        OptionInfo oi = name_map.get(arg_name);\n        if (oi == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(String.format(\"unknown option name '%s' in arg '%s'\", arg_name, arg));\n          if (false) { // for debugging\n            msg.append(\"; known options:\");\n            for (String option_name : UtilMDE.sortedKeySet(name_map)) {\n              msg.append(\" \");\n              msg.append(option_name);\n            }\n          }\n          throw new ArgException(msg.toString());\n        }\n        if (oi.argument_required() && (arg_value == null)) {\n          ii++;\n          if (ii >= args.length) {\n            throw new ArgException(\"option %s requires an argument\", arg);\n          }\n          arg_value = args[ii];\n        }\n        // System.out.printf (\"arg_name = '%s', arg_value='%s'%n\", arg_name,\n        //                    arg_value);\n        set_arg(oi, arg_name, arg_value);\n      } else { // not an option\n        if (!parse_options_after_arg) {\n          ignore_options = true;\n        }\n        non_options.add(arg);\n      }\n\n      // If no ',' tail, advance to next args option\n      if (tail.length() == 0) {\n        ii++;\n      }\n    }\n    String[] result = non_options.toArray(new String[non_options.size()]);\n    return result;\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  This method\n   * splits the argument string into command-line arguments, respecting\n   * single and double quotes, then calls {@link #parse(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]</code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain</code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains misused options or an unknown option.\n   * @see #parse(String[])\n   */\n  public String[] parse(String args) throws ArgException {\n\n    // Split the args string on whitespace boundaries accounting for quoted\n    // strings.\n    args = args.trim();\n    List<String> arg_list = new ArrayList<String>();\n    String arg = \"\";\n    char active_quote = 0;\n    for (int ii = 0; ii < args.length(); ii++) {\n      char ch = args.charAt(ii);\n      if ((ch == '\\'') || (ch == '\"')) {\n        arg += ch;\n        ii++;\n        while ((ii < args.length()) && (args.charAt(ii) != ch)) {\n          arg += args.charAt(ii++);\n        }\n        arg += ch;\n      } else if (Character.isWhitespace(ch)) {\n        // System.out.printf (\"adding argument '%s'%n\", arg);\n        arg_list.add(arg);\n        arg = \"\";\n        while ((ii < args.length()) && Character.isWhitespace(args.charAt(ii))) {\n          ii++;\n        }\n        if (ii < args.length()) {\n          // Encountered a non-whitespace character.\n          // Back up to process it on the next loop iteration.\n          ii--;\n        }\n      } else { // must be part of current argument\n        arg += ch;\n      }\n    }\n    if (!arg.equals(\"\")) {\n      arg_list.add(arg);\n    }\n\n    String[] argsArray = arg_list.toArray(new String[arg_list.size()]);\n    return parse(argsArray);\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse(String[])\n   */\n  public String[] parse_or_usage(String[] args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      // throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * <p>\n   * This method splits the argument string into command-line arguments,\n   * respecting single and double quotes, then calls\n   * {@link #parse_or_usage(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]</code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain</code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse_or_usage(String[])\n   */\n  public String[] parse_or_usage(String args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      // throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }\n\n  /// This is a lot of methods, but it does save a tad of typing for the\n  /// programmer.\n\n  /**\n   * Prints usage information.  Uses the usage synopsis passed into the\n   * constructor, if any.\n   * @param ps where to print usage information\n   */\n  public void print_usage(PrintStream ps) {\n    if (usage_synopsis != null) {\n      ps.printf(\"Usage: %s%n\", usage_synopsis);\n    }\n    ps.println(usage());\n    if (print_list_help) {\n      ps.println();\n      ps.println(LIST_HELP);\n    }\n  }\n\n  /**\n   * Prints, to standard output, usage information.\n   */\n  public void print_usage() {\n    print_usage(System.out);\n  }\n\n  // This method is distinct from\n  //   print_usage (PrintStream ps, String format, Object... args)\n  // because % characters in the message are not interpreted.\n  /**\n   * Prints a message followed by indented usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param msg message to print before usage information\n   */\n  public void print_usage(PrintStream ps, String msg) {\n    ps.println(msg);\n    print_usage(ps);\n  }\n\n  /**\n   * Prints, to standard output, a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param msg messag. to print before usage information\n   */\n  public void print_usage(String msg) {\n    print_usage(System.out, msg);\n  }\n\n  /**\n   * Prints a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   */\n  @SuppressWarnings(\"formatter\") // acts as format method wrapper\n  public void print_usage(PrintStream ps, String format, /*@Nullable*/ Object... args) {\n    ps.printf(format, args);\n    if (!format.endsWith(\"%n\")) {\n      ps.println();\n    }\n    print_usage(ps);\n  }\n\n  /**\n   * Prints, to standard output, a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   */\n  /*@FormatMethod*/\n  public void print_usage(String format, /*@Nullable*/ Object... args) {\n    print_usage(System.out, format, args);\n  }\n\n  /**\n   * Return the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   */\n  public String usage(String... group_names) {\n    return usage(false, group_names);\n  }\n\n  /**\n   * Returns the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param include_unpublicized if true, treat all unpublicized options\n   * and option groups as publicized\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   */\n  public String usage(boolean include_unpublicized, String... group_names) {\n    if (!use_groups) {\n      if (group_names.length > 0) {\n        throw new IllegalArgumentException(\n            \"This instance of Options does not have any option groups defined\");\n      }\n      return format_options(\n          options, max_opt_len(options, include_unpublicized), include_unpublicized);\n    }\n\n    List<OptionGroupInfo> groups = new ArrayList<OptionGroupInfo>();\n    if (group_names.length > 0) {\n      for (String group_name : group_names) {\n        if (!group_map.containsKey(group_name)) {\n          throw new IllegalArgumentException(\"invalid option group: \" + group_name);\n        }\n        OptionGroupInfo gi = group_map.get(group_name);\n        if (!include_unpublicized && !gi.any_publicized()) {\n          throw new IllegalArgumentException(\n              \"group does not contain any publicized options: \" + group_name);\n        } else {\n          groups.add(group_map.get(group_name));\n        }\n      }\n    } else { // return usage for all groups that are not unpublicized\n      for (OptionGroupInfo gi : group_map.values()) {\n        if ((gi.unpublicized || !gi.any_publicized()) && !include_unpublicized) {\n          continue;\n        }\n        groups.add(gi);\n      }\n    }\n\n    List<Integer> lengths = new ArrayList<Integer>();\n    for (OptionGroupInfo gi : groups) {\n      lengths.add(max_opt_len(gi.optionList, include_unpublicized));\n    }\n    int max_len = Collections.max(lengths);\n\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionGroupInfo gi : groups) {\n      buf.append(String.format(\"%n%s:\", gi.name));\n      buf.append(format_options(gi.optionList, max_len, include_unpublicized));\n    }\n\n    return buf.toString();\n  }\n\n  /**\n   * Format a list of options for use in generating usage messages.\n   */\n  private String format_options(\n      List<OptionInfo> opt_list, int max_len, boolean include_unpublicized) {\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      String default_str = \"\";\n      if (oi.default_str != null) {\n        default_str = String.format(\" [default %s]\", oi.default_str);\n      }\n\n      @SuppressWarnings(\"formatter\") // format string computed from max_len argument\n      String use =\n          String.format(\"  %-\" + max_len + \"s - %s%s\", oi.synopsis(), oi.description, default_str);\n      buf.append(use);\n    }\n    return buf.toString();\n  }\n\n  /**\n   * Return the length of the longest synopsis message in a list of options.\n   * Useful for aligning options in usage strings.\n   * @return the length of the longest synopsis message in a list of options\n   */\n  private int max_opt_len(List<OptionInfo> opt_list, boolean include_unpublicized) {\n    int max_len = 0;\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      int len = oi.synopsis().length();\n      if (len > max_len) {\n        max_len = len;\n      }\n    }\n    return max_len;\n  }\n\n  /**\n   * Package-private accessors/utility methods that are needed by the\n   * OptionsDoclet class to generate HTML documentation.\n   */\n  /*@Pure*/\n  boolean isUsingGroups() {\n    return use_groups;\n  }\n\n  /*@Pure*/\n  boolean isUsingSingleDash() {\n    return use_single_dash;\n  }\n\n  List<OptionInfo> getOptions() {\n    return options;\n  }\n\n  Collection<OptionGroupInfo> getOptionGroups() {\n    return group_map.values();\n  }\n\n  /**\n   * Set the specified option to the value specified in arg_value.  Throws\n   * an ArgException if there are any errors.\n   */\n  private void set_arg(OptionInfo oi, String arg_name, /*@Nullable*/ String arg_value)\n      throws ArgException {\n\n    Field f = oi.field;\n    Class<?> type = oi.base_type;\n\n    // Keep track of all of the options specified\n    if (options_str.length() > 0) {\n      options_str += \" \";\n    }\n    options_str += arg_name;\n    if (arg_value != null) {\n      if (!arg_value.contains(\" \")) {\n        options_str += \"=\" + arg_value;\n      } else if (!arg_value.contains(\"'\")) {\n        options_str += \"='\" + arg_value + \"'\";\n      } else if (!arg_value.contains(\"\\\"\")) {\n        options_str += \"=\\\"\" + arg_value + \"\\\"\";\n      } else {\n        throw new ArgException(\"Can't quote for internal debugging: \" + arg_value);\n      }\n    }\n    // Argument values are required for everything but booleans\n    if (arg_value == null) {\n      if ((type != Boolean.TYPE) || (type != Boolean.class)) {\n        arg_value = \"true\";\n      } else {\n        throw new ArgException(\"Value required for option \" + arg_name);\n      }\n    }\n\n    try {\n      if (type.isPrimitive()) {\n        if (type == Boolean.TYPE) {\n          boolean val;\n          String arg_value_lowercase = arg_value.toLowerCase();\n          if (arg_value_lowercase.equals(\"true\") || (arg_value_lowercase.equals(\"t\"))) {\n            val = true;\n          } else if (arg_value_lowercase.equals(\"false\") || arg_value_lowercase.equals(\"f\")) {\n            val = false;\n          } else {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a boolean\", arg_value, arg_name);\n          }\n          arg_value = (val) ? \"true\" : \"false\";\n          // System.out.printf (\"Setting %s to %s%n\", arg_name, val);\n          f.setBoolean(oi.obj, val);\n        } else if (type == Integer.TYPE) {\n          int val;\n          try {\n            val = Integer.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not an integer\", arg_value, arg_name);\n          }\n          f.setInt(oi.obj, val);\n        } else if (type == Long.TYPE) {\n          long val;\n          try {\n            val = Long.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a long integer\", arg_value, arg_name);\n          }\n          f.setLong(oi.obj, val);\n        } else if (type == Float.TYPE) {\n          Float val;\n          try {\n            val = Float.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a float\", arg_value, arg_name);\n          }\n          f.setFloat(oi.obj, val);\n        } else if (type == Double.TYPE) {\n          Double val;\n          try {\n            val = Double.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a double\", arg_value, arg_name);\n          }\n          f.setDouble(oi.obj, val);\n        } else { // unexpected type\n          throw new Error(\"Unexpected type \" + type);\n        }\n      } else { // reference type\n\n        // If the argument is a list, add repeated arguments or multiple\n        // blank separated arguments to the list, otherwise just set the\n        // argument value.\n        if (oi.list != null) {\n          if (split_lists) {\n            String[] aarr = arg_value.split(\"  *\");\n            for (String aval : aarr) {\n              Object val = get_ref_arg(oi, arg_name, aval);\n              oi.list.add(val); // uncheck cast\n            }\n          } else {\n            Object val = get_ref_arg(oi, arg_name, arg_value);\n            oi.list.add(val);\n          }\n        } else {\n          Object val = get_ref_arg(oi, arg_name, arg_value);\n          f.set(oi.obj, val);\n        }\n      }\n    } catch (ArgException ae) {\n      throw ae;\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error \", e);\n    }\n  }\n\n  /**\n   * Create an instance of the correct type by passing the argument value\n   * string to the constructor.  The only expected error is some sort\n   * of parse error from the constructor.\n   */\n  private /*@NonNull*/ Object get_ref_arg(OptionInfo oi, String arg_name, String arg_value)\n      throws ArgException {\n\n    Object val = null;\n    try {\n      if (oi.constructor != null) {\n        val = oi.constructor.newInstance(new Object[] {arg_value});\n      } else if (oi.base_type.isEnum()) {\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Object tmpVal = getEnumValue((Class<Enum>) oi.base_type, arg_value);\n        val = tmpVal;\n      } else {\n        if (oi.factory == null) {\n          throw new Error(\"No constructor or factory for argument \" + arg_name);\n        }\n        @SuppressWarnings(\"nullness\") // oi.factory is a static method, so null first argument is OK\n        Object tmpVal = oi.factory.invoke(null, arg_value);\n        val = tmpVal;\n      }\n    } catch (Exception e) {\n      throw new ArgException(\"Invalid argument (%s) for argument %s\", arg_value, arg_name);\n    }\n\n    assert val != null : \"@AssumeAssertion(nullness)\";\n    return val;\n  }\n\n  /**\n   * Behaves like {@link java.lang.Enum#valueOf}, except that <code>name</code>\n   * is case-insensitive and hyphen-insensitive (hyphens can be used in place of\n   * underscores).  This allows for greater flexibility when specifying enum\n   * types as command-line arguments.\n   * @param <T> the enum type\n   */\n  private <T extends Enum<T>> T getEnumValue(Class<T> enumType, String name) {\n    T[] constants = enumType.getEnumConstants();\n    if (constants == null) {\n      throw new IllegalArgumentException(enumType.getName() + \" is not an enum type\");\n    }\n    for (T constant : constants) {\n      if (constant.name().equalsIgnoreCase(name.replace('-', '_'))) {\n        return constant;\n      }\n    }\n    // same error that's thrown by Enum.valueOf()\n    throw new IllegalArgumentException(\n        \"No enum constant \" + enumType.getCanonicalName() + \".\" + name);\n  }\n\n  /**\n   * Return a short name for the specified type for use in messages.\n   * @return a short name for the specified type for use in messages\n   */\n  private static String type_short_name(Class<?> type) {\n\n    if (type.isPrimitive()) {\n      return type.getName();\n    } else if (type == File.class) {\n      return \"filename\";\n    } else if (type == Pattern.class) {\n      return \"regex\";\n    } else if (type.isEnum()) {\n      return (\"enum\");\n    } else {\n      return type.getSimpleName().toLowerCase();\n    }\n  }\n\n  /**\n   * Returns a string containing all of the options that were set and their\n   * arguments.  This is essentially the contents of args[] with all\n   * non-options removed.\n   * @return options, similarly to supplied on the command line\n   * @see #settings()\n   */\n  public String get_options_str() {\n    return (options_str);\n  }\n\n  /**\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   * @return options, similarly to supplied on the command line\n   */\n  public String settings() {\n    return settings(false);\n  }\n\n  /**\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   *\n   * @param include_unpublicized  if true, treat all unpublicized options\n   * and option groups as publicized\n   * @return options, similarly to supplied on the command line\n   */\n  public String settings(boolean include_unpublicized) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    // Determine the length of the longest name\n    int max_len = max_opt_len(options, include_unpublicized);\n\n    // Create the settings string\n    for (OptionInfo oi : options) {\n      @SuppressWarnings(\"formatter\") // format string computed from max_len\n      String use = String.format(\"%-\" + max_len + \"s = \", oi.long_name);\n      try {\n        use += oi.field.get(oi.obj);\n      } catch (Exception e) {\n        throw new Error(\"unexpected exception reading field \" + oi.field, e);\n      }\n      out.append(use);\n    }\n\n    return out.toString();\n  }\n\n  /**\n   * Return a description of all of the known options.\n   * Each option is described on its own line in the output.\n   * @return a description of all of the known options\n   */\n  @Override\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public String toString(/*>>>@GuardSatisfied Options this*/) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    for (OptionInfo oi : options) {\n      out.append(oi);\n    }\n\n    return out.toString();\n  }\n\n  /**\n   * Exceptions encountered during argument processing.\n   */\n  public static class ArgException extends Exception {\n    static final long serialVersionUID = 20051223L;\n\n    public ArgException(String s) {\n      super(s);\n    }\n\n    @SuppressWarnings(\"formatter\") // acts as format method wrapper\n    public ArgException(String format, /*@Nullable*/ Object... args) {\n      super(String.format(format, args));\n    }\n  }\n\n  private static class ParseResult {\n    /*@Nullable*/ String short_name;\n    /*@Nullable*/ String type_name;\n    String description;\n\n    ParseResult(\n        /*@Nullable*/ String short_name, /*@Nullable*/ String type_name, String description) {\n      this.short_name = short_name;\n      this.type_name = type_name;\n      this.description = description;\n    }\n  }\n\n  /**\n   * Parse an option value and return its three components (short_name,\n   * type_name, and description).  The short_name and type_name are null\n   * if they are not specified in the string.\n   */\n  private static ParseResult parse_option(String val) {\n\n    // Get the short name, long name, and description\n    String short_name;\n    String type_name;\n    /*@NonNull*/ String description;\n\n    // Get the short name (if any)\n    if (val.startsWith(\"-\")) {\n      if (val.length() < 4 || !val.substring(2, 3).equals(\" \")) {\n        throw new Error(\n            \"Malformed @Option argument \\\"\"\n                + val\n                + \"\\\".  An argument that starts with '-' should contain a short name, a space, and a description.\");\n      }\n      short_name = val.substring(1, 2);\n      description = val.substring(3);\n    } else {\n      short_name = null;\n      description = val;\n    }\n\n    // Get the type name (if any)\n    if (description.startsWith(\"<\")) {\n      type_name = description.substring(1).replaceFirst(\">.*\", \"\");\n      description = description.replaceFirst(\"<.*> \", \"\");\n    } else {\n      type_name = null;\n    }\n\n    // Return the result\n    return new ParseResult(short_name, type_name, description);\n  }\n\n  //   /**\n  //    * Test class with some defined arguments.\n  //    */\n  //   private static class Test {\n  //\n  //     @Option (\"generic\") List<Pattern> lp = new ArrayList<Pattern>();\n  //     @Option (\"-a <filename> argument 1\") String arg1 = \"/tmp/foobar\";\n  //     @Option (\"argument 2\") String arg2;\n  //     @Option (\"-d double value\") double temperature;\n  //     @Option (\"-f the input file\") File input_file;\n  //   }\n  //\n  //   /**\n  //    * Simple example\n  //    */\n  //   private static void main (String[] args) throws ArgException {\n  //\n  //     Options options = new Options (\"test\", new Test());\n  //     System.out.printf (\"Options:%n%s\", options);\n  //     options.parse_or_usage (args);\n  //     System.out.printf (\"Results:%n%s\", options.settings());\n  //   }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "args", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "settings", "plume", "Options", "public String settings(boolean include_unpublicized)" ], [ "usage", "plume", "Options", "public String usage(boolean include_unpublicized, String... group_names)" ], [ "parse_or_usage", "plume", "Options", "public String[] parse_or_usage(String[] args)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "parse_or_usage", "plume", "Options", "public String[] parse_or_usage(String args)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "isUsingSingleDash", "plume", "Options", "boolean isUsingSingleDash()" ], [ "settings", "plume", "Options", "public String settings()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "parse", "plume", "Options", "public String[] parse(String[] args) throws ArgException" ], [ "getOptionGroups", "plume", "Options", "Collection<OptionGroupInfo> getOptionGroups()" ], [ "get_options_str", "plume", "Options", "public String get_options_str()" ], [ "isUsingGroups", "plume", "Options", "boolean isUsingGroups()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getOptions", "plume", "Options", "List<OptionInfo> getOptions()" ], [ "usage", "plume", "Options", "public String usage(String... group_names)" ], [ "toString", "plume", "Options", "public String toString()" ], [ "parse", "plume", "Options", "public String[] parse(String args) throws ArgException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "equals", "", "java.lang.String[]", "public boolean equals(Object);" ], [ "toString", "", "java.lang.String[]", "public String toString()" ], [ "hashCode", "", "java.lang.String[]", "public native int hashCode()" ], [ "getClass", "", "java.lang.String[]", "public final native Class getClass();" ], [ "clone", "", "java.lang.String[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "usage_synopsis", "plume", "Options", "public String usage_synopsis = null;" ], [ "length", "java.lang", "String[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10784,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "Options",
  "javadocTag" : "@param args objects to put in formatted message",
  "methodJavadoc" : "    /**\n   * Prints a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   */",
  "methodSourceCode" : "public void print_usage(PrintStream ps, String format, /*@Nullable*/\nObject... args){\n    ps.printf(format, args);\n    if (!format.endsWith(\"%n\")) {\n        ps.println();\n    }\n    print_usage(ps);\n}",
  "classJavadoc" : "/**\n * The Options class:\n * <ul>\n *   <li>parses command-line options and sets fields in your program accordingly,</li>\n *   <li>creates usage messages (such as printed by a <code>--help</code> option), and</li>\n *   <li>creates documentation suitable for a manual or manpage.</li>\n * </ul>\n * Thus, the programmer is freed from writing duplicative, boilerplate code\n * and documentation that could get out of sync with the rest of the program.\n * <p>\n *\n * The programmer does not have to write any code, only declare and\n * document variables.  For each field that you want to set from a\n * command-line argument, you write Javadoc and an @{@link plume.Option}\n * annotation.  Then, the field is automatically set from a command-line\n * option of the same name, and usage messages and printed documentation\n * are generated automatically.\n * <p>\n *\n * The main entry point is {@link #parse_or_usage(String[])}.\n * Typical use is:\n *\n * <!-- Example needs some more words of explanation and example command lines. -->\n * <pre>\n *  import plume.*;\n *\n *  public class MyProgram {\n *\n *    &#64;Option(\"-o &lt;filename&gt; the output file \")\n *    public static File outfile = new File(\"/tmp/foobar\");\n *\n *    &#64;Option(\"-i ignore case\")\n *    public static boolean ignore_case;\n *\n *    &#64;Option(\"set the initial temperature\")\n *    public static double temperature = 75.0;\n *\n *    public static void main(String[] args) {\n *      MyProgram myInstance = new MyProgram();\n *      Options options = new Options(\"MyProgram [options] infile outfile\",\n *                                    myInstance, MyUtilityClass.class);\n *      String[] remaining_args = options.parse_or_usage(args);\n *      ...\n *    }\n *  }</pre>\n * A user may invoke the program using the command-line arguments\n * <code>-o</code>, <code>--outfile</code>, <code>-i</code>, <code>--ignore-case</code>,\n * and <code>--temperature</code>. <p>\n *\n * The call to {@link #parse_or_usage} sets fields in object myInstance,\n * and sets static fields in class MyUtilityClass.  It returns the original\n * command line, with all options removed. <p>\n *\n * <b>@Option indicates a command-line option</b> <p>\n * The @{@link Option} annotation on a field specifies brief user documentation\n * and, optionally, a one-character short name that users may supply on the\n * command line.  The long name is taken from the name of the variable;\n * when the name contains an underscore, the user may substitute a hyphen\n * on the command line instead; for example, the --multi-word-variable\n * command-line option would set the variable multi_word_variable. <p>\n *\n * On the command line, the values for options are specified in the form\n * '--longname=value', '-shortname=value', '--longname value', or '-shortname\n * value'.  If {@link #use_single_dash(boolean)} is true, then the long names\n * take the form '-longname=value' or '-longname value'.  The value is\n * mandatory for all options except booleans.  Booleans are set to true if no\n * value is specified. <p>\n *\n * All arguments that start with '-' are processed as options.  To\n * terminate option processing at the first non-option argument, see {@link\n * #parse_options_after_arg(boolean)}.  Also, the special option '--'\n * terminates option processing; method <code>parse_or_usage</code> returns\n * all subsequent arguments (along with any preceding non-option arguments)\n * without scanning them for options. <p>\n *\n * A user may provide an option multiple times on the command line.  If the\n * field is a list, each entry is added to the list.  If the field is\n * not a list, then only the last occurrence is used (subsequent\n * occurrences overwrite the previous value). <p>\n *\n * <b>Unpublicized options</b> <p>\n * The @{@link Unpublicized} annotation causes an option not to be displayed\n * in the usage message.  This can be useful for options that are\n * preliminary, experimental, or for internal purposes only.  The @{@link\n * Unpublicized} annotation must be specified in addition to the @{@link\n * Option} annotation. <p>\n *\n * There are forms of the usage-message methods that can include even\n * unpublicized options; for example, see {@link #usage(boolean,String...)}.\n * <p>\n *\n * <b>Option groups</b> <p>\n * The @{@link OptionGroup} annotation can be used to assign a name to a set of\n * related options.  This is useful for organizing a list of\n * options.  Options in the same group are displayed under the same heading\n * in usage texts. <p>\n *\n * The @{@link OptionGroup} annotation must be specified on a field in addition\n * to an @{@link Option} annotation.  Note that, due to a deficiency in\n * Javadoc, an <code>@OptionGroup</code> annotation must appear underneath any\n * Javadoc comment for the field it applies to. <p>\n *\n * The <code>@OptionGroup</code> annotation acts like a delimiter &mdash; all\n * <code>@Option</code>-annotated fields up to the next\n * <code>@OptionGroup</code> annotation belong to the same group.  When using\n * option groups, the first <code>@Option</code>-annotated field of every class\n * and object passed to the {@link #Options(String, Object...)} constructor\n * must have an <code>@OptionGroup</code> annotation.  Furthermore, the first\n * parameter of an <code>@OptionGroup</code> annotation (the group name) must\n * be unique among all classes and objects passed to the {@link\n * #Options(String, Object...)} constructor. <p>\n *\n * If an option group itself is unpublicized:\n * <ul>\n *   <li>The default usage message omits the group and all options belonging\n *       to it.\n *   <li>An unpublicized option group (that has any publicized options) is\n *       included in documentation for a manual.\n *   <li>A field with an @{@link Unpublicized} annotation is excluded\n *       even when passing the group's name\n *       explicitly as a parameter to {@link #usage(String...)}.\n * </ul>\n *\n * If an option group is not unpublicized but contains only unpublicized\n * options, it will not be included in the default usage message. <p>\n *\n * <b>Option aliases</b> <p>\n * The @{@link Option} annotation has an optional parameter <code>aliases</code>,\n * which accepts an array of strings.  Each string in the array is an alias for\n * the option being defined and can be used in place of an option's long name\n * or short name.</p>\n *\n * For example:\n * <pre>\n *     // The user may supply --help, -h, or -help, all of which mean the same thing and set this variable\n *     &#64;Option(value=\"-h Print a help message\", aliases={\"-help\"})\n *     public static boolean help;</pre>\n *\n * Aliases should start with a single dash or double dash.\n * If there is only a single, one-character alias, it can be put at the\n * beginning of the value field without the need for an aliases field.\n * It is the user's responsibility to ensure that no alias is the same as other\n * options or aliases and that they can be parsed unambiguously. <p>\n *\n * <b>Generating documentation for a manual or manpage</b> <p>\n * The class Javadoc for a class that has a main method should generally\n * contain a summary of all command-line options.  Such a summary can also\n * be useful in other circumstances.\n * See the {@link plume.OptionsDoclet} class for instructions about generating\n * HTML documentation. <p>\n *\n * <b>Supported field types</b> <p>\n * A field with an @{@link Option} annotation may be of the following types:\n * <ul>\n *   <li>Primitive types:  boolean, int, long, float, double.\n *       (Primitives can also be represented as wrappers:  Boolean,\n *       Integer, Long, Float, Double.  Use of a wrapper type allows the\n *       argument to have no default value.)\n *   <li>Reference types that have a constructor with a single string\n *       parameter.\n *   <li>java.util.regex.Pattern.\n *   <li>enums.\n *   <li>Lists of any of the above reference types.\n * </ul> <p>\n *\n * <b>More examples</b> <p>\n *\n * Example clients of the Options library include {@link plume.Lookup},\n * <a href=\"https://randoop.github.io/randoop/manual/#command-line-options\">Randoop</a>, and\n * <a href=\"http://types.cs.washington.edu/javari/javarifier/#command-line-opts\">Javarifier</a>, among many others.  <p>\n *\n * <b>Limitations</b> <ul>\n *\n *  <li> Short options are only supported as separate entries\n *  (e.g., \"-a -b\") and not as a single group (e.g., \"-ab\").\n *\n *  <li> Not all primitive types are supported.\n *\n *  <li> Types without a constructor that takes a single <code>String</code>\n *  argument are not supported.\n *\n *  <li> The \"--no-long\" option to turn off a boolean option named \"long\"\n *  is not supported; use \"--long=false\" instead.\n *\n * </ul> <p>\n *\n * <b>Possible enhancements</b> <ul>\n *  <li> Positional arguments (non-options that must be provided in a given\n *  order) could be supported.\n * </ul>\n *\n * @see plume.Option\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n */",
  "classSourceCode" : "// The five files\n//   Option.java\n//   OptionGroup.java\n//   Options.java\n//   Unpublicized.java\n//   OptionsDoclet.java\n// together comprise the implementation of command-line processing.\n\npackage plume;\n\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\n/*>>>\nimport org.checkerframework.checker.formatter.qual.*;\nimport org.checkerframework.checker.initialization.qual.*;\nimport org.checkerframework.checker.lock.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*/\n\n/**\n * The Options class:\n * <ul>\n *   <li>parses command-line options and sets fields in your program accordingly,</li>\n *   <li>creates usage messages (such as printed by a <code>--help</code> option), and</li>\n *   <li>creates documentation suitable for a manual or manpage.</li>\n * </ul>\n * Thus, the programmer is freed from writing duplicative, boilerplate code\n * and documentation that could get out of sync with the rest of the program.\n * <p>\n *\n * The programmer does not have to write any code, only declare and\n * document variables.  For each field that you want to set from a\n * command-line argument, you write Javadoc and an @{@link plume.Option}\n * annotation.  Then, the field is automatically set from a command-line\n * option of the same name, and usage messages and printed documentation\n * are generated automatically.\n * <p>\n *\n * The main entry point is {@link #parse_or_usage(String[])}.\n * Typical use is:\n *\n * <!-- Example needs some more words of explanation and example command lines. -->\n * <pre>\n *  import plume.*;\n *\n *  public class MyProgram {\n *\n *    &#64;Option(\"-o &lt;filename&gt; the output file \")\n *    public static File outfile = new File(\"/tmp/foobar\");\n *\n *    &#64;Option(\"-i ignore case\")\n *    public static boolean ignore_case;\n *\n *    &#64;Option(\"set the initial temperature\")\n *    public static double temperature = 75.0;\n *\n *    public static void main(String[] args) {\n *      MyProgram myInstance = new MyProgram();\n *      Options options = new Options(\"MyProgram [options] infile outfile\",\n *                                    myInstance, MyUtilityClass.class);\n *      String[] remaining_args = options.parse_or_usage(args);\n *      ...\n *    }\n *  }</pre>\n * A user may invoke the program using the command-line arguments\n * <code>-o</code>, <code>--outfile</code>, <code>-i</code>, <code>--ignore-case</code>,\n * and <code>--temperature</code>. <p>\n *\n * The call to {@link #parse_or_usage} sets fields in object myInstance,\n * and sets static fields in class MyUtilityClass.  It returns the original\n * command line, with all options removed. <p>\n *\n * <b>@Option indicates a command-line option</b> <p>\n * The @{@link Option} annotation on a field specifies brief user documentation\n * and, optionally, a one-character short name that users may supply on the\n * command line.  The long name is taken from the name of the variable;\n * when the name contains an underscore, the user may substitute a hyphen\n * on the command line instead; for example, the --multi-word-variable\n * command-line option would set the variable multi_word_variable. <p>\n *\n * On the command line, the values for options are specified in the form\n * '--longname=value', '-shortname=value', '--longname value', or '-shortname\n * value'.  If {@link #use_single_dash(boolean)} is true, then the long names\n * take the form '-longname=value' or '-longname value'.  The value is\n * mandatory for all options except booleans.  Booleans are set to true if no\n * value is specified. <p>\n *\n * All arguments that start with '-' are processed as options.  To\n * terminate option processing at the first non-option argument, see {@link\n * #parse_options_after_arg(boolean)}.  Also, the special option '--'\n * terminates option processing; method <code>parse_or_usage</code> returns\n * all subsequent arguments (along with any preceding non-option arguments)\n * without scanning them for options. <p>\n *\n * A user may provide an option multiple times on the command line.  If the\n * field is a list, each entry is added to the list.  If the field is\n * not a list, then only the last occurrence is used (subsequent\n * occurrences overwrite the previous value). <p>\n *\n * <b>Unpublicized options</b> <p>\n * The @{@link Unpublicized} annotation causes an option not to be displayed\n * in the usage message.  This can be useful for options that are\n * preliminary, experimental, or for internal purposes only.  The @{@link\n * Unpublicized} annotation must be specified in addition to the @{@link\n * Option} annotation. <p>\n *\n * There are forms of the usage-message methods that can include even\n * unpublicized options; for example, see {@link #usage(boolean,String...)}.\n * <p>\n *\n * <b>Option groups</b> <p>\n * The @{@link OptionGroup} annotation can be used to assign a name to a set of\n * related options.  This is useful for organizing a list of\n * options.  Options in the same group are displayed under the same heading\n * in usage texts. <p>\n *\n * The @{@link OptionGroup} annotation must be specified on a field in addition\n * to an @{@link Option} annotation.  Note that, due to a deficiency in\n * Javadoc, an <code>@OptionGroup</code> annotation must appear underneath any\n * Javadoc comment for the field it applies to. <p>\n *\n * The <code>@OptionGroup</code> annotation acts like a delimiter &mdash; all\n * <code>@Option</code>-annotated fields up to the next\n * <code>@OptionGroup</code> annotation belong to the same group.  When using\n * option groups, the first <code>@Option</code>-annotated field of every class\n * and object passed to the {@link #Options(String, Object...)} constructor\n * must have an <code>@OptionGroup</code> annotation.  Furthermore, the first\n * parameter of an <code>@OptionGroup</code> annotation (the group name) must\n * be unique among all classes and objects passed to the {@link\n * #Options(String, Object...)} constructor. <p>\n *\n * If an option group itself is unpublicized:\n * <ul>\n *   <li>The default usage message omits the group and all options belonging\n *       to it.\n *   <li>An unpublicized option group (that has any publicized options) is\n *       included in documentation for a manual.\n *   <li>A field with an @{@link Unpublicized} annotation is excluded\n *       even when passing the group's name\n *       explicitly as a parameter to {@link #usage(String...)}.\n * </ul>\n *\n * If an option group is not unpublicized but contains only unpublicized\n * options, it will not be included in the default usage message. <p>\n *\n * <b>Option aliases</b> <p>\n * The @{@link Option} annotation has an optional parameter <code>aliases</code>,\n * which accepts an array of strings.  Each string in the array is an alias for\n * the option being defined and can be used in place of an option's long name\n * or short name.</p>\n *\n * For example:\n * <pre>\n *     // The user may supply --help, -h, or -help, all of which mean the same thing and set this variable\n *     &#64;Option(value=\"-h Print a help message\", aliases={\"-help\"})\n *     public static boolean help;</pre>\n *\n * Aliases should start with a single dash or double dash.\n * If there is only a single, one-character alias, it can be put at the\n * beginning of the value field without the need for an aliases field.\n * It is the user's responsibility to ensure that no alias is the same as other\n * options or aliases and that they can be parsed unambiguously. <p>\n *\n * <b>Generating documentation for a manual or manpage</b> <p>\n * The class Javadoc for a class that has a main method should generally\n * contain a summary of all command-line options.  Such a summary can also\n * be useful in other circumstances.\n * See the {@link plume.OptionsDoclet} class for instructions about generating\n * HTML documentation. <p>\n *\n * <b>Supported field types</b> <p>\n * A field with an @{@link Option} annotation may be of the following types:\n * <ul>\n *   <li>Primitive types:  boolean, int, long, float, double.\n *       (Primitives can also be represented as wrappers:  Boolean,\n *       Integer, Long, Float, Double.  Use of a wrapper type allows the\n *       argument to have no default value.)\n *   <li>Reference types that have a constructor with a single string\n *       parameter.\n *   <li>java.util.regex.Pattern.\n *   <li>enums.\n *   <li>Lists of any of the above reference types.\n * </ul> <p>\n *\n * <b>More examples</b> <p>\n *\n * Example clients of the Options library include {@link plume.Lookup},\n * <a href=\"https://randoop.github.io/randoop/manual/#command-line-options\">Randoop</a>, and\n * <a href=\"http://types.cs.washington.edu/javari/javarifier/#command-line-opts\">Javarifier</a>, among many others.  <p>\n *\n * <b>Limitations</b> <ul>\n *\n *  <li> Short options are only supported as separate entries\n *  (e.g., \"-a -b\") and not as a single group (e.g., \"-ab\").\n *\n *  <li> Not all primitive types are supported.\n *\n *  <li> Types without a constructor that takes a single <code>String</code>\n *  argument are not supported.\n *\n *  <li> The \"--no-long\" option to turn off a boolean option named \"long\"\n *  is not supported; use \"--long=false\" instead.\n *\n * </ul> <p>\n *\n * <b>Possible enhancements</b> <ul>\n *  <li> Positional arguments (non-options that must be provided in a given\n *  order) could be supported.\n * </ul>\n *\n * @see plume.Option\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n */\npublic class Options {\n\n  /** The system-dependent line separator. */\n  private static String eol = System.getProperty(\"line.separator\");\n\n  /** Information about an option. */\n  class OptionInfo {\n\n    /** What variable the option sets. */\n    Field field;\n\n    //    /** Option annotation on the field. */\n    //    Option option;\n\n    /** Object containing the field.  Null if the field is static. */\n    /*@UnknownInitialization*/ /*@Raw*/ /*@Nullable*/ Object obj;\n\n    /** Short (one-character) argument name. */\n    /*@Nullable*/ String short_name;\n\n    /** Long argument name. */\n    String long_name;\n\n    /** Aliases for this option. */\n    String[] aliases;\n\n    /** Argument description: the first line. */\n    String description;\n\n    /** Full Javadoc description. */\n    /*@Nullable*/ String jdoc;\n\n    /**\n     * Maps names of enum constants to their corresponding Javadoc.  This is\n     * used by OptionsDoclet to generate documentation for enum-type options.\n     * Null if the base_type is not an Enum.\n     */\n    /*@MonotonicNonNull*/ Map<String, String> enum_jdoc;\n\n    /**\n     * Name of the argument type.  Defaults to the type of the field, but\n     * user can override this in the option string.\n     */\n    String type_name;\n\n    /**\n     * Class type of this field.  If the field is a list, the basetype\n     * of the list.\n     */\n    Class<?> base_type;\n\n    /** Default value of the option as a string. */\n    /*@Nullable*/ String default_str = null;\n\n    /**\n     * If true, the default value string for this option will be excluded from\n     * OptionsDoclet documentation.\n     */\n    boolean no_doc_default = false;\n\n    /** If the option is a list, this references that list. */\n    /*@MonotonicNonNull*/ List<Object> list = null;\n\n    /** Constructor that takes one String for the type. */\n    /*@Nullable*/ Constructor<?> constructor = null;\n\n    /** Factory that takes a string (some classes don't have a string constructor) and always returns non-null. */\n    /*@Nullable*/ Method factory = null;\n\n    /**\n     * If true, this OptionInfo is not output when printing documentation.\n     * @see #usage()\n     */\n    boolean unpublicized;\n\n    /**\n     * Create a new OptionInfo.\n     * The short name, type name, and description are taken\n     * from the option parameter.  The long name is the name of the\n     * field.  The default value is the current value of the field.\n     * @param field the field to set\n     * @param option the option\n     * @param obj the object whose field will be set;\n     *   if obj is null, the field must be static\n     * @param unpublicized whether the option is unpublicized\n     */\n    OptionInfo(\n        Field field,\n        Option option,\n        /*@UnknownInitialization*/ /*@Raw*/ /*@Nullable*/ Object obj,\n        boolean unpublicized) {\n      this.field = field;\n      //      this.option = option;\n      this.obj = obj;\n      this.base_type = field.getType();\n      this.unpublicized = unpublicized;\n      this.aliases = option.aliases();\n      this.no_doc_default = option.noDocDefault();\n\n      // The long name is the name of the field\n      long_name = field.getName();\n      if (use_dashes) {\n        long_name = long_name.replace('_', '-');\n      }\n\n      // Get the default value (if any)\n      Object default_obj = null;\n      if (!Modifier.isPublic(field.getModifiers())) {\n        throw new Error(\"option field is not public: \" + field);\n      }\n      try {\n        default_obj = field.get(obj);\n        if (default_obj != null) {\n          default_str = default_obj.toString();\n        }\n      } catch (Exception e) {\n        throw new Error(\"Unexpected error getting default for \" + field, e);\n      }\n\n      if (field.getType().isArray()) {\n        throw new Error(\"@Option may not annotate a variable of array type: \" + field);\n      }\n\n      // Handle lists.  When a list argument is specified multiple times,\n      // each argument value is appended to the list.\n      Type gen_type = field.getGenericType();\n      if (gen_type instanceof ParameterizedType) {\n        ParameterizedType pt = (ParameterizedType) gen_type;\n        Type raw_type = pt.getRawType();\n        if (!raw_type.equals(List.class)) {\n          throw new Error(\n              \"@Option supports List<...> but no other parameterized type; it does not support type \"\n                  + pt\n                  + \" for field \"\n                  + field);\n        }\n        if (default_obj == null) {\n          List<Object> new_list = new ArrayList<Object>();\n          try {\n            field.set(obj, new_list);\n          } catch (Exception e) {\n            throw new Error(\"Unexpected error setting default for \" + field, e);\n          }\n          default_obj = new_list;\n        }\n        if (((List<?>) default_obj).isEmpty()) {\n          default_str = null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        List<Object> default_obj_as_list = (List<Object>) default_obj;\n        this.list = default_obj_as_list;\n        // System.out.printf (\"list default = %s%n\", list);\n        Type[] listTypeArgs = pt.getActualTypeArguments();\n        this.base_type = (Class<?>) (listTypeArgs.length == 0 ? Object.class : listTypeArgs[0]);\n\n        // System.out.printf (\"Param type for %s = %s%n\", field, pt);\n        // System.out.printf (\"raw type = %s, type = %s%n\", pt.getRawType(),\n        //                   pt.getActualTypeArguments()[0]);\n      }\n\n      // Get the short name, type name, and description from the annotation\n      ParseResult pr;\n      try {\n        pr = parse_option(option.value());\n      } catch (Throwable e) {\n        throw new Error(\n            \"Error while processing @Option(\\\"\" + option.value() + \"\\\") on '\" + field + \"'\", e);\n      }\n      short_name = pr.short_name;\n      if (pr.type_name != null) {\n        type_name = pr.type_name;\n      } else {\n        type_name = type_short_name(base_type);\n      }\n      description = pr.description;\n\n      // Get a constructor for non-primitive base types\n      if (!base_type.isPrimitive() && !base_type.isEnum()) {\n        try {\n          if (base_type == Pattern.class) {\n            factory = Pattern.class.getMethod(\"compile\", String.class);\n          } else { // look for a string constructor\n            constructor = base_type.getConstructor(String.class);\n          }\n        } catch (Exception e) {\n          throw new Error(\n              \"@Option does not support type \"\n                  + base_type\n                  + \" for field \"\n                  + field\n                  + \" because it does not have a string constructor\",\n              e);\n        }\n      }\n    }\n\n    /**\n     * Return whether or not this option has a required argument.\n     * @return whether or not this option has a required argument\n     */\n    public boolean argument_required() {\n      Class<?> type = field.getType();\n      return ((type != Boolean.TYPE) && (type != Boolean.class));\n    }\n\n    /**\n     * Returns a short synopsis of the option in the form\n     * <code>-s --long=&lt;type&gt;</code>\n     * <strong>or</strong> (if use_single_dash is true)\n     * <code>-s -long=&lt;type&gt;</code> .\n     */\n    public String synopsis() {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String name = prefix + long_name;\n      if (short_name != null) {\n        name = String.format(\"-%s %s\", short_name, name);\n      }\n      name += String.format(\"=<%s>\", type_name);\n      if (list != null) {\n        name += \" [+]\";\n      }\n      return (name);\n    }\n\n    /**\n     * Return a one-line description of the option.\n     * @return a one-line description of the option\n     */\n    @Override\n    /*@SideEffectFree*/\n    public String toString(/*>>>@GuardSatisfied OptionInfo this*/) {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String short_name_str = \"\";\n      if (short_name != null) {\n        short_name_str = \"-\" + short_name + \" \";\n      }\n      return String.format(\"%s%s%s field %s\", short_name_str, prefix, long_name, field);\n    }\n\n    /** Returns the class that declares this option.\n     * @return the class that declares this option\n     */\n    public Class<?> get_declaring_class() {\n      return field.getDeclaringClass();\n    }\n  }\n\n  /** Information about an option group. */\n  static class OptionGroupInfo {\n\n    /** The name of this option group. */\n    String name;\n\n    /**\n     * If true, this group of options will not be printed in usage output by\n     * default. However, the usage information for this option group can be\n     * printed by specifying the group explicitly in the call to {@link\n     * #usage}.\n     */\n    boolean unpublicized;\n\n    /** List of options that belong to this group. */\n    List<OptionInfo> optionList;\n\n    OptionGroupInfo(String name, boolean unpublicized) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = name;\n      this.unpublicized = unpublicized;\n    }\n\n    OptionGroupInfo(OptionGroup optionGroup) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = optionGroup.value();\n      this.unpublicized = optionGroup.unpublicized();\n    }\n\n    /**\n     * If false, this group of options does not contain any publicized options,\n     * so it will not be included in the default usage message.\n     */\n    boolean any_publicized() {\n      for (OptionInfo oi : optionList) {\n        if (!oi.unpublicized) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Whether to parse options after a non-option command-line argument.\n   * @see #parse_options_after_arg(boolean)\n   */\n  private boolean parse_options_after_arg = true;\n\n  /** All of the argument options as a single string. */\n  private String options_str = \"\";\n\n  /** First specified class.  Void stands for \"not yet initialized\". */\n  private Class<?> main_class = Void.TYPE;\n\n  /** List of all of the defined options. */\n  private final List<OptionInfo> options = new ArrayList<OptionInfo>();\n\n  /** Map from short or long option names (with leading dashes) to option information. */\n  private final Map<String, OptionInfo> name_map = new LinkedHashMap<String, OptionInfo>();\n\n  /** Map from option group name to option group information. */\n  private final Map<String, OptionGroupInfo> group_map =\n      new LinkedHashMap<String, OptionGroupInfo>();\n\n  /**\n   * If, after the Options constructor is called, use_groups is true, then the\n   * user is using @OptionGroup annotations correctly (as per the requirement\n   * specified above).  If false, then @OptionGroup annotations have not been\n   * specified on any @Option-annotated fields.  When @OptionGroup annotations\n   * are used incorrectly, an Error is thrown by the Options constructor.\n   */\n  private boolean use_groups;\n\n  /**\n   * Convert underscores to dashes in long options in usage messages.  Users\n   * may specify either the underscore or dashed name on the command line.\n   */\n  private final boolean use_dashes = true;\n\n  /**\n   * When true, long options take the form -longOption with a single dash,\n   * rather than the default --longOption with two dashes.\n   */\n  private boolean use_single_dash = false;\n\n  /**\n   * String describing \"[+]\" (copied from Mercurial).\n   */\n  private static final String LIST_HELP = \"[+] marked option can be specified multiple times\";\n\n  /**\n   * Whether printing the usage message should print LIST_HELP.  The default is\n   * to print LIST_HELP if the usage message contains an option that accepts a\n   * list as a parameter.\n   */\n  private boolean print_list_help = false;\n\n  /**\n   * When true, an argument to a option of list type is split, on\n   * whitespace, into multiple arguments each of which is added to the\n   * list.  When false, each argument to an option of list type is treated\n   * as a single element, no matter what characters it contains.\n   */\n  @Option(\"Treat arguments to lists as space-separated.\")\n  public static boolean split_lists = false;\n\n  /**\n   * Synopsis of usage.  Example:  \"prog [options] arg1 arg2 ...\"\n   * <p>\n   * This variable is public so that clients can reset it (useful for\n   * masquerading as another program, based on parsed options).\n   */\n  public /*@Nullable*/ String usage_synopsis = null;\n\n  // Debug loggers\n  // Does nothing if not enabled.\n  private final SimpleLog debug_options = new SimpleLog(false);\n\n  /**\n   * Enable or disable debug logging.\n   * @param enabled whether to enable or disable logging\n   */\n  public void enableDebugLogging(boolean enabled) {\n    debug_options.enabled = enabled;\n  }\n\n  /**\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case its static fields are set.  The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param args the classes whose options to process\n   */\n  public Options(/*@UnknownInitialization*/ /*@Raw*/ Object... args) {\n    this(\"\", args);\n  }\n\n  /**\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case it must be fully initalized and its static fields are set.\n   * The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param usage_synopsis a synopsis of how to call your program\n   * @param args the classes whose options to process\n   */\n  public Options(String usage_synopsis, /*@UnknownInitialization*/ /*@Raw*/ Object... args) {\n\n    if (args.length == 0) {\n      throw new Error(\"Must pass at least one object to Options constructor\");\n    }\n\n    this.usage_synopsis = usage_synopsis;\n\n    this.use_groups = false;\n\n    // true once the first @Option annotation is observed, false until then.\n    boolean seen_first_opt = false;\n\n    // Loop through each specified object or class\n    for (Object obj : args) {\n      boolean is_class = obj instanceof Class<?>;\n      String current_group = null;\n\n      @SuppressWarnings({\n        \"rawness\",\n        \"initialization\"\n      }) // if is_class is true, obj is a non-null initialized Class\n      /*@Initialized*/ /*@NonRaw*/ /*@NonNull*/ Class<?> clazz =\n          (is_class ? (/*@Initialized*/ /*@NonRaw*/ /*@NonNull*/ Class<?>) obj : obj.getClass());\n      if (main_class == Void.TYPE) {\n        main_class = clazz;\n      }\n      Field[] fields = clazz.getDeclaredFields();\n\n      for (Field f : fields) {\n        try {\n          // Possible exception because \"obj\" is not yet initialized; catch it and proceed\n          @SuppressWarnings(\"cast\")\n          Object obj_nonraw = (/*@Initialized*/ /*@NonRaw*/ Object) obj;\n          debug_options.log(\"Considering field %s of object %s%n\", f, obj_nonraw);\n        } catch (Throwable t) {\n          debug_options.log(\"Considering field %s of object of type %s%n\", f, obj.getClass());\n        }\n        try {\n          debug_options.log(\"  with annotations %s%n\", Arrays.toString(f.getDeclaredAnnotations()));\n        } catch (java.lang.ArrayStoreException e) {\n          if (e.getMessage() != null\n              && Objects.equals(\n                  e.getMessage(), \"sun.reflect.annotation.TypeNotPresentExceptionProxy\")) {\n            debug_options.log(\"  with TypeNotPresentExceptionProxy while getting annotations%n\");\n          } else {\n            throw e;\n          }\n        }\n        Option option = safeGetAnnotation(f, Option.class);\n        if (option == null) {\n          continue;\n        }\n\n        boolean unpublicized = safeGetAnnotation(f, Unpublicized.class) != null;\n\n        if (is_class && !Modifier.isStatic(f.getModifiers())) {\n          throw new Error(\"non-static option \" + f + \" in class \" + obj);\n        }\n\n        @SuppressWarnings(\n            \"initialization\") // \"new MyClass(underInitialization)\" yields @UnderInitialization even when @Initialized would be safe\n        /*@Initialized*/ OptionInfo oi =\n            new OptionInfo(f, option, is_class ? null : obj, unpublicized);\n        options.add(oi);\n\n        // FIXME: should also check that the option does not belong to an\n        // unpublicized option group\n        if (oi.list != null && !oi.unpublicized) {\n          print_list_help = true;\n        }\n\n        OptionGroup optionGroup = safeGetAnnotation(f, OptionGroup.class);\n\n        if (!seen_first_opt) {\n          seen_first_opt = true;\n          // This is the first @Option annotation encountered so we can decide\n          // now if the user intends to use option groups.\n          if (optionGroup != null) {\n            use_groups = true;\n          } else {\n            continue;\n          }\n        }\n\n        if (!use_groups) {\n          if (optionGroup != null) {\n            // The user included an @OptionGroup annotation in their code\n            // without including an @OptionGroup annotation on the first\n            // @Option-annotated field, hence violating the requirement.\n\n            // NOTE: changing this error string requires changes to TestPlume\n            throw new Error(\n                \"missing @OptionGroup annotation on the first \"\n                    + \"@Option-annotated field of class \"\n                    + main_class);\n          } else {\n            continue;\n          }\n        }\n\n        // use_groups is true at this point.  The variable current_group is set\n        // to null at the start of every iteration through 'args'.  This is so\n        // we can check that the first @Option-annotated field of every\n        // class/object in 'args' has an @OptionGroup annotation when use_groups\n        // is true, as required.\n        if (current_group == null && optionGroup == null) {\n          // NOTE: changing this error string requires changes to TestPlume\n          throw new Error(\"missing @OptionGroup annotation in field \" + f + \" of class \" + obj);\n        } else if (optionGroup != null) {\n          String name = optionGroup.value();\n          if (group_map.containsKey(name)) {\n            throw new Error(\"option group \" + name + \" declared twice\");\n          }\n          OptionGroupInfo gi = new OptionGroupInfo(optionGroup);\n          group_map.put(name, gi);\n          current_group = name;\n        } // current_group is non-null at this point\n        @SuppressWarnings(\"nullness\") // map key\n        /*@NonNull*/ OptionGroupInfo ogi = group_map.get(current_group);\n        ogi.optionList.add(oi);\n      } // loop through fields\n    } // loop through args\n\n    String prefix = use_single_dash ? \"-\" : \"--\";\n\n    // Add each option to the option name map\n    for (OptionInfo oi : options) {\n      if (oi.short_name != null) {\n        if (name_map.containsKey(\"-\" + oi.short_name)) {\n          throw new Error(\"short name \" + oi + \" appears twice\");\n        }\n        name_map.put(\"-\" + oi.short_name, oi);\n      }\n      if (name_map.containsKey(prefix + oi.long_name)) {\n        throw new Error(\"long name \" + oi + \" appears twice\");\n      }\n      name_map.put(prefix + oi.long_name, oi);\n      if (use_dashes && oi.long_name.contains(\"-\")) {\n        name_map.put(prefix + oi.long_name.replace('-', '_'), oi);\n      }\n      if (oi.aliases.length > 0) {\n        for (String alias : oi.aliases) {\n          if (name_map.containsKey(alias)) {\n            throw new Error(\"alias \" + oi + \" appears twice\");\n          }\n          name_map.put(alias, oi);\n        }\n      }\n    }\n  }\n\n  /**\n   * Like getAnnotation, but returns null (and prints a warning) rather\n   * than throwing an exception.\n   */\n  @SuppressWarnings(\n      \"initialization\") // bug; see test case checkers/tests/nullness/generics/OptionsTest.java\n  private static <T extends Annotation> /*@Nullable*/ T safeGetAnnotation(\n      Field f, Class<T> annotationClass) {\n    /*@Nullable*/ T annotation;\n    try {\n      @SuppressWarnings(\"cast\") // cast is redundant (except for type annotations)\n      /*@Nullable*/ T cast = f.getAnnotation((Class</*@NonNull*/ T>) annotationClass);\n      annotation = cast;\n    } catch (Exception e) {\n      // Can get\n      //   java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy\n      // when an annotation is not present at run time (example: @NonNull)\n      System.out.printf(\n          \"Exception in call to f.getAnnotation(%s)%n  for f=%s%n  %s%nClasspath =%n\",\n          annotationClass,\n          f,\n          e.getMessage());\n      //e.printStackTrace();\n      JWhich.printClasspath();\n      annotation = null;\n    }\n\n    return annotation;\n  }\n\n  /**\n   * If true, Options will parse arguments even after a non-option\n   * command-line argument.  Setting this to true is useful to permit users\n   * to write options at the end of a command line.  Setting this to false\n   * is useful to avoid processing arguments that are actually\n   * options/arguments for another program that this one will invoke.\n   * @param val whether to parse arguments after a non-option command-line argument\n   */\n  public void parse_options_after_arg(boolean val) {\n    parse_options_after_arg = val;\n  }\n\n  /**\n   * If true, long options (those derived from field names) will be parsed with\n   * a single dash prefix as in -longOption.  The default is false and long\n   * options will be parsed with a double dash prefix as in --longOption.\n   * @param val whether to parse long options with a single dash, as in -longOption\n   */\n  public void use_single_dash(boolean val) {\n    use_single_dash = val;\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.\n   * @param args the commandline to be parsed\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains unknown option or\n   * misused options.\n   */\n  public String[] parse(String[] args) throws ArgException {\n\n    List<String> non_options = new ArrayList<String>();\n    // If true, then \"--\" has been seen and any argument starting with \"-\"\n    // is processed as an ordinary argument, not as an option.\n    boolean ignore_options = false;\n\n    // Loop through each argument\n    String tail = \"\";\n    String arg;\n    for (int ii = 0; ii < args.length; ) {\n      // If there was a ',' separator in previous arg, use the tail as\n      // current arg; otherwise, fetch the next arg from args list.\n      if (tail.length() > 0) {\n        arg = tail;\n        tail = \"\";\n      } else {\n        arg = args[ii];\n      }\n\n      if (arg.equals(\"--\")) {\n        ignore_options = true;\n      } else if ((arg.startsWith(\"--\") || arg.startsWith(\"-\")) && !ignore_options) {\n        String arg_name;\n        String arg_value;\n\n        // Allow ',' as an argument separator to get around\n        // some command line quoting problems.  (markro)\n        int split_pos = arg.indexOf(\",-\");\n        if (split_pos == 0) {\n          // Just discard the ',' if \",-\" occurs at begining of string\n          arg = arg.substring(1);\n          split_pos = arg.indexOf(\",-\");\n        }\n        if (split_pos > 0) {\n          tail = arg.substring(split_pos + 1);\n          arg = arg.substring(0, split_pos);\n        }\n\n        int eq_pos = arg.indexOf('=');\n        if (eq_pos == -1) {\n          arg_name = arg;\n          arg_value = null;\n        } else {\n          arg_name = arg.substring(0, eq_pos);\n          arg_value = arg.substring(eq_pos + 1);\n        }\n        OptionInfo oi = name_map.get(arg_name);\n        if (oi == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(String.format(\"unknown option name '%s' in arg '%s'\", arg_name, arg));\n          if (false) { // for debugging\n            msg.append(\"; known options:\");\n            for (String option_name : UtilMDE.sortedKeySet(name_map)) {\n              msg.append(\" \");\n              msg.append(option_name);\n            }\n          }\n          throw new ArgException(msg.toString());\n        }\n        if (oi.argument_required() && (arg_value == null)) {\n          ii++;\n          if (ii >= args.length) {\n            throw new ArgException(\"option %s requires an argument\", arg);\n          }\n          arg_value = args[ii];\n        }\n        // System.out.printf (\"arg_name = '%s', arg_value='%s'%n\", arg_name,\n        //                    arg_value);\n        set_arg(oi, arg_name, arg_value);\n      } else { // not an option\n        if (!parse_options_after_arg) {\n          ignore_options = true;\n        }\n        non_options.add(arg);\n      }\n\n      // If no ',' tail, advance to next args option\n      if (tail.length() == 0) {\n        ii++;\n      }\n    }\n    String[] result = non_options.toArray(new String[non_options.size()]);\n    return result;\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  This method\n   * splits the argument string into command-line arguments, respecting\n   * single and double quotes, then calls {@link #parse(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]</code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain</code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains misused options or an unknown option.\n   * @see #parse(String[])\n   */\n  public String[] parse(String args) throws ArgException {\n\n    // Split the args string on whitespace boundaries accounting for quoted\n    // strings.\n    args = args.trim();\n    List<String> arg_list = new ArrayList<String>();\n    String arg = \"\";\n    char active_quote = 0;\n    for (int ii = 0; ii < args.length(); ii++) {\n      char ch = args.charAt(ii);\n      if ((ch == '\\'') || (ch == '\"')) {\n        arg += ch;\n        ii++;\n        while ((ii < args.length()) && (args.charAt(ii) != ch)) {\n          arg += args.charAt(ii++);\n        }\n        arg += ch;\n      } else if (Character.isWhitespace(ch)) {\n        // System.out.printf (\"adding argument '%s'%n\", arg);\n        arg_list.add(arg);\n        arg = \"\";\n        while ((ii < args.length()) && Character.isWhitespace(args.charAt(ii))) {\n          ii++;\n        }\n        if (ii < args.length()) {\n          // Encountered a non-whitespace character.\n          // Back up to process it on the next loop iteration.\n          ii--;\n        }\n      } else { // must be part of current argument\n        arg += ch;\n      }\n    }\n    if (!arg.equals(\"\")) {\n      arg_list.add(arg);\n    }\n\n    String[] argsArray = arg_list.toArray(new String[arg_list.size()]);\n    return parse(argsArray);\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse(String[])\n   */\n  public String[] parse_or_usage(String[] args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      // throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }\n\n  /**\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * <p>\n   * This method splits the argument string into command-line arguments,\n   * respecting single and double quotes, then calls\n   * {@link #parse_or_usage(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]</code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain</code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse_or_usage(String[])\n   */\n  public String[] parse_or_usage(String args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      // throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }\n\n  /// This is a lot of methods, but it does save a tad of typing for the\n  /// programmer.\n\n  /**\n   * Prints usage information.  Uses the usage synopsis passed into the\n   * constructor, if any.\n   * @param ps where to print usage information\n   */\n  public void print_usage(PrintStream ps) {\n    if (usage_synopsis != null) {\n      ps.printf(\"Usage: %s%n\", usage_synopsis);\n    }\n    ps.println(usage());\n    if (print_list_help) {\n      ps.println();\n      ps.println(LIST_HELP);\n    }\n  }\n\n  /**\n   * Prints, to standard output, usage information.\n   */\n  public void print_usage() {\n    print_usage(System.out);\n  }\n\n  // This method is distinct from\n  //   print_usage (PrintStream ps, String format, Object... args)\n  // because % characters in the message are not interpreted.\n  /**\n   * Prints a message followed by indented usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param msg message to print before usage information\n   */\n  public void print_usage(PrintStream ps, String msg) {\n    ps.println(msg);\n    print_usage(ps);\n  }\n\n  /**\n   * Prints, to standard output, a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param msg messag. to print before usage information\n   */\n  public void print_usage(String msg) {\n    print_usage(System.out, msg);\n  }\n\n  /**\n   * Prints a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   */\n  @SuppressWarnings(\"formatter\") // acts as format method wrapper\n  public void print_usage(PrintStream ps, String format, /*@Nullable*/ Object... args) {\n    ps.printf(format, args);\n    if (!format.endsWith(\"%n\")) {\n      ps.println();\n    }\n    print_usage(ps);\n  }\n\n  /**\n   * Prints, to standard output, a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   */\n  /*@FormatMethod*/\n  public void print_usage(String format, /*@Nullable*/ Object... args) {\n    print_usage(System.out, format, args);\n  }\n\n  /**\n   * Return the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   */\n  public String usage(String... group_names) {\n    return usage(false, group_names);\n  }\n\n  /**\n   * Returns the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param include_unpublicized if true, treat all unpublicized options\n   * and option groups as publicized\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   */\n  public String usage(boolean include_unpublicized, String... group_names) {\n    if (!use_groups) {\n      if (group_names.length > 0) {\n        throw new IllegalArgumentException(\n            \"This instance of Options does not have any option groups defined\");\n      }\n      return format_options(\n          options, max_opt_len(options, include_unpublicized), include_unpublicized);\n    }\n\n    List<OptionGroupInfo> groups = new ArrayList<OptionGroupInfo>();\n    if (group_names.length > 0) {\n      for (String group_name : group_names) {\n        if (!group_map.containsKey(group_name)) {\n          throw new IllegalArgumentException(\"invalid option group: \" + group_name);\n        }\n        OptionGroupInfo gi = group_map.get(group_name);\n        if (!include_unpublicized && !gi.any_publicized()) {\n          throw new IllegalArgumentException(\n              \"group does not contain any publicized options: \" + group_name);\n        } else {\n          groups.add(group_map.get(group_name));\n        }\n      }\n    } else { // return usage for all groups that are not unpublicized\n      for (OptionGroupInfo gi : group_map.values()) {\n        if ((gi.unpublicized || !gi.any_publicized()) && !include_unpublicized) {\n          continue;\n        }\n        groups.add(gi);\n      }\n    }\n\n    List<Integer> lengths = new ArrayList<Integer>();\n    for (OptionGroupInfo gi : groups) {\n      lengths.add(max_opt_len(gi.optionList, include_unpublicized));\n    }\n    int max_len = Collections.max(lengths);\n\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionGroupInfo gi : groups) {\n      buf.append(String.format(\"%n%s:\", gi.name));\n      buf.append(format_options(gi.optionList, max_len, include_unpublicized));\n    }\n\n    return buf.toString();\n  }\n\n  /**\n   * Format a list of options for use in generating usage messages.\n   */\n  private String format_options(\n      List<OptionInfo> opt_list, int max_len, boolean include_unpublicized) {\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      String default_str = \"\";\n      if (oi.default_str != null) {\n        default_str = String.format(\" [default %s]\", oi.default_str);\n      }\n\n      @SuppressWarnings(\"formatter\") // format string computed from max_len argument\n      String use =\n          String.format(\"  %-\" + max_len + \"s - %s%s\", oi.synopsis(), oi.description, default_str);\n      buf.append(use);\n    }\n    return buf.toString();\n  }\n\n  /**\n   * Return the length of the longest synopsis message in a list of options.\n   * Useful for aligning options in usage strings.\n   * @return the length of the longest synopsis message in a list of options\n   */\n  private int max_opt_len(List<OptionInfo> opt_list, boolean include_unpublicized) {\n    int max_len = 0;\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      int len = oi.synopsis().length();\n      if (len > max_len) {\n        max_len = len;\n      }\n    }\n    return max_len;\n  }\n\n  /**\n   * Package-private accessors/utility methods that are needed by the\n   * OptionsDoclet class to generate HTML documentation.\n   */\n  /*@Pure*/\n  boolean isUsingGroups() {\n    return use_groups;\n  }\n\n  /*@Pure*/\n  boolean isUsingSingleDash() {\n    return use_single_dash;\n  }\n\n  List<OptionInfo> getOptions() {\n    return options;\n  }\n\n  Collection<OptionGroupInfo> getOptionGroups() {\n    return group_map.values();\n  }\n\n  /**\n   * Set the specified option to the value specified in arg_value.  Throws\n   * an ArgException if there are any errors.\n   */\n  private void set_arg(OptionInfo oi, String arg_name, /*@Nullable*/ String arg_value)\n      throws ArgException {\n\n    Field f = oi.field;\n    Class<?> type = oi.base_type;\n\n    // Keep track of all of the options specified\n    if (options_str.length() > 0) {\n      options_str += \" \";\n    }\n    options_str += arg_name;\n    if (arg_value != null) {\n      if (!arg_value.contains(\" \")) {\n        options_str += \"=\" + arg_value;\n      } else if (!arg_value.contains(\"'\")) {\n        options_str += \"='\" + arg_value + \"'\";\n      } else if (!arg_value.contains(\"\\\"\")) {\n        options_str += \"=\\\"\" + arg_value + \"\\\"\";\n      } else {\n        throw new ArgException(\"Can't quote for internal debugging: \" + arg_value);\n      }\n    }\n    // Argument values are required for everything but booleans\n    if (arg_value == null) {\n      if ((type != Boolean.TYPE) || (type != Boolean.class)) {\n        arg_value = \"true\";\n      } else {\n        throw new ArgException(\"Value required for option \" + arg_name);\n      }\n    }\n\n    try {\n      if (type.isPrimitive()) {\n        if (type == Boolean.TYPE) {\n          boolean val;\n          String arg_value_lowercase = arg_value.toLowerCase();\n          if (arg_value_lowercase.equals(\"true\") || (arg_value_lowercase.equals(\"t\"))) {\n            val = true;\n          } else if (arg_value_lowercase.equals(\"false\") || arg_value_lowercase.equals(\"f\")) {\n            val = false;\n          } else {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a boolean\", arg_value, arg_name);\n          }\n          arg_value = (val) ? \"true\" : \"false\";\n          // System.out.printf (\"Setting %s to %s%n\", arg_name, val);\n          f.setBoolean(oi.obj, val);\n        } else if (type == Integer.TYPE) {\n          int val;\n          try {\n            val = Integer.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not an integer\", arg_value, arg_name);\n          }\n          f.setInt(oi.obj, val);\n        } else if (type == Long.TYPE) {\n          long val;\n          try {\n            val = Long.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a long integer\", arg_value, arg_name);\n          }\n          f.setLong(oi.obj, val);\n        } else if (type == Float.TYPE) {\n          Float val;\n          try {\n            val = Float.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a float\", arg_value, arg_name);\n          }\n          f.setFloat(oi.obj, val);\n        } else if (type == Double.TYPE) {\n          Double val;\n          try {\n            val = Double.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a double\", arg_value, arg_name);\n          }\n          f.setDouble(oi.obj, val);\n        } else { // unexpected type\n          throw new Error(\"Unexpected type \" + type);\n        }\n      } else { // reference type\n\n        // If the argument is a list, add repeated arguments or multiple\n        // blank separated arguments to the list, otherwise just set the\n        // argument value.\n        if (oi.list != null) {\n          if (split_lists) {\n            String[] aarr = arg_value.split(\"  *\");\n            for (String aval : aarr) {\n              Object val = get_ref_arg(oi, arg_name, aval);\n              oi.list.add(val); // uncheck cast\n            }\n          } else {\n            Object val = get_ref_arg(oi, arg_name, arg_value);\n            oi.list.add(val);\n          }\n        } else {\n          Object val = get_ref_arg(oi, arg_name, arg_value);\n          f.set(oi.obj, val);\n        }\n      }\n    } catch (ArgException ae) {\n      throw ae;\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error \", e);\n    }\n  }\n\n  /**\n   * Create an instance of the correct type by passing the argument value\n   * string to the constructor.  The only expected error is some sort\n   * of parse error from the constructor.\n   */\n  private /*@NonNull*/ Object get_ref_arg(OptionInfo oi, String arg_name, String arg_value)\n      throws ArgException {\n\n    Object val = null;\n    try {\n      if (oi.constructor != null) {\n        val = oi.constructor.newInstance(new Object[] {arg_value});\n      } else if (oi.base_type.isEnum()) {\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Object tmpVal = getEnumValue((Class<Enum>) oi.base_type, arg_value);\n        val = tmpVal;\n      } else {\n        if (oi.factory == null) {\n          throw new Error(\"No constructor or factory for argument \" + arg_name);\n        }\n        @SuppressWarnings(\"nullness\") // oi.factory is a static method, so null first argument is OK\n        Object tmpVal = oi.factory.invoke(null, arg_value);\n        val = tmpVal;\n      }\n    } catch (Exception e) {\n      throw new ArgException(\"Invalid argument (%s) for argument %s\", arg_value, arg_name);\n    }\n\n    assert val != null : \"@AssumeAssertion(nullness)\";\n    return val;\n  }\n\n  /**\n   * Behaves like {@link java.lang.Enum#valueOf}, except that <code>name</code>\n   * is case-insensitive and hyphen-insensitive (hyphens can be used in place of\n   * underscores).  This allows for greater flexibility when specifying enum\n   * types as command-line arguments.\n   * @param <T> the enum type\n   */\n  private <T extends Enum<T>> T getEnumValue(Class<T> enumType, String name) {\n    T[] constants = enumType.getEnumConstants();\n    if (constants == null) {\n      throw new IllegalArgumentException(enumType.getName() + \" is not an enum type\");\n    }\n    for (T constant : constants) {\n      if (constant.name().equalsIgnoreCase(name.replace('-', '_'))) {\n        return constant;\n      }\n    }\n    // same error that's thrown by Enum.valueOf()\n    throw new IllegalArgumentException(\n        \"No enum constant \" + enumType.getCanonicalName() + \".\" + name);\n  }\n\n  /**\n   * Return a short name for the specified type for use in messages.\n   * @return a short name for the specified type for use in messages\n   */\n  private static String type_short_name(Class<?> type) {\n\n    if (type.isPrimitive()) {\n      return type.getName();\n    } else if (type == File.class) {\n      return \"filename\";\n    } else if (type == Pattern.class) {\n      return \"regex\";\n    } else if (type.isEnum()) {\n      return (\"enum\");\n    } else {\n      return type.getSimpleName().toLowerCase();\n    }\n  }\n\n  /**\n   * Returns a string containing all of the options that were set and their\n   * arguments.  This is essentially the contents of args[] with all\n   * non-options removed.\n   * @return options, similarly to supplied on the command line\n   * @see #settings()\n   */\n  public String get_options_str() {\n    return (options_str);\n  }\n\n  /**\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   * @return options, similarly to supplied on the command line\n   */\n  public String settings() {\n    return settings(false);\n  }\n\n  /**\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   *\n   * @param include_unpublicized  if true, treat all unpublicized options\n   * and option groups as publicized\n   * @return options, similarly to supplied on the command line\n   */\n  public String settings(boolean include_unpublicized) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    // Determine the length of the longest name\n    int max_len = max_opt_len(options, include_unpublicized);\n\n    // Create the settings string\n    for (OptionInfo oi : options) {\n      @SuppressWarnings(\"formatter\") // format string computed from max_len\n      String use = String.format(\"%-\" + max_len + \"s = \", oi.long_name);\n      try {\n        use += oi.field.get(oi.obj);\n      } catch (Exception e) {\n        throw new Error(\"unexpected exception reading field \" + oi.field, e);\n      }\n      out.append(use);\n    }\n\n    return out.toString();\n  }\n\n  /**\n   * Return a description of all of the known options.\n   * Each option is described on its own line in the output.\n   * @return a description of all of the known options\n   */\n  @Override\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public String toString(/*>>>@GuardSatisfied Options this*/) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    for (OptionInfo oi : options) {\n      out.append(oi);\n    }\n\n    return out.toString();\n  }\n\n  /**\n   * Exceptions encountered during argument processing.\n   */\n  public static class ArgException extends Exception {\n    static final long serialVersionUID = 20051223L;\n\n    public ArgException(String s) {\n      super(s);\n    }\n\n    @SuppressWarnings(\"formatter\") // acts as format method wrapper\n    public ArgException(String format, /*@Nullable*/ Object... args) {\n      super(String.format(format, args));\n    }\n  }\n\n  private static class ParseResult {\n    /*@Nullable*/ String short_name;\n    /*@Nullable*/ String type_name;\n    String description;\n\n    ParseResult(\n        /*@Nullable*/ String short_name, /*@Nullable*/ String type_name, String description) {\n      this.short_name = short_name;\n      this.type_name = type_name;\n      this.description = description;\n    }\n  }\n\n  /**\n   * Parse an option value and return its three components (short_name,\n   * type_name, and description).  The short_name and type_name are null\n   * if they are not specified in the string.\n   */\n  private static ParseResult parse_option(String val) {\n\n    // Get the short name, long name, and description\n    String short_name;\n    String type_name;\n    /*@NonNull*/ String description;\n\n    // Get the short name (if any)\n    if (val.startsWith(\"-\")) {\n      if (val.length() < 4 || !val.substring(2, 3).equals(\" \")) {\n        throw new Error(\n            \"Malformed @Option argument \\\"\"\n                + val\n                + \"\\\".  An argument that starts with '-' should contain a short name, a space, and a description.\");\n      }\n      short_name = val.substring(1, 2);\n      description = val.substring(3);\n    } else {\n      short_name = null;\n      description = val;\n    }\n\n    // Get the type name (if any)\n    if (description.startsWith(\"<\")) {\n      type_name = description.substring(1).replaceFirst(\">.*\", \"\");\n      description = description.replaceFirst(\"<.*> \", \"\");\n    } else {\n      type_name = null;\n    }\n\n    // Return the result\n    return new ParseResult(short_name, type_name, description);\n  }\n\n  //   /**\n  //    * Test class with some defined arguments.\n  //    */\n  //   private static class Test {\n  //\n  //     @Option (\"generic\") List<Pattern> lp = new ArrayList<Pattern>();\n  //     @Option (\"-a <filename> argument 1\") String arg1 = \"/tmp/foobar\";\n  //     @Option (\"argument 2\") String arg2;\n  //     @Option (\"-d double value\") double temperature;\n  //     @Option (\"-f the input file\") File input_file;\n  //   }\n  //\n  //   /**\n  //    * Simple example\n  //    */\n  //   private static void main (String[] args) throws ArgException {\n  //\n  //     Options options = new Options (\"test\", new Test());\n  //     System.out.printf (\"Options:%n%s\", options);\n  //     options.parse_or_usage (args);\n  //     System.out.printf (\"Results:%n%s\", options.settings());\n  //   }\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "ps", "java.io", "PrintStream" ], [ "format", "java.lang", "String" ], [ "args", "java.lang", "Object[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "get_options_str", "plume", "Options", "public String get_options_str()" ], [ "usage", "plume", "Options", "public String usage(String... group_names)" ], [ "usage", "plume", "Options", "public String usage(boolean include_unpublicized, String... group_names)" ], [ "parse", "plume", "Options", "public String[] parse(String args) throws ArgException" ], [ "parse_or_usage", "plume", "Options", "public String[] parse_or_usage(String[] args)" ], [ "parse", "plume", "Options", "public String[] parse(String[] args) throws ArgException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "isUsingSingleDash", "plume", "Options", "boolean isUsingSingleDash()" ], [ "toString", "plume", "Options", "public String toString()" ], [ "getOptions", "plume", "Options", "List<OptionInfo> getOptions()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "isUsingGroups", "plume", "Options", "boolean isUsingGroups()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "settings", "plume", "Options", "public String settings(boolean include_unpublicized)" ], [ "parse_or_usage", "plume", "Options", "public String[] parse_or_usage(String args)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getOptionGroups", "plume", "Options", "Collection<OptionGroupInfo> getOptionGroups()" ], [ "settings", "plume", "Options", "public String settings()" ], [ "checkError", "java.io", "PrintStream", "public boolean checkError()" ], [ "append", "java.io", "PrintStream", "public PrintStream append(char arg0)" ], [ "append", "java.io", "PrintStream", "public PrintStream append(CharSequence arg0)" ], [ "format", "java.io", "PrintStream", "public PrintStream format(String arg0, Object[] arg1)" ], [ "printf", "java.io", "PrintStream", "public PrintStream printf(String arg0, Object[] arg1)" ], [ "printf", "java.io", "PrintStream", "public PrintStream printf(Locale arg0, String arg1, Object[] arg2)" ], [ "append", "java.io", "PrintStream", "public PrintStream append(CharSequence arg0, int arg1, int arg2)" ], [ "format", "java.io", "PrintStream", "public PrintStream format(Locale arg0, String arg1, Object[] arg2)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "append", "java.lang", "Appendable", "public abstract Appendable append(char arg0) throws IOException" ], [ "append", "java.lang", "Appendable", "public abstract Appendable append(CharSequence arg0) throws IOException" ], [ "append", "java.lang", "Appendable", "public abstract Appendable append(CharSequence arg0, int arg1, int arg2) throws IOException" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "usage_synopsis", "plume", "Options", "public String usage_synopsis = null;" ], [ "out", "java.io", "FilterOutputStream", "protected OutputStream out;" ], [ "length", "java.lang", "Object[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10806,
  "oracle" : "true ? Arrays.stream(a).allMatch(jdVar -> jdVar >= methodResultID) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return the smallest value in the array",
  "methodJavadoc" : "    /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */",
  "methodSourceCode" : "public static double min(double[] a){\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "a", "", "double[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "equals", "", "double[]", "public boolean equals(Object);" ], [ "toString", "", "double[]", "public String toString()" ], [ "hashCode", "", "double[]", "public native int hashCode()" ], [ "getClass", "", "double[]", "public final native Class getClass();" ], [ "clone", "", "double[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "double[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10813,
  "oracle" : "a.length > 0;",
  "oracleType" : "PRE",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@param a an array",
  "methodJavadoc" : "    /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */",
  "methodSourceCode" : "public static int max(int[] a){\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "a", "", "int[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 10822,
  "oracle" : "true ? Arrays.stream(a).allMatch(jdVar -> jdVar <= methodResultID) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "plume-lib-1.1.0",
  "packageName" : "plume",
  "className" : "ArraysMDE",
  "javadocTag" : "@return the largest value in the array",
  "methodJavadoc" : "    /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */",
  "methodSourceCode" : "public static Long max(Long[] a){\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    // to return a value actually in the array\n    Long result = a[0];\n    // for faster comparison\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}",
  "classJavadoc" : "/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */",
  "classSourceCode" : "// If you edit this file, you must also edit its tests.\n// For tests of this and the entire plume package, see class TestPlume.\n\npackage plume;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Vector;\n\n/*>>>\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\nimport org.checkerframework.framework.qual.PolyAll;\n*/\n\n/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n */\n@SuppressWarnings(\"interning\") // to do later\npublic final class ArraysMDE {\n  /** This class is a collecton of methods; it does not represent anything. */\n  private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// min, max\n  ///\n\n  // Could also add linear-time orderStatistics if I liked.\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; // to return a value actually in the array\n    long result_long = result.longValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; // to return a value actually in the array\n    int result_int = result.intValue(); // for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }\n\n  /**\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      // return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   */\n  public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }\n\n  /**\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   */\n  public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   */\n  public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   */\n  public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   */\n  public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf\n  ///\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> type of the elements of the array\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using the equals method.\n   * @param <T> the type of the elements\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   *    Identical to List.indexOf, but included for completeness.\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index whose element is equal to the specified element,\n   *    or -1 if no such element is found in the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    return a.indexOf(elt);\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.List#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      /*@PolyNull*/ Object[] a, /*@Nullable*/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<? extends /*@PolyNull*/ Object> a, /*@Nullable*/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the list,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in that section of the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOfEq(\n      List<? extends /*@PolyNull*/ Object> a,\n      /*@Nullable*/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first occurrence of the given element in the array.\n   * @param a an array\n   * @param elt the element to search for\n   * @param minindex first index at which to search\n   * @param indexlimit first index at which not to search\n   * @return the first index i containing the specified element,\n   *    such that minindex &le; i &lt; indexlimit,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// indexOf, for finding subarrays\n  ///\n\n  // This is analogous to Common Lisp's \"search\" function.\n\n  // This implementation is very inefficient; I could use tricky Boyer-Moore\n  // search techniques if I liked, but it's not worth it to me yet.\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  // The signature on this method is unnecessarily strict because it\n  // requires that the component types be identical.  The signature should\n  // be indexOfEq(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n  // @PolyAll qualifier does not yet take an argument.\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given array elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, /*@PolyAll*/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if no such element is found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(/*@PolyAll*/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using the equals method.\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if no such element is found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the list that matches the given list elementwise,\n   *    testing for equality using == (not the equals method).\n   * @param a a list\n   * @param sub subsequence to search for\n   * @return the first index at which the second list starts in the first list,\n   *    or -1 if the element is not found in the list\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for the first subsequence of the array that matches the given array elementwise.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @return the first index containing the specified element,\n   *    or -1 if the element is not found in the array\n   * @see java.util.Vector#indexOf(java.lang.Object)\n   * @see java.lang.String#indexOf(java.lang.String)\n   */\n  /*@Pure*/\n  public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// mismatch\n  ///\n\n  // This is analogous to Common Lisp's \"mismatch\" function.\n\n  // Put it off until later; for now, use the simpler subarray function,\n  // which is a specialization of mismatch,\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray extraction\n  ///\n\n  // Note that the second argument is a length, not an end position.\n  // That's to avoid confusion over whether it would be the last included\n  // index or the first non-included index.\n\n  /**\n   * Return a subarray of the given array.\n   * @return a subarray of the given array\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ Object[] subarray(\n      /*@PolyAll*/ Object[] a, int startindex, int length) {\n    /*@PolyAll*/ Object[] result = new /*@PolyAll*/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a sublist of the given list.\n   * @param <T> type of the elements\n   * @param a the original list\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a sublist of the given list\n   */\n  /*@SideEffectFree*/\n  public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static /*@PolyAll*/ String[] subarray(\n      /*@PolyAll*/ String[] a, int startindex, int length) {\n    /*@PolyAll*/ String[] result = new /*@PolyAll*/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  /**\n   * Return a subarray of the given array.\n   * @param a the original array\n   * @param startindex the first index to be included\n   * @param length the number of elements to include (not an end index,\n   *        to avoid confusion over whether it would be the last included\n   *        index or the first non-included index)\n   * @return a subarray of the given array\n   */\n  /*@SideEffectFree*/\n  public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// subarray testing\n  ///\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(\n      /*@PolyAll*/ Object[] a, /*@PolyNull*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(\n      /*@PolyAll*/ Object[] a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(/*@PolyAll*/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, /*@PolyAll*/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using the equals method.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return the first index at which the second array starts in the first array,\n   *    or -1 if no such element is found in the array\n   */\n  /*@Pure*/\n  public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first,\n   *    testing for equality using == (not the equals method).\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the second array is a subarray of the first,\n   *    starting at the specified index of the first.\n   * @param a an array\n   * @param sub subsequence to search for\n   * @param a_offset first index at which to search\n   * @return true iff sub is a contiguous subarray of a\n   */\n  /*@Pure*/\n  public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// concatenation\n  ///\n\n  // Concat used to return null if both arguments are null.  That is\n  // convenient for the implementer, but not so good for clients.\n\n  /**\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   */\n  private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(T /*@Nullable*/ [] a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        // System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, T /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.length];\n\n        // System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static <T> T[] concat(/*@Nullable*/ List<T> a, /*@Nullable*/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new /*@MonotonicNonNull*/ Object[a.size() + b.size()];\n\n        // System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        // System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }\n\n  // Note: PolyAll is not quite right.  Need to review.\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static /*@PolyAll*/ String[] concat(\n      /*@PolyAll*/ String /*@Nullable*/ [] a, /*@PolyAll*/ String /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        /*@PolyAll*/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static byte[] concat(byte /*@Nullable*/ [] a, byte /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static boolean[] concat(boolean /*@Nullable*/ [] a, boolean /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static char[] concat(char /*@Nullable*/ [] a, char /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static double[] concat(double /*@Nullable*/ [] a, double /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static float[] concat(float /*@Nullable*/ [] a, float /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static int[] concat(int /*@Nullable*/ [] a, int /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static long[] concat(long /*@Nullable*/ [] a, long /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  /**\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   */\n  public static short[] concat(short /*@Nullable*/ [] a, short /*@Nullable*/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Printing\n  ///\n\n  // This should be extended to all types, when I get around to it.  The\n  // methods are patterned after that of java.util.Vector (and use its\n  // output format).\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, each element is quoted like a Java String.\n   * @param a an array\n   * @return a string representation of the array, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@PolyAll*/ Object /*@Nullable*/ [] a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@PolyAll*/ Object /*@Nullable*/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a) {\n    return toString(a, false);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @return a string representation of the collection, with the elements quoted\n   * @see java.util.Vector#toString\n   */\n  /*@SideEffectFree*/\n  public static String toStringQuoted(/*@Nullable*/ Collection<?> a) {\n    return toString(a, true);\n  }\n\n  /**\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(/*@Nullable*/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(int /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(long /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(double /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(float /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (string creation)\n  /*@SideEffectFree*/\n  public static String toString(boolean /*@Nullable*/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@SideEffectFree*/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  /**\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   */\n  @SuppressWarnings(\"purity\") // defensive coding: throw exception when argument is invalid\n  /*@Pure*/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Sortedness\n  ///\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted.\n   * @param a an array\n   * @return true iff the array is sorted\n   */\n  /*@Pure*/\n  public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns whether the array is sorted in desending order.\n   * @param a an array\n   * @return true iff the array is sorted in desending order\n   */\n  /*@Pure*/\n  public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      // Could be optimized not to create the last element,\n      // but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      // Could be optimized not to add the last element,\n      // but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Arrays as partial functions of int->int\n  ///\n\n  /**\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (array)\n  /*@Pure*/\n  public static boolean fn_is_permutation(int[] a) {\n    // In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }\n\n  /**\n   * Return true iff the array does not contain -1.\n   * @param a an array, representing a function\n   * @return true iff no element of a maps to -1\n   */\n  /*@Pure*/\n  public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; // not found\n  }\n\n  /**\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   */\n  public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }\n\n  /**\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   */\n  public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }\n\n  /**\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   */\n  public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      // ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   */\n  public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Set operations, such as subset, unions, and intersections\n  ///\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // This implementation is O(n^2) when the smaller really is a subset, but\n  // might be quicker when it is not.  Sorting both sets has (minimum\n  // and maximum) running time of Theta(n log n).\n  /**\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   */\n  @SuppressWarnings(\"purity\") // side effect to local state (HashSet)\n  /*@Pure*/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// Array comparators\n  ///\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * Strings).\n   */\n  public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ String[] a1, /*@PolyAll*/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * numbers).\n   */\n  public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ T[] a1, /*@PolyAll*/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        // Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()</code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()</code> (but do contain identical\n   * objects).\n   */\n  public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    /**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     */\n    /*@Pure*/\n    @SuppressWarnings(\n        \"override.param.invalid\") // CF bug: does not permit expanding annotations on array elements with @Poly\n    // The signature on this method is unnecessarily strict because it\n    // requires that the component types be identical.  The signature should\n    // be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    // @PolyAll qualifier does not yet take an argument.\n    public int compare(/*@PolyAll*/ Object[] a1, /*@PolyAll*/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        // Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        // I'm counting on the fact that hashCode returns a different\n        // number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// nullness\n  ///\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(/*@PolyAll*/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(/*@PolyAll*/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Return true if a contains null.\n   * @param a an array\n   * @return true iff some element of a is null (false if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    // The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (/*@Nullable*/ Object) null) >= 0;\n  }\n\n  /**\n   * Return true if all elements of a are null.\n   * @param a an array\n   * @return true iff all elements of a are null (unspecified result if a is zero-sized)\n   */\n  /*@Pure*/\n  public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  /// javadoc hacks\n  ///\n\n  // Without this, the Javadoc mentions of \"java.util.Vector\", are not links\n  // in the generated HTML.\n  // \"private static Vector v;\" doesn't work, nor does\n  // \"static { new java.util.Vector(); }\", nor does \"private Vector v\".\n  // Yuck!\n  public Vector<?> javadocLossage;\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "FileIOException", "plume" ], [ "MathMDE", "plume" ], [ "DeterministicObject", "plume" ], [ "Digest", "plume" ], [ "StringBuilderDelimited", "plume" ], [ "OrderedPairIterator", "plume" ], [ "CountingPrintWriter", "plume" ], [ "MultiVersionControl", "plume" ], [ "WeakIdentityHashMap", "plume" ], [ "IterableIterator", "plume" ], [ "Lookup", "plume" ], [ "Pair", "plume" ], [ "FileCompiler", "plume" ], [ "MultiRandSelector", "plume" ], [ "RandoopMappedCalls", "plume" ], [ "Stopwatch", "plume" ], [ "TaskManager", "plume" ], [ "WeakHasherMap", "plume" ], [ "ClassFileVersion", "plume" ], [ "WeakIdentityPair", "plume" ], [ "OptionsDoclet", "plume" ], [ "DeclarationAnnotations", "plume" ], [ "Option", "plume" ], [ "RegexUtil", "plume" ], [ "JWhich", "plume" ], [ "TimeLimitProcess", "plume" ], [ "Intern", "plume" ], [ "GraphMDE", "plume" ], [ "HtmlPrettyPrint", "plume" ], [ "SimpleLog", "plume" ], [ "OptionGroup", "plume" ], [ "ICalAvailable", "plume" ], [ "RandomSelector", "plume" ], [ "BCELUtil", "plume" ], [ "UtilMDE", "plume" ], [ "Hasher", "plume" ], [ "BibtexClean", "plume" ], [ "LimitedSizeIntSet", "plume" ], [ "Partitioner", "plume" ], [ "Triple", "plume" ], [ "Options", "plume" ], [ "ArraysMDE", "plume" ], [ "StrTok", "plume" ], [ "Unpublicized", "plume" ], [ "TestPlume", "plume" ], [ "LimitedSizeSet", "plume" ], [ "EntryReader", "plume" ], [ "Filter", "plume" ], [ "FuzzyFloat", "plume" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "negate", "plume", "MathMDE", "public static int negate(int a)" ], [ "negate", "plume", "MathMDE", "public static long negate(long a)" ], [ "negate", "plume", "MathMDE", "public static double negate(double a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static int bitwiseComplement(int a)" ], [ "bitwiseComplement", "plume", "MathMDE", "public static long bitwiseComplement(long a)" ], [ "mul", "plume", "MathMDE", "public static int mul(int x, int y)" ], [ "mul", "plume", "MathMDE", "public static long mul(long x, long y)" ], [ "mul", "plume", "MathMDE", "public static double mul(double x, double y)" ], [ "div", "plume", "MathMDE", "public static int div(int x, int y)" ], [ "div", "plume", "MathMDE", "public static long div(long x, long y)" ], [ "div", "plume", "MathMDE", "public static double div(double x, double y)" ], [ "mod", "plume", "MathMDE", "public static int mod(int x, int y)" ], [ "mod", "plume", "MathMDE", "public static long mod(long x, long y)" ], [ "lshift", "plume", "MathMDE", "public static int lshift(int x, int y)" ], [ "lshift", "plume", "MathMDE", "public static long lshift(long x, long y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static int rshiftSigned(int x, int y)" ], [ "rshiftSigned", "plume", "MathMDE", "public static long rshiftSigned(long x, long y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static int rshiftUnsigned(int x, int y)" ], [ "rshiftUnsigned", "plume", "MathMDE", "public static long rshiftUnsigned(long x, long y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static int bitwiseAnd(int x, int y)" ], [ "bitwiseAnd", "plume", "MathMDE", "public static long bitwiseAnd(long x, long y)" ], [ "logicalAnd", "plume", "MathMDE", "public static int logicalAnd(int x, int y)" ], [ "logicalAnd", "plume", "MathMDE", "public static long logicalAnd(long x, long y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static int bitwiseXor(int x, int y)" ], [ "bitwiseXor", "plume", "MathMDE", "public static long bitwiseXor(long x, long y)" ], [ "logicalXor", "plume", "MathMDE", "public static int logicalXor(int x, int y)" ], [ "logicalXor", "plume", "MathMDE", "public static long logicalXor(long x, long y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static int bitwiseOr(int x, int y)" ], [ "bitwiseOr", "plume", "MathMDE", "public static long bitwiseOr(long x, long y)" ], [ "logicalOr", "plume", "MathMDE", "public static int logicalOr(int x, int y)" ], [ "logicalOr", "plume", "MathMDE", "public static long logicalOr(long x, long y)" ], [ "sign", "plume", "MathMDE", "public static int sign(int a)" ], [ "pow", "plume", "MathMDE", "public static int pow(int base, int expt) throws ArithmeticException" ], [ "pow", "plume", "MathMDE", "public static long pow(long base, long expt) throws ArithmeticException" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int a, int b)" ], [ "gcd", "plume", "MathMDE", "public static int gcd(int[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static int gcd_differences(int[] a)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long a, long b)" ], [ "gcd", "plume", "MathMDE", "public static long gcd(long[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static long gcd_differences(long[] a)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double a, double b)" ], [ "gcd", "plume", "MathMDE", "public static double gcd(double[] a)" ], [ "gcd_differences", "plume", "MathMDE", "public static double gcd_differences(double[] a)" ], [ "mod_positive", "plume", "MathMDE", "public static int mod_positive(int x, int y)" ], [ "modulus", "plume", "MathMDE", "public static int[] modulus(int[] nums)" ], [ "modulus_int", "plume", "MathMDE", "public static int[] modulus_int(Iterator<Integer> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_int", "plume", "MathMDE", "public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)" ], [ "mod_positive", "plume", "MathMDE", "public static long mod_positive(long x, long y)" ], [ "modulus", "plume", "MathMDE", "public static long[] modulus(long[] nums)" ], [ "modulus_long", "plume", "MathMDE", "public static long[] modulus_long(Iterator<Long> itor)" ], [ "modulus_strict", "plume", "MathMDE", "public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)" ], [ "modulus_strict_long", "plume", "MathMDE", "public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)" ], [ "missing_numbers", "plume", "MathMDE", "public static int[] missing_numbers(int[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static int[] nonmodulus_strict(int[] nums)" ], [ "nonmodulus_strict_int", "plume", "MathMDE", "public static int[] nonmodulus_strict_int(Iterator<Integer> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static int[] nonmodulus_nonstrict(int[] nums)" ], [ "missing_numbers", "plume", "MathMDE", "public static long[] missing_numbers(long[] nums)" ], [ "nonmodulus_strict", "plume", "MathMDE", "public static long[] nonmodulus_strict(long[] nums)" ], [ "nonmodulus_strict_long", "plume", "MathMDE", "public static long[] nonmodulus_strict_long(Iterator<Long> nums)" ], [ "nonmodulus_nonstrict", "plume", "MathMDE", "public static long[] nonmodulus_nonstrict(long[] nums)" ], [ "getFileDigest", "plume", "Digest", "public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException" ], [ "hexEncode", "plume", "Digest", "public static String hexEncode(byte[] bytes)" ], [ "hexDecode", "plume", "Digest", "public static byte[] hexDecode(String s) throws IllegalArgumentException" ], [ "dirToCheckoutHg", "plume", "MultiVersionControl", "static Checkout dirToCheckoutHg(File hgDir, File dir)" ], [ "dirToCheckoutGit", "plume", "MultiVersionControl", "static Checkout dirToCheckoutGit(File gitDir, File dir)" ], [ "dirToCheckoutSvn", "plume", "MultiVersionControl", "static Checkout dirToCheckoutSvn(File dir)" ], [ "removeCommonSuffixDirs", "plume", "MultiVersionControl", "static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)" ], [ "eq", "plume", "WeakIdentityHashMap", "static boolean eq(Object x, Object y)" ], [ "hasher", "plume", "WeakIdentityHashMap", "static int hasher(Object x)" ], [ "indexFor", "plume", "WeakIdentityHashMap", "static int indexFor(int h, int length)" ], [ "old_get_entry", "plume", "Lookup", "public static Entry old_get_entry(EntryReader reader) throws IOException" ], [ "first_line", "plume", "Lookup", "public static String first_line(String entry)" ], [ "of", "plume", "Pair", "public static <A extends Object, B extends Object> Pair<A, B> of(A a, B b)" ], [ "short_str", "plume", "TaskManager", "public static String short_str(float f)" ], [ "short_str", "plume", "Task", "public static String short_str(float f)" ], [ "versionNumbers", "plume", "ClassFileVersion", "public static double[] versionNumbers(InputStream is)" ], [ "of", "plume", "WeakIdentityPair", "public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b)" ], [ "start", "plume", "OptionsDoclet", "public static boolean start(RootDoc root)" ], [ "optionLength", "plume", "OptionsDoclet", "public static int optionLength(String option)" ], [ "validOptions", "plume", "OptionsDoclet", "public static boolean validOptions(String[][] options, DocErrorReporter reporter)" ], [ "javadocToHtml", "plume", "OptionsDoclet", "public static String javadocToHtml(Doc doc)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(String s, int groups)" ], [ "isRegex", "plume", "RegexUtil", "public static boolean isRegex(char c)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s)" ], [ "regexError", "plume", "RegexUtil", "public static String regexError(String s, int groups)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s)" ], [ "regexException", "plume", "RegexUtil", "public static PatternSyntaxException regexException(String s, int groups)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s)" ], [ "asRegex", "plume", "RegexUtil", "public static String asRegex(String s, int groups)" ], [ "findClass", "plume", "JWhich", "public static URL findClass(final String className)" ], [ "asResourceName", "plume", "JWhich", "protected static String asResourceName(String resource)" ], [ "getClasspath", "plume", "JWhich", "protected static String getClasspath()" ], [ "internStrings", "plume", "Intern", "public static String[] internStrings(String[] a)" ], [ "isInterned", "plume", "Intern", "public static boolean isInterned(Object value)" ], [ "numIntegers", "plume", "Intern", "public static int numIntegers()" ], [ "numLongs", "plume", "Intern", "public static int numLongs()" ], [ "numIntArrays", "plume", "Intern", "public static int numIntArrays()" ], [ "numLongArrays", "plume", "Intern", "public static int numLongArrays()" ], [ "numDoubles", "plume", "Intern", "public static int numDoubles()" ], [ "numDoubleArrays", "plume", "Intern", "public static int numDoubleArrays()" ], [ "numStringArrays", "plume", "Intern", "public static int numStringArrays()" ], [ "numObjectArrays", "plume", "Intern", "public static int numObjectArrays()" ], [ "integers", "plume", "Intern", "public static Iterator<Integer> integers()" ], [ "longs", "plume", "Intern", "public static Iterator<Long> longs()" ], [ "intArrays", "plume", "Intern", "public static Iterator<int[]> intArrays()" ], [ "longArrays", "plume", "Intern", "public static Iterator<long[]> longArrays()" ], [ "doubles", "plume", "Intern", "public static Iterator<Double> doubles()" ], [ "doubleArrays", "plume", "Intern", "public static Iterator<double[]> doubleArrays()" ], [ "stringArrays", "plume", "Intern", "public static Iterator<String[]> stringArrays()" ], [ "objectArrays", "plume", "Intern", "public static Iterator<Object[]> objectArrays()" ], [ "intern", "plume", "Intern", "public static String intern(String a)" ], [ "intern", "plume", "Intern", "public static long intern(long l)" ], [ "intern", "plume", "Intern", "public static double intern(double d)" ], [ "intern", "plume", "Intern", "public static Integer intern(Integer a)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(int i)" ], [ "internedInteger", "plume", "Intern", "public static Integer internedInteger(String s)" ], [ "intern", "plume", "Intern", "public static Long intern(Long a)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(long i)" ], [ "internedLong", "plume", "Intern", "public static Long internedLong(String s)" ], [ "intern", "plume", "Intern", "public static int[] intern(int[] a)" ], [ "intern", "plume", "Intern", "public static long[] intern(long[] a)" ], [ "intern", "plume", "Intern", "public static Double intern(Double a)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(double d)" ], [ "internedDouble", "plume", "Intern", "public static Double internedDouble(String s)" ], [ "intern", "plume", "Intern", "public static double[] intern(double[] a)" ], [ "intern", "plume", "Intern", "public static String[] intern(String[] a)" ], [ "intern", "plume", "Intern", "public static Object[] intern(Object[] a)" ], [ "intern", "plume", "Intern", "public static Object intern(Object a)" ], [ "internSubsequence", "plume", "Intern", "public static int[] internSubsequence(int[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static long[] internSubsequence(long[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static double[] internSubsequence(double[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static Object[] internSubsequence(Object[] seq, int start, int end)" ], [ "internSubsequence", "plume", "Intern", "public static String[] internSubsequence(String[] seq, int start, int end)" ], [ "dominators", "plume", "GraphMDE", "public static <T> Map<T, List<T>> dominators(Map<T, List<T>> predecessors)" ], [ "canonicalizeTimezone", "plume", "ICalAvailable", "static String canonicalizeTimezone(String timezone)" ], [ "printedTimezone", "plume", "ICalAvailable", "static String printedTimezone(TimeZone tz)" ], [ "parseTime", "plume", "ICalAvailable", "static DateTime parseTime(String time)" ], [ "rangeString", "plume", "ICalAvailable", "static String rangeString(Period p, TimeZone tz)" ], [ "periodListString", "plume", "ICalAvailable", "static String periodListString(PeriodList pl, TimeZone tz)" ], [ "mergeDateAndTime", "plume", "ICalAvailable", "static DateTime mergeDateAndTime(DateTime date, DateTime time)" ], [ "oneDayAvailable", "plume", "ICalAvailable", "static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)" ], [ "parseDate", "plume", "ICalAvailable", "static java.util.Date parseDate(String strDate) throws ParseException" ], [ "formatDate", "plume", "ICalAvailable", "static String formatDate(DateTime d, TimeZone tz)" ], [ "get_method_declaration", "plume", "BCELUtil", "public static String get_method_declaration(Method m)" ], [ "get_access_flags", "plume", "BCELUtil", "static String get_access_flags(Method m)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a)" ], [ "get_constant_str", "plume", "BCELUtil", "public static String get_constant_str(ConstantPool pool, int index)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(MethodGen mg)" ], [ "is_constructor", "plume", "BCELUtil", "public static boolean is_constructor(Method m)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(MethodGen mg)" ], [ "is_clinit", "plume", "BCELUtil", "public static boolean is_clinit(Method m)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(ClassGen gen)" ], [ "in_jdk", "plume", "BCELUtil", "public static boolean in_jdk(String classname)" ], [ "in_jdk_internalform", "plume", "BCELUtil", "public static boolean in_jdk_internalform(String classname)" ], [ "instruction_descr", "plume", "BCELUtil", "public static String instruction_descr(InstructionList il, ConstantPoolGen pool)" ], [ "local_var_descr", "plume", "BCELUtil", "public static String local_var_descr(MethodGen mg)" ], [ "is_local_variable_type_table", "plume", "BCELUtil", "public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)" ], [ "get_attribute_name", "plume", "BCELUtil", "public static String get_attribute_name(Attribute a, ConstantPoolGen pool)" ], [ "is_main", "plume", "BCELUtil", "public static boolean is_main(MethodGen mg)" ], [ "type_to_classgetname", "plume", "BCELUtil", "public static String type_to_classgetname(Type type)" ], [ "type_to_class", "plume", "BCELUtil", "public static Class<?> type_to_class(Type type)" ], [ "add_type", "plume", "BCELUtil", "public static Type[] add_type(Type[] types, Type new_type)" ], [ "insert_type", "plume", "BCELUtil", "public static Type[] insert_type(Type new_type, Type[] types)" ], [ "classname_to_type", "plume", "BCELUtil", "public static Type classname_to_type(String classname)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)" ], [ "intersectionCardinalityAtLeast", "plume", "UtilMDE", "public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b)" ], [ "intersectionCardinality", "plume", "UtilMDE", "public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)" ], [ "fileInputStream", "plume", "UtilMDE", "public static InputStream fileInputStream(File file) throws IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException" ], [ "fileReader", "plume", "UtilMDE", "public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException" ], [ "bufferedFileReader", "plume", "UtilMDE", "public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException" ], [ "lineNumberFileReader", "plume", "UtilMDE", "public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename) throws IOException" ], [ "bufferedFileWriter", "plume", "UtilMDE", "public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException" ], [ "bufferedFileOutputStream", "plume", "UtilMDE", "public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException" ], [ "isSubtype", "plume", "UtilMDE", "public static boolean isSubtype(Class<?> sub, Class<?> sup)" ], [ "classForName", "plume", "UtilMDE", "public static Class<?> classForName(String className) throws ClassNotFoundException" ], [ "binaryNameToFieldDescriptor", "plume", "UtilMDE", "public static String binaryNameToFieldDescriptor(String classname)" ], [ "primitiveTypeNameToFieldDescriptor", "plume", "UtilMDE", "public static String primitiveTypeNameToFieldDescriptor(String primitive_name)" ], [ "binaryNameToClassGetName", "plume", "UtilMDE", "public static String binaryNameToClassGetName(String bn)" ], [ "fieldDescriptorToClassGetName", "plume", "UtilMDE", "public static String fieldDescriptorToClassGetName(String fd)" ], [ "arglistToJvm", "plume", "UtilMDE", "public static String arglistToJvm(String arglist)" ], [ "fieldDescriptorToBinaryName", "plume", "UtilMDE", "public static String fieldDescriptorToBinaryName(String classname)" ], [ "arglistFromJvm", "plume", "UtilMDE", "public static String arglistFromJvm(String arglist)" ], [ "defineClassFromFile", "plume", "UtilMDE", "public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException" ], [ "count_lines", "plume", "UtilMDE", "public static long count_lines(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(String filename) throws IOException" ], [ "inferLineSeparator", "plume", "UtilMDE", "public static String inferLineSeparator(File file) throws IOException" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2)" ], [ "equalFiles", "plume", "UtilMDE", "public static boolean equalFiles(String file1, String file2, boolean trimLines)" ], [ "canCreateAndWrite", "plume", "UtilMDE", "public static boolean canCreateAndWrite(File file)" ], [ "createTempDir", "plume", "UtilMDE", "public static File createTempDir(String prefix, String suffix) throws IOException" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(String dirName)" ], [ "deleteDir", "plume", "UtilMDE", "public static boolean deleteDir(File dir)" ], [ "expandFilename", "plume", "UtilMDE", "public static File expandFilename(File name)" ], [ "expandFilename", "plume", "UtilMDE", "public static String expandFilename(String name)" ], [ "java_source", "plume", "UtilMDE", "public static String java_source(File name)" ], [ "readObject", "plume", "UtilMDE", "public static Object readObject(File file) throws IOException, ClassNotFoundException" ], [ "readerContents", "plume", "UtilMDE", "public static String readerContents(Reader r)" ], [ "readFile", "plume", "UtilMDE", "public static String readFile(File file)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double x)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double a, double b, double c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(double[] a, double[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long l)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long a, long b, long c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(long[] a, long[] b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String a, String b, String c)" ], [ "hash", "plume", "UtilMDE", "public static int hash(String[] a)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts)" ], [ "randomElements", "plume", "UtilMDE", "public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random)" ], [ "incrementMap", "plume", "UtilMDE", "public static <T> Integer incrementMap(Map<T, Integer> m, T key, int count)" ], [ "mapToString", "plume", "UtilMDE", "public static <K, V> String mapToString(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K extends Comparable<? super K>, V> Collection<K> sortedKeySet(Map<K, V> m)" ], [ "sortedKeySet", "plume", "UtilMDE", "public static <K, V> Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "methodForName", "plume", "UtilMDE", "public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(String... command)" ], [ "backticks", "plume", "UtilMDE", "public static String backticks(List<String> command)" ], [ "propertyIsTrue", "plume", "UtilMDE", "public static boolean propertyIsTrue(Properties p, String key)" ], [ "appendProperty", "plume", "UtilMDE", "public static String appendProperty(Properties p, String key, String value)" ], [ "setDefaultMaybe", "plume", "UtilMDE", "public static String setDefaultMaybe(Properties p, String key, String value)" ], [ "getPrivateField", "plume", "UtilMDE", "public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException" ], [ "getFromSet", "plume", "UtilMDE", "public static Object getFromSet(Set<?> set, Object key)" ], [ "streamString", "plume", "UtilMDE", "public static String streamString(InputStream is)" ], [ "replaceString", "plume", "UtilMDE", "public static String replaceString(String target, String oldStr, String newStr)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, char delim)" ], [ "split", "plume", "UtilMDE", "public static String[] split(String s, String delim)" ], [ "splitLines", "plume", "UtilMDE", "public static String[] splitLines(String s)" ], [ "join", "plume", "UtilMDE", "public static String join(Object[] a, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(Object... a)" ], [ "join", "plume", "UtilMDE", "public static String join(List<?> v, String delim)" ], [ "joinLines", "plume", "UtilMDE", "public static String joinLines(List<String> v)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(String orig)" ], [ "escapeNonJava", "plume", "UtilMDE", "public static String escapeNonJava(Character ch)" ], [ "escapeNonASCII", "plume", "UtilMDE", "public static String escapeNonASCII(String orig)" ], [ "unescapeNonJava", "plume", "UtilMDE", "public static String unescapeNonJava(String orig)" ], [ "removeWhitespaceAround", "plume", "UtilMDE", "public static String removeWhitespaceAround(String arg, String delimiter)" ], [ "removeWhitespaceAfter", "plume", "UtilMDE", "public static String removeWhitespaceAfter(String arg, String delimiter)" ], [ "removeWhitespaceBefore", "plume", "UtilMDE", "public static String removeWhitespaceBefore(String arg, String delimiter)" ], [ "nplural", "plume", "UtilMDE", "public static String nplural(int n, String noun)" ], [ "lpad", "plume", "UtilMDE", "public static String lpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(String s, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(int num, int length)" ], [ "rpad", "plume", "UtilMDE", "public static String rpad(double num, int length)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, int ch)" ], [ "count", "plume", "UtilMDE", "public static int count(String s, String sub)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim, boolean returnDelims)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str, String delim)" ], [ "tokens", "plume", "UtilMDE", "public static Vector<Object> tokens(String str)" ], [ "backTrace", "plume", "UtilMDE", "public static String backTrace(Throwable t)" ], [ "sortList", "plume", "UtilMDE", "public static <T> List<T> sortList(List<T> l, Comparator<? super T> c)" ], [ "removeDuplicates", "plume", "UtilMDE", "public static <T> List<T> removeDuplicates(List<T> l)" ], [ "deepEquals", "plume", "UtilMDE", "public static boolean deepEquals(Object o1, Object o2)" ], [ "makeVector", "plume", "UtilMDE", "public static <T> Vector<T> makeVector(Enumeration<T> e)" ], [ "create_combinations", "plume", "UtilMDE", "public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs)" ], [ "create_combinations", "plume", "UtilMDE", "public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(String qualified_name)" ], [ "fullyQualifiedNameToSimpleName", "plume", "UtilMDE", "public static String fullyQualifiedNameToSimpleName(String qualified_name)" ], [ "unqualified_name", "plume", "UtilMDE", "public static String unqualified_name(Class<?> cls)" ], [ "abbreviateNumber", "plume", "UtilMDE", "public static String abbreviateNumber(long val)" ], [ "merge", "plume", "LimitedSizeIntSet", "public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)" ], [ "of", "plume", "Triple", "public static <A, B, C> Triple<A, B, C> of(A a, B b, C c)" ], [ "min", "plume", "ArraysMDE", "public static int min(int[] a)" ], [ "min", "plume", "ArraysMDE", "public static long min(long[] a)" ], [ "min", "plume", "ArraysMDE", "public static double min(double[] a)" ], [ "min", "plume", "ArraysMDE", "public static Integer min(Integer[] a)" ], [ "min", "plume", "ArraysMDE", "public static Long min(Long[] a)" ], [ "min", "plume", "ArraysMDE", "public static Double min(Double[] a)" ], [ "max", "plume", "ArraysMDE", "public static int max(int[] a)" ], [ "max", "plume", "ArraysMDE", "public static long max(long[] a)" ], [ "max", "plume", "ArraysMDE", "public static double max(double[] a)" ], [ "max", "plume", "ArraysMDE", "public static Integer max(Integer[] a)" ], [ "max", "plume", "ArraysMDE", "public static Long max(Long[] a)" ], [ "max", "plume", "ArraysMDE", "public static Double max(Double[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static int[] min_max(int[] a)" ], [ "min_max", "plume", "ArraysMDE", "public static long[] min_max(long[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static int element_range(int[] a)" ], [ "element_range", "plume", "ArraysMDE", "public static long element_range(long[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[] a)" ], [ "sum", "plume", "ArraysMDE", "public static int sum(int[][] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[] a)" ], [ "sum", "plume", "ArraysMDE", "public static double sum(double[][] a)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static <T> int indexOf(T[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double elt)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, Object[] sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, Object[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(Object[] a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(Object[] a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(List<?> a, List<?> sub)" ], [ "indexOfEq", "plume", "ArraysMDE", "public static int indexOfEq(List<?> a, List<?> sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(int[] a, int[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(double[] a, double[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(long[] a, long[] sub)" ], [ "indexOf", "plume", "ArraysMDE", "public static int indexOf(boolean[] a, boolean[] sub)" ], [ "subarray", "plume", "ArraysMDE", "public static Object[] subarray(Object[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static <T> List<T> subarray(List<T> a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static String[] subarray(String[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static byte[] subarray(byte[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static boolean[] subarray(boolean[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static char[] subarray(char[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static double[] subarray(double[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static float[] subarray(float[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static int[] subarray(int[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static long[] subarray(long[] a, int startindex, int length)" ], [ "subarray", "plume", "ArraysMDE", "public static short[] subarray(short[] a, int startindex, int length)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarrayEq", "plume", "ArraysMDE", "public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(int[] a, int[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(long[] a, long[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(double[] a, double[] sub, int a_offset)" ], [ "isSubarray", "plume", "ArraysMDE", "public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(T[] a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, T[] b)" ], [ "concat", "plume", "ArraysMDE", "public static <T> T[] concat(List<T> a, List<T> b)" ], [ "concat", "plume", "ArraysMDE", "public static String[] concat(String[] a, String[] b)" ], [ "concat", "plume", "ArraysMDE", "public static byte[] concat(byte[] a, byte[] b)" ], [ "concat", "plume", "ArraysMDE", "public static boolean[] concat(boolean[] a, boolean[] b)" ], [ "concat", "plume", "ArraysMDE", "public static char[] concat(char[] a, char[] b)" ], [ "concat", "plume", "ArraysMDE", "public static double[] concat(double[] a, double[] b)" ], [ "concat", "plume", "ArraysMDE", "public static float[] concat(float[] a, float[] b)" ], [ "concat", "plume", "ArraysMDE", "public static int[] concat(int[] a, int[] b)" ], [ "concat", "plume", "ArraysMDE", "public static long[] concat(long[] a, long[] b)" ], [ "concat", "plume", "ArraysMDE", "public static short[] concat(short[] a, short[] b)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Object[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object[] a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a)" ], [ "toStringQuoted", "plume", "ArraysMDE", "public static String toStringQuoted(Collection<?> a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Collection<?> a, boolean quoted)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(int[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(long[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(double[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(float[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(boolean[] a)" ], [ "toString", "plume", "ArraysMDE", "public static String toString(Object obj) throws IllegalArgumentException" ], [ "length", "plume", "ArraysMDE", "public static int length(Object obj) throws IllegalArgumentException" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(int[] a)" ], [ "sorted", "plume", "ArraysMDE", "public static boolean sorted(long[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(int[] a)" ], [ "sorted_descending", "plume", "ArraysMDE", "public static boolean sorted_descending(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(boolean[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(byte[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(char[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(float[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(short[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(int[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(double[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(long[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(String[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static boolean noDuplicates(Object[] a)" ], [ "noDuplicates", "plume", "ArraysMDE", "public static <T> boolean noDuplicates(List<T> a)" ], [ "fn_is_permutation", "plume", "ArraysMDE", "public static boolean fn_is_permutation(int[] a)" ], [ "fn_is_total", "plume", "ArraysMDE", "public static boolean fn_is_total(int[] a)" ], [ "fn_identity", "plume", "ArraysMDE", "public static int[] fn_identity(int length)" ], [ "fn_inverse_permutation", "plume", "ArraysMDE", "public static int[] fn_inverse_permutation(int[] a)" ], [ "fn_inverse", "plume", "ArraysMDE", "public static int[] fn_inverse(int[] a, int arange)" ], [ "fn_compose", "plume", "ArraysMDE", "public static int[] fn_compose(int[] a, int[] b)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(long[] smaller, long[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(double[] smaller, double[] bigger)" ], [ "isSubset", "plume", "ArraysMDE", "public static boolean isSubset(String[] smaller, String[] bigger)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(Object[] a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(Object[] a)" ], [ "any_null", "plume", "ArraysMDE", "public static boolean any_null(List<?> a)" ], [ "all_null", "plume", "ArraysMDE", "public static boolean all_null(List<?> a)" ], [ "int_array_iterator", "plume", "TestPlume", "public static Iterator<Integer> int_array_iterator(int[] nums)" ], [ "int_iterator_array", "plume", "TestPlume", "public static int[] int_iterator_array(Iterator<Integer> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Iterator<T> itor)" ], [ "toVector", "plume", "TestPlume", "public static <T> Vector<T> toVector(Enumeration<T> e)" ], [ "merge", "plume", "LimitedSizeSet", "public static <T> LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "serialVersionUID", "plume", "FileIOException", "static final long serialVersionUID = 20050923L;" ], [ "counter", "plume", "DeterministicObject", "static int counter = 0;" ], [ "home", "plume", "MultiVersionControl", "public static String home = System.getProperty(\"user.home\");" ], [ "debug", "plume", "MultiVersionControl", "public static boolean debug = false;" ], [ "idf", "plume", "MultiVersionControl", "static IsDirectoryFilter idf = new IsDirectoryFilter();" ], [ "help", "plume", "Lookup", "public static boolean help = false;" ], [ "verbose", "plume", "Lookup", "public static boolean verbose = false;" ], [ "entry_file", "plume", "Lookup", "public static String entry_file = \"~/lookup/root\";" ], [ "search_body", "plume", "Lookup", "public static boolean search_body = false;" ], [ "regular_expressions", "plume", "Lookup", "public static boolean regular_expressions = false;" ], [ "case_sensitive", "plume", "Lookup", "public static boolean case_sensitive = false;" ], [ "word_match", "plume", "Lookup", "public static boolean word_match = false;" ], [ "print_all", "plume", "Lookup", "public static boolean print_all = false;" ], [ "item_num", "plume", "Lookup", "public static Integer item_num;" ], [ "show_location", "plume", "Lookup", "public static boolean show_location = false;" ], [ "entry_start_re", "plume", "Lookup", "public static Pattern entry_start_re = Pattern.compile(\"^>entry *()\");" ], [ "entry_stop_re", "plume", "Lookup", "public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");" ], [ "description_re", "plume", "Lookup", "public static Pattern description_re = null;" ], [ "comment_re", "plume", "Lookup", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "Lookup", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "runtime", "plume", "FileCompiler", "public static Runtime runtime = java.lang.Runtime.getRuntime();" ], [ "java_filename_pattern", "plume", "FileCompiler", "static Pattern java_filename_pattern;" ], [ "responsible", "plume", "TaskManager", "public static String responsible = null;" ], [ "milestone", "plume", "TaskManager", "public static String milestone = null;" ], [ "completed", "plume", "TaskManager", "public static boolean completed = false;" ], [ "open", "plume", "TaskManager", "public static boolean open = false;" ], [ "verbose", "plume", "TaskManager", "public static boolean verbose = false;" ], [ "format", "plume", "TaskManager", "public static OutputFormat format = OutputFormat.short_ascii;" ], [ "comment_re", "plume", "TaskManager", "public static String comment_re = \"^%.*\";" ], [ "include_re", "plume", "TaskManager", "public static String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";" ], [ "lineSep", "plume", "TaskManager", "public static final String lineSep = System.getProperty(\"line.separator\");" ], [ "minversion", "plume", "ClassFileVersion", "static double minversion = 0;" ], [ "debug", "plume", "DeclarationAnnotations", "static boolean debug = false;" ], [ "date", "plume", "ICalAvailable", "public static String date = \"today\";" ], [ "start_date", "plume", "ICalAvailable", "public static DateTime start_date = new DateTime();" ], [ "days", "plume", "ICalAvailable", "public static int days = 8;" ], [ "iCal_URL", "plume", "ICalAvailable", "public static List<String> iCal_URL = new ArrayList<String>();" ], [ "business_hours", "plume", "ICalAvailable", "public static String business_hours = \"9am-5pm\";" ], [ "businessHours", "plume", "ICalAvailable", "static List<Period> businessHours = new ArrayList<Period>();" ], [ "businessDays", "plume", "ICalAvailable", "static List<Integer> businessDays = new ArrayList<Integer>();" ], [ "tzRegistry", "plume", "ICalAvailable", "static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();" ], [ "timezone1", "plume", "ICalAvailable", "public static String timezone1 = TimeZone.getDefault().getID();" ], [ "tz1", "plume", "ICalAvailable", "static TimeZone tz1;" ], [ "timezone2", "plume", "ICalAvailable", "public static String timezone2;" ], [ "tz2", "plume", "ICalAvailable", "static TimeZone tz2;" ], [ "debug", "plume", "ICalAvailable", "public static boolean debug = false;" ], [ "calendars", "plume", "ICalAvailable", "static List<Calendar> calendars = new ArrayList<Calendar>();" ], [ "tf", "plume", "ICalAvailable", "static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);" ], [ "df", "plume", "ICalAvailable", "static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);" ], [ "dffull", "plume", "ICalAvailable", "static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);" ], [ "canonicalTimezones", "plume", "ICalAvailable", "static Map<String,String> canonicalTimezones = new HashMap<String, String>();" ], [ "printedTimezones", "plume", "ICalAvailable", "static Map<String,String> printedTimezones = new HashMap<String, String>();" ], [ "timeRegexp", "plume", "ICalAvailable", "static Pattern timeRegexp = Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");" ], [ "dateFormats", "plume", "ICalAvailable", "static SimpleDateFormat[] dateFormats = { new SimpleDateFormat(\"yyyy/MM/dd\"), new SimpleDateFormat(\"MM/dd/yyyy\"), new SimpleDateFormat(\"MM/dd/yy\") // Bad idea:  sets year to 1970.  So require the year, at least for now.\n// new SimpleDateFormat(\"MM/dd\"),\n};" ], [ "skip_checks", "plume", "BCELUtil", "public static boolean skip_checks = false;" ], [ "userHome", "plume", "UtilMDE", "static final String userHome = System.getProperty(\"user.home\");" ], [ "args_seen", "plume", "UtilMDE", "static HashMap<String,Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();" ], [ "serialVersionUID", "plume", "UtilMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "NullableStringComparator", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LimitedSizeIntSet", "static final long serialVersionUID = 20031021L;" ], [ "split_lists", "plume", "Options", "public static boolean split_lists = false;" ], [ "serialVersionUID", "plume", "Options", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArgException", "static final long serialVersionUID = 20051223L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ArraysMDE", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "StringArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "IntArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "LongArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ComparableArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "ObjectArrayComparatorLengthFirst", "static final long serialVersionUID = 20150812L;" ], [ "short_run", "plume", "TestPlume", "static boolean short_run = false;" ], [ "mass", "plume", "TestPlume", "public static int mass;" ], [ "x", "plume", "TestPlume", "public static int x;" ], [ "y", "plume", "TestPlume", "public static int y;" ], [ "z", "plume", "TestPlume", "public static int z;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "help", "plume", "TestPlume", "public static boolean help = false;" ], [ "mu", "plume", "TestPlume", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestPlume", "public static double pi = 3.14;" ], [ "color", "plume", "TestPlume", "public static boolean color = false;" ], [ "firstPass", "plume", "TestPlume", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestPlume", "public static Compressor secondPass;" ], [ "mass", "plume", "TestOptionGroups1", "public static int mass;" ], [ "x", "plume", "TestOptionGroups1", "public static int x;" ], [ "y", "plume", "TestOptionGroups1", "public static int y;" ], [ "z", "plume", "TestOptionGroups1", "public static int z;" ], [ "help", "plume", "TestOptionGroups2", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups2", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups2", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups2", "public static boolean color = false;" ], [ "help", "plume", "TestOptionGroups3", "public static boolean help = false;" ], [ "mu", "plume", "TestOptionGroups3", "public static double mu = 4902.7;" ], [ "pi", "plume", "TestOptionGroups3", "public static double pi = 3.14;" ], [ "color", "plume", "TestOptionGroups3", "public static boolean color = false;" ], [ "firstPass", "plume", "TestOptionsEnums", "public static Compressor firstPass;" ], [ "secondPass", "plume", "TestOptionsEnums", "public static Compressor secondPass;" ], [ "serialVersionUID", "plume", "LimitedSizeSet", "static final long serialVersionUID = 20031021L;" ], [ "serialVersionUID", "plume", "FuzzyFloat", "static final long serialVersionUID = 20150812L;" ], [ "serialVersionUID", "plume", "DoubleArrayComparatorLexical", "static final long serialVersionUID = 20150812L;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "a", "", "Long[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "", "java.lang.Long[]", "public boolean equals(Object);" ], [ "toString", "", "java.lang.Long[]", "public String toString()" ], [ "hashCode", "", "java.lang.Long[]", "public native int hashCode()" ], [ "getClass", "", "java.lang.Long[]", "public final native Class getClass();" ], [ "clone", "", "java.lang.Long[]", "public T[] clone();" ], [ "describeConstable", "java.lang", "Long", "public Optional<Long> describeConstable()" ], [ "doubleValue", "java.lang", "Long", "public double doubleValue()" ], [ "floatValue", "java.lang", "Long", "public float floatValue()" ], [ "intValue", "java.lang", "Long", "public int intValue()" ], [ "hashCode", "java.lang", "Long", "public int hashCode()" ], [ "longValue", "java.lang", "Long", "public long longValue()" ], [ "shortValue", "java.lang", "Long", "public short shortValue()" ], [ "toString", "java.lang", "Long", "public String toString()" ], [ "compareTo", "java.lang", "Long", "public int compareTo(Long arg0)" ], [ "resolveConstantDesc", "java.lang", "Long", "public Long resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "byteValue", "java.lang", "Long", "public byte byteValue()" ], [ "equals", "java.lang", "Long", "public boolean equals(Object arg0)" ], [ "doubleValue", "java.lang", "Number", "public abstract double doubleValue()" ], [ "byteValue", "java.lang", "Number", "public byte byteValue()" ], [ "longValue", "java.lang", "Number", "public abstract long longValue()" ], [ "floatValue", "java.lang", "Number", "public abstract float floatValue()" ], [ "intValue", "java.lang", "Number", "public abstract int intValue()" ], [ "shortValue", "java.lang", "Number", "public short shortValue()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "javadocLossage", "plume", "ArraysMDE", "public Vector<?> javadocLossage;" ], [ "length", "java.lang", "Long[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]