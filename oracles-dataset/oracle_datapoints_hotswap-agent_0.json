[ {
  "id" : 26831,
  "oracle" : "name != null;",
  "oracleType" : "PRE",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@param name the name of the Class",
  "methodJavadoc" : "    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */",
  "methodSourceCode" : "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError{\n    Assert.notNull(name, \"Name must not be null\");\n    Class<?> clazz = resolvePrimitiveClassName(name);\n    if (clazz == null) {\n        clazz = commonClassCache.get(name);\n    }\n    if (clazz != null) {\n        return clazz;\n    }\n    // \"java.lang.String[]\" style arrays\n    if (name.endsWith(ARRAY_SUFFIX)) {\n        String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n        Class<?> elementClass = forName(elementClassName, classLoader);\n        return Array.newInstance(elementClass, 0).getClass();\n    }\n    // \"[Ljava.lang.String;\" style arrays\n    if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n        String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n        Class<?> elementClass = forName(elementName, classLoader);\n        return Array.newInstance(elementClass, 0).getClass();\n    }\n    // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n    if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n        String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n        Class<?> elementClass = forName(elementName, classLoader);\n        return Array.newInstance(elementClass, 0).getClass();\n    }\n    ClassLoader clToUse = classLoader;\n    if (clToUse == null) {\n        clToUse = getDefaultClassLoader();\n    }\n    try {\n        return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n    } catch (ClassNotFoundException ex) {\n        int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n        if (lastDotIndex != -1) {\n            String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n            try {\n                return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n            } catch (ClassNotFoundException ex2) {\n                // Swallow - let original exception get through\n            }\n        }\n        throw ex;\n    }\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ [ "\"int\"", "String" ], [ "\"String[]\"", "String" ], [ "\"java.lang.Thread.State\"", "String" ], [ "\"java.lang.Thread$State\"", "String" ] ],
  "tokensMethodArguments" : [ [ "name", "java.lang", "String" ], [ "classLoader", "java.lang", "ClassLoader" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "findLoadedClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> findLoadedClass(String arg0)" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, byte[] arg1, int arg2, int arg3, ProtectionDomain arg4) throws ClassFormatError" ], [ "loadClass", "java.lang", "ClassLoader", "final Class<? extends Object> loadClass(Module arg0, String arg1)" ], [ "loadClass", "java.lang", "ClassLoader", "protected Class<? extends Object> loadClass(String arg0, boolean arg1) throws ClassNotFoundException" ], [ "definePackage", "java.lang", "ClassLoader", "protected Package definePackage(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5, String arg6, URL arg7)" ], [ "findLibrary", "java.lang", "ClassLoader", "protected String findLibrary(String arg0)" ], [ "createOrGetClassLoaderValueMap", "java.lang", "ClassLoader", "ConcurrentHashMap<? extends Object, ? extends Object> createOrGetClassLoaderValueMap()" ], [ "getUnnamedModule", "java.lang", "ClassLoader", "public final Module getUnnamedModule()" ], [ "getPackages", "java.lang", "ClassLoader", "protected Package[] getPackages()" ], [ "isRegisteredAsParallelCapable", "java.lang", "ClassLoader", "public final boolean isRegisteredAsParallelCapable()" ], [ "loadClass", "java.lang", "ClassLoader", "public Class<? extends Object> loadClass(String arg0) throws ClassNotFoundException" ], [ "packages", "java.lang", "ClassLoader", "Stream<Package> packages()" ], [ "findResource", "java.lang", "ClassLoader", "protected URL findResource(String arg0)" ], [ "getParent", "java.lang", "ClassLoader", "public final ClassLoader getParent()" ], [ "findResources", "java.lang", "ClassLoader", "protected Enumeration<URL> findResources(String arg0) throws IOException" ], [ "nameAndId", "java.lang", "ClassLoader", "String nameAndId()" ], [ "definePackage", "java.lang", "ClassLoader", "Package definePackage(String arg0, Module arg1)" ], [ "resources", "java.lang", "ClassLoader", "public Stream<URL> resources(String arg0)" ], [ "getResource", "java.lang", "ClassLoader", "public URL getResource(String arg0)" ], [ "getDefinedPackages", "java.lang", "ClassLoader", "public final Package[] getDefinedPackages()" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(byte[] arg0, int arg1, int arg2) throws ClassFormatError" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, ByteBuffer arg1, ProtectionDomain arg2) throws ClassFormatError" ], [ "getResourceAsStream", "java.lang", "ClassLoader", "public InputStream getResourceAsStream(String arg0)" ], [ "getDefinedPackage", "java.lang", "ClassLoader", "public final Package getDefinedPackage(String arg0)" ], [ "definePackage", "java.lang", "ClassLoader", "Package definePackage(Class<? extends Object> arg0)" ], [ "findResource", "java.lang", "ClassLoader", "protected URL findResource(String arg0, String arg1) throws IOException" ], [ "isAncestor", "java.lang", "ClassLoader", "boolean isAncestor(ClassLoader arg0)" ], [ "findClass", "java.lang", "ClassLoader", "protected Class<? extends Object> findClass(String arg0, String arg1)" ], [ "getResources", "java.lang", "ClassLoader", "public Enumeration<URL> getResources(String arg0) throws IOException" ], [ "name", "java.lang", "ClassLoader", "final String name()" ], [ "findSystemClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> findSystemClass(String arg0) throws ClassNotFoundException" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, byte[] arg1, int arg2, int arg3) throws ClassFormatError" ], [ "desiredAssertionStatus", "java.lang", "ClassLoader", "boolean desiredAssertionStatus(String arg0)" ], [ "findClass", "java.lang", "ClassLoader", "protected Class<? extends Object> findClass(String arg0) throws ClassNotFoundException" ], [ "getPackage", "java.lang", "ClassLoader", "protected Package getPackage(String arg0)" ], [ "getName", "java.lang", "ClassLoader", "public String getName()" ], [ "getClassLoadingLock", "java.lang", "ClassLoader", "protected Object getClassLoadingLock(String arg0)" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26832,
  "oracle" : "className != null;",
  "oracleType" : "PRE",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@param className the name of the Class",
  "methodJavadoc" : "    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */",
  "methodSourceCode" : "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException{\n    try {\n        return forName(className, classLoader);\n    } catch (ClassNotFoundException ex) {\n        throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n    } catch (LinkageError ex) {\n        throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n    }\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ [ "\"int\"", "String" ], [ "\"String[]\"", "String" ] ],
  "tokensMethodArguments" : [ [ "className", "java.lang", "String" ], [ "classLoader", "java.lang", "ClassLoader" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "name", "java.lang", "ClassLoader", "final String name()" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, ByteBuffer arg1, ProtectionDomain arg2) throws ClassFormatError" ], [ "findLoadedClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> findLoadedClass(String arg0)" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(byte[] arg0, int arg1, int arg2) throws ClassFormatError" ], [ "findSystemClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> findSystemClass(String arg0) throws ClassNotFoundException" ], [ "getClassLoadingLock", "java.lang", "ClassLoader", "protected Object getClassLoadingLock(String arg0)" ], [ "getParent", "java.lang", "ClassLoader", "public final ClassLoader getParent()" ], [ "loadClass", "java.lang", "ClassLoader", "protected Class<? extends Object> loadClass(String arg0, boolean arg1) throws ClassNotFoundException" ], [ "packages", "java.lang", "ClassLoader", "Stream<Package> packages()" ], [ "desiredAssertionStatus", "java.lang", "ClassLoader", "boolean desiredAssertionStatus(String arg0)" ], [ "getResources", "java.lang", "ClassLoader", "public Enumeration<URL> getResources(String arg0) throws IOException" ], [ "resources", "java.lang", "ClassLoader", "public Stream<URL> resources(String arg0)" ], [ "findLibrary", "java.lang", "ClassLoader", "protected String findLibrary(String arg0)" ], [ "loadClass", "java.lang", "ClassLoader", "final Class<? extends Object> loadClass(Module arg0, String arg1)" ], [ "findResource", "java.lang", "ClassLoader", "protected URL findResource(String arg0, String arg1) throws IOException" ], [ "isRegisteredAsParallelCapable", "java.lang", "ClassLoader", "public final boolean isRegisteredAsParallelCapable()" ], [ "getName", "java.lang", "ClassLoader", "public String getName()" ], [ "definePackage", "java.lang", "ClassLoader", "Package definePackage(String arg0, Module arg1)" ], [ "definePackage", "java.lang", "ClassLoader", "Package definePackage(Class<? extends Object> arg0)" ], [ "nameAndId", "java.lang", "ClassLoader", "String nameAndId()" ], [ "getPackage", "java.lang", "ClassLoader", "protected Package getPackage(String arg0)" ], [ "getResource", "java.lang", "ClassLoader", "public URL getResource(String arg0)" ], [ "getPackages", "java.lang", "ClassLoader", "protected Package[] getPackages()" ], [ "createOrGetClassLoaderValueMap", "java.lang", "ClassLoader", "ConcurrentHashMap<? extends Object, ? extends Object> createOrGetClassLoaderValueMap()" ], [ "loadClass", "java.lang", "ClassLoader", "public Class<? extends Object> loadClass(String arg0) throws ClassNotFoundException" ], [ "getDefinedPackage", "java.lang", "ClassLoader", "public final Package getDefinedPackage(String arg0)" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, byte[] arg1, int arg2, int arg3) throws ClassFormatError" ], [ "getResourceAsStream", "java.lang", "ClassLoader", "public InputStream getResourceAsStream(String arg0)" ], [ "definePackage", "java.lang", "ClassLoader", "protected Package definePackage(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5, String arg6, URL arg7)" ], [ "findResources", "java.lang", "ClassLoader", "protected Enumeration<URL> findResources(String arg0) throws IOException" ], [ "findClass", "java.lang", "ClassLoader", "protected Class<? extends Object> findClass(String arg0) throws ClassNotFoundException" ], [ "getDefinedPackages", "java.lang", "ClassLoader", "public final Package[] getDefinedPackages()" ], [ "isAncestor", "java.lang", "ClassLoader", "boolean isAncestor(ClassLoader arg0)" ], [ "findClass", "java.lang", "ClassLoader", "protected Class<? extends Object> findClass(String arg0, String arg1)" ], [ "findResource", "java.lang", "ClassLoader", "protected URL findResource(String arg0)" ], [ "getUnnamedModule", "java.lang", "ClassLoader", "public final Module getUnnamedModule()" ], [ "defineClass", "java.lang", "ClassLoader", "protected final Class<? extends Object> defineClass(String arg0, byte[] arg1, int arg2, int arg3, ProtectionDomain arg4) throws ClassFormatError" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26833,
  "oracle" : "instance != null;",
  "oracleType" : "PRE",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@param instance the instance to check",
  "methodJavadoc" : "    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */",
  "methodSourceCode" : "public static Class<?> getUserClass(Object instance){\n    Assert.notNull(instance, \"Instance must not be null\");\n    return getUserClass(instance.getClass());\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "instance", "java.lang", "Object" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26834,
  "oracle" : "className.isEmpty();",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@throws IllegalArgumentException if the className is empty",
  "methodJavadoc" : "    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */",
  "methodSourceCode" : "public static String getShortName(String className){\n    Assert.hasLength(className, \"Class name must not be empty\");\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n    int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n    if (nameEndIndex == -1) {\n        nameEndIndex = className.length();\n    }\n    String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n    shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n    return shortName;\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "className", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "length", "java.lang", "String", "public int length()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26835,
  "oracle" : "true ? methodResultID.length() <= className.length() : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@return the class name of the class without the package name",
  "methodJavadoc" : "    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */",
  "methodSourceCode" : "public static String getShortName(String className){\n    Assert.hasLength(className, \"Class name must not be empty\");\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n    int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n    if (nameEndIndex == -1) {\n        nameEndIndex = className.length();\n    }\n    String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n    shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n    return shortName;\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "className", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26836,
  "oracle" : "true ? methodResultID.length() <= ClassUtils.getQualifiedName(clazz).length() : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@return the class name of the class without the package name",
  "methodJavadoc" : "    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */",
  "methodSourceCode" : "public static String getShortName(Class<?> clazz){\n    return getShortName(getQualifiedName(clazz));\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "clazz", "java.lang.Class", "Class<?>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "length", "java.lang", "String", "public int length()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26837,
  "oracle" : "true ? methodResultID.endsWith(\".class\") : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@return the file name of the \".class\" file",
  "methodJavadoc" : "    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */",
  "methodSourceCode" : "public static String getClassFileName(Class<?> clazz){\n    Assert.notNull(clazz, \"Class must not be null\");\n    String className = clazz.getName();\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n    return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ [ "\"String.class\"", "String" ], [ "\".class\"", "String" ] ],
  "tokensMethodArguments" : [ [ "clazz", "java.lang.Class", "Class<?>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "length", "java.lang", "String", "public int length()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26838,
  "oracle" : "clazz.isArray() ? methodResultID.endsWith(\"[]\") : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@return the qualified name of the class",
  "methodJavadoc" : "    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */",
  "methodSourceCode" : "public static String getQualifiedName(Class<?> clazz){\n    Assert.notNull(clazz, \"Class must not be null\");\n    if (clazz.isArray()) {\n        return getQualifiedNameForArray(clazz);\n    } else {\n        return clazz.getName();\n    }\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ [ "\"[]\"", "String" ] ],
  "tokensMethodArguments" : [ [ "clazz", "java.lang.Class", "Class<?>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26839,
  "oracle" : "true ? methodResultID != null : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@return the method (never {@code null})",
  "methodJavadoc" : "    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */",
  "methodSourceCode" : "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes){\n    Assert.notNull(clazz, \"Class must not be null\");\n    Assert.notNull(methodName, \"Method name must not be null\");\n    if (paramTypes != null) {\n        try {\n            return clazz.getMethod(methodName, paramTypes);\n        } catch (NoSuchMethodException ex) {\n            throw new IllegalStateException(\"Expected method not found: \" + ex);\n        }\n    } else {\n        Set<Method> candidates = new HashSet<Method>(1);\n        Method[] methods = clazz.getMethods();\n        for (Method method : methods) {\n            if (methodName.equals(method.getName())) {\n                candidates.add(method);\n            }\n        }\n        if (candidates.size() == 1) {\n            return candidates.iterator().next();\n        } else if (candidates.isEmpty()) {\n            throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n        } else {\n            throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n        }\n    }\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "clazz", "java.lang.Class", "Class<?>" ], [ "methodName", "java.lang", "String" ], [ "paramTypes", "java.lang.Class", "Class<?>[]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "length", "java.lang", "String", "public int length()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "hasGenericInformation", "java.lang.reflect", "Method", "boolean hasGenericInformation()" ], [ "isSynthetic", "java.lang.reflect", "Method", "public boolean isSynthetic()" ], [ "getName", "java.lang.reflect", "Method", "public String getName()" ], [ "getParameterCount", "java.lang.reflect", "Method", "public int getParameterCount()" ], [ "leafCopy", "java.lang.reflect", "Method", "Method leafCopy()" ], [ "getDefaultValue", "java.lang.reflect", "Method", "public Object getDefaultValue()" ], [ "copy", "java.lang.reflect", "Method", "Method copy()" ], [ "getModifiers", "java.lang.reflect", "Method", "public int getModifiers()" ], [ "hashCode", "java.lang.reflect", "Method", "public int hashCode()" ], [ "toGenericString", "java.lang.reflect", "Method", "public String toGenericString()" ], [ "getExceptionTypes", "java.lang.reflect", "Method", "public Class<? extends Object>[] getExceptionTypes()" ], [ "getAnnotationBytes", "java.lang.reflect", "Method", "byte[] getAnnotationBytes()" ], [ "getAnnotatedReturnType", "java.lang.reflect", "Method", "public AnnotatedType getAnnotatedReturnType()" ], [ "invoke", "java.lang.reflect", "Method", "public Object invoke(Object arg0, Object[] arg1) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException" ], [ "toString", "java.lang.reflect", "Method", "public String toString()" ], [ "getParameterAnnotations", "java.lang.reflect", "Method", "public Annotation[][] getParameterAnnotations()" ], [ "getGenericInfo", "java.lang.reflect", "Method", "MethodRepository getGenericInfo()" ], [ "getDeclaringClass", "java.lang.reflect", "Method", "public Class<? extends Object> getDeclaringClass()" ], [ "getDeclaredAnnotations", "java.lang.reflect", "Method", "public Annotation[] getDeclaredAnnotations()" ], [ "getTypeParameters", "java.lang.reflect", "Method", "public TypeVariable<Method>[] getTypeParameters()" ], [ "getRoot", "java.lang.reflect", "Method", "Method getRoot()" ], [ "getSharedExceptionTypes", "java.lang.reflect", "Method", "Class<? extends Object>[] getSharedExceptionTypes()" ], [ "getGenericReturnType", "java.lang.reflect", "Method", "public Type getGenericReturnType()" ], [ "handleParameterNumberMismatch", "java.lang.reflect", "Method", "boolean handleParameterNumberMismatch(int arg0, Class<? extends Object>[] arg1)" ], [ "equals", "java.lang.reflect", "Method", "public boolean equals(Object arg0)" ], [ "getSharedParameterTypes", "java.lang.reflect", "Method", "Class<? extends Object>[] getSharedParameterTypes()" ], [ "getReturnType", "java.lang.reflect", "Method", "public Class<? extends Object> getReturnType()" ], [ "getAnnotation", "java.lang.reflect", "Method", "public <T> T getAnnotation(Class<T> arg0)" ], [ "getGenericParameterTypes", "java.lang.reflect", "Method", "public Type[] getGenericParameterTypes()" ], [ "isBridge", "java.lang.reflect", "Method", "public boolean isBridge()" ], [ "toShortString", "java.lang.reflect", "Method", "String toShortString()" ], [ "getGenericExceptionTypes", "java.lang.reflect", "Method", "public Type[] getGenericExceptionTypes()" ], [ "getMethodAccessor", "java.lang.reflect", "Method", "MethodAccessor getMethodAccessor()" ], [ "isVarArgs", "java.lang.reflect", "Method", "public boolean isVarArgs()" ], [ "isDefault", "java.lang.reflect", "Method", "public boolean isDefault()" ], [ "getParameterTypes", "java.lang.reflect", "Method", "public Class<? extends Object>[] getParameterTypes()" ], [ "toShortSignature", "java.lang.reflect", "Method", "String toShortSignature()" ], [ "getModifiers", "java.lang.reflect", "Executable", "public abstract int getModifiers()" ], [ "getParameterAnnotations", "java.lang.reflect", "Executable", "public abstract Annotation[][] getParameterAnnotations()" ], [ "getExceptionTypes", "java.lang.reflect", "Executable", "public abstract Class<? extends Object>[] getExceptionTypes()" ], [ "getAnnotatedExceptionTypes", "java.lang.reflect", "Executable", "public AnnotatedType[] getAnnotatedExceptionTypes()" ], [ "handleParameterNumberMismatch", "java.lang.reflect", "Executable", "abstract boolean handleParameterNumberMismatch(int arg0, Class<? extends Object>[] arg1)" ], [ "getParameters", "java.lang.reflect", "Executable", "public Parameter[] getParameters()" ], [ "toGenericString", "java.lang.reflect", "Executable", "public abstract String toGenericString()" ], [ "getAnnotatedReceiverType", "java.lang.reflect", "Executable", "public AnnotatedType getAnnotatedReceiverType()" ], [ "getGenericInfo", "java.lang.reflect", "Executable", "abstract ConstructorRepository getGenericInfo()" ], [ "getAnnotatedParameterTypes", "java.lang.reflect", "Executable", "public AnnotatedType[] getAnnotatedParameterTypes()" ], [ "getParameterTypes", "java.lang.reflect", "Executable", "public abstract Class<? extends Object>[] getParameterTypes()" ], [ "getAnnotation", "java.lang.reflect", "Executable", "public <T> T getAnnotation(Class<T> arg0)" ], [ "getAnnotatedReturnType0", "java.lang.reflect", "Executable", "AnnotatedType getAnnotatedReturnType0(Type arg0)" ], [ "isVarArgs", "java.lang.reflect", "Executable", "public boolean isVarArgs()" ], [ "getSharedExceptionTypes", "java.lang.reflect", "Executable", "abstract Class<? extends Object>[] getSharedExceptionTypes()" ], [ "parseParameterAnnotations", "java.lang.reflect", "Executable", "Annotation[][] parseParameterAnnotations(byte[] arg0)" ], [ "getAllGenericParameterTypes", "java.lang.reflect", "Executable", "Type[] getAllGenericParameterTypes()" ], [ "hasGenericInformation", "java.lang.reflect", "Executable", "abstract boolean hasGenericInformation()" ], [ "getTypeAnnotationBytes0", "java.lang.reflect", "Executable", "native byte[] getTypeAnnotationBytes0()" ], [ "sharedGetParameterAnnotations", "java.lang.reflect", "Executable", "Annotation[][] sharedGetParameterAnnotations(Class<? extends Object>[] arg0, byte[] arg1)" ], [ "sharedToString", "java.lang.reflect", "Executable", "String sharedToString(int arg0, boolean arg1, Class<? extends Object>[] arg2, Class<? extends Object>[] arg3)" ], [ "getTypeParameters", "java.lang.reflect", "Executable", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getParameterCount", "java.lang.reflect", "Executable", "public int getParameterCount()" ], [ "getDeclaredAnnotations", "java.lang.reflect", "Executable", "public Annotation[] getDeclaredAnnotations()" ], [ "getAnnotationsByType", "java.lang.reflect", "Executable", "public <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "parameterize", "java.lang.reflect", "Executable", "Type parameterize(Class<? extends Object> arg0)" ], [ "getSharedParameterTypes", "java.lang.reflect", "Executable", "abstract Class<? extends Object>[] getSharedParameterTypes()" ], [ "getDeclaringClass", "java.lang.reflect", "Executable", "public abstract Class<? extends Object> getDeclaringClass()" ], [ "getName", "java.lang.reflect", "Executable", "public abstract String getName()" ], [ "hasRealParameterData", "java.lang.reflect", "Executable", "boolean hasRealParameterData()" ], [ "getAnnotationBytes", "java.lang.reflect", "Executable", "abstract byte[] getAnnotationBytes()" ], [ "getAnnotatedReturnType", "java.lang.reflect", "Executable", "public abstract AnnotatedType getAnnotatedReturnType()" ], [ "isSynthetic", "java.lang.reflect", "Executable", "public boolean isSynthetic()" ], [ "getGenericExceptionTypes", "java.lang.reflect", "Executable", "public Type[] getGenericExceptionTypes()" ], [ "equalParamTypes", "java.lang.reflect", "Executable", "boolean equalParamTypes(Class<? extends Object>[] arg0, Class<? extends Object>[] arg1)" ], [ "sharedToGenericString", "java.lang.reflect", "Executable", "String sharedToGenericString(int arg0, boolean arg1)" ], [ "getGenericParameterTypes", "java.lang.reflect", "Executable", "public Type[] getGenericParameterTypes()" ], [ "getTypeAnnotationBytes", "java.lang.reflect", "Executable", "byte[] getTypeAnnotationBytes()" ], [ "isAnnotationPresent", "java.lang.reflect", "AccessibleObject", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "canAccess", "java.lang.reflect", "AccessibleObject", "public final boolean canAccess(Object arg0)" ], [ "isAccessible", "java.lang.reflect", "AccessibleObject", "public boolean isAccessible()" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AccessibleObject", "public <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getAnnotation", "java.lang.reflect", "AccessibleObject", "public <T> T getAnnotation(Class<T> arg0)" ], [ "toShortString", "java.lang.reflect", "AccessibleObject", "String toShortString()" ], [ "setAccessible0", "java.lang.reflect", "AccessibleObject", "boolean setAccessible0(boolean arg0)" ], [ "getRoot", "java.lang.reflect", "AccessibleObject", "AccessibleObject getRoot()" ], [ "getAnnotationsByType", "java.lang.reflect", "AccessibleObject", "public <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "trySetAccessible", "java.lang.reflect", "AccessibleObject", "public final boolean trySetAccessible()" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AccessibleObject", "public Annotation[] getDeclaredAnnotations()" ], [ "verifyAccess", "java.lang.reflect", "AccessibleObject", "final boolean verifyAccess(Class<? extends Object> arg0, Class<? extends Object> arg1, Class<? extends Object> arg2, int arg3)" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AccessibleObject", "public <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AccessibleObject", "public Annotation[] getAnnotations()" ], [ "getDeclaringClass", "java.lang.reflect", "Member", "public abstract Class<? extends Object> getDeclaringClass()" ], [ "getName", "java.lang.reflect", "Member", "public abstract String getName()" ], [ "isSynthetic", "java.lang.reflect", "Member", "public abstract boolean isSynthetic()" ], [ "getModifiers", "java.lang.reflect", "Member", "public abstract int getModifiers()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ], [ "length", "java.lang", "Class[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26840,
  "oracle" : "resourcePath.contains(\"/\") ? methodResultID.contains(\".\") && (methodResultID.contains(\"/\"))==false : (methodResultID.contains(\"/\"))==false;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@return the corresponding fully qualified class name",
  "methodJavadoc" : "    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */",
  "methodSourceCode" : "public static String convertResourcePathToClassName(String resourcePath){\n    Assert.notNull(resourcePath, \"Resource path must not be null\");\n    return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ [ "\"/\"", "String" ], [ "\".\"", "String" ] ],
  "tokensMethodArguments" : [ [ "resourcePath", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 26841,
  "oracle" : "clazz1 == null ? methodResultID == clazz2 : methodResultID == clazz1;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "hotswap-agent",
  "packageName" : "org.hotswap.agent.util.spring.util",
  "className" : "ClassUtils",
  "javadocTag" : "@return the common ancestor (i.e. common superclass, one interface\n        extending the other), or {@code null} if none found. If any of\n        the given classes is {@code null}, the other class will be\n        returned.",
  "methodJavadoc" : "    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */",
  "methodSourceCode" : "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2){\n    if (clazz1 == null) {\n        return clazz2;\n    }\n    if (clazz2 == null) {\n        return clazz1;\n    }\n    if (clazz1.isAssignableFrom(clazz2)) {\n        return clazz1;\n    }\n    if (clazz2.isAssignableFrom(clazz1)) {\n        return clazz2;\n    }\n    Class<?> ancestor = clazz1;\n    do {\n        ancestor = ancestor.getSuperclass();\n        if (ancestor == null || Object.class == ancestor) {\n            return null;\n        }\n    } while (!ancestor.isAssignableFrom(clazz2));\n    return ancestor;\n}",
  "classJavadoc" : "/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */",
  "classSourceCode" : "/*\n * Copyright 2002-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.hotswap.agent.util.spring.util;\n\nimport java.beans.Introspector;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Miscellaneous class utility methods. Mainly for internal use within the\n * framework.\n *\n * @author Juergen Hoeller\n * @author Keith Donald\n * @author Rob Harrop\n * @author Sam Brannen\n * @since 1.1\n * @see TypeUtils\n * @see ReflectionUtils\n */\npublic abstract class ClassUtils {\n\n    /** Suffix for array class names: \"[]\" */\n    public static final String ARRAY_SUFFIX = \"[]\";\n\n    /** Prefix for internal array class names: \"[\" */\n    private static final String INTERNAL_ARRAY_PREFIX = \"[\";\n\n    /** Prefix for internal non-primitive array class names: \"[L\" */\n    private static final String NON_PRIMITIVE_ARRAY_PREFIX = \"[L\";\n\n    /** The package separator character '.' */\n    private static final char PACKAGE_SEPARATOR = '.';\n\n    /** The path separator character '/' */\n    private static final char PATH_SEPARATOR = '/';\n\n    /** The inner class separator character '$' */\n    private static final char INNER_CLASS_SEPARATOR = '$';\n\n    /** The CGLIB class separator character \"$$\" */\n    public static final String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    /** The \".class\" file suffix */\n    public static final String CLASS_FILE_SUFFIX = \".class\";\n\n    /**\n     * Map with primitive wrapper type as key and corresponding primitive type\n     * as value, for example: Integer.class -> int.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type as key and corresponding wrapper type as value,\n     * for example: int.class -> Integer.class.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<Class<?>, Class<?>>(8);\n\n    /**\n     * Map with primitive type name as key and corresponding primitive type as\n     * value, for example: \"int\" -> \"int.class\".\n     */\n    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<String, Class<?>>(32);\n\n    /**\n     * Map with common \"java.lang\" class name as key and corresponding Class as\n     * value. Primarily for efficient deserialization of remote invocations.\n     */\n    private static final Map<String, Class<?>> commonClassCache = new HashMap<String, Class<?>>(32);\n\n    static {\n        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);\n        primitiveWrapperTypeMap.put(Byte.class, byte.class);\n        primitiveWrapperTypeMap.put(Character.class, char.class);\n        primitiveWrapperTypeMap.put(Double.class, double.class);\n        primitiveWrapperTypeMap.put(Float.class, float.class);\n        primitiveWrapperTypeMap.put(Integer.class, int.class);\n        primitiveWrapperTypeMap.put(Long.class, long.class);\n        primitiveWrapperTypeMap.put(Short.class, short.class);\n\n        for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n            registerCommonClasses(entry.getKey());\n        }\n\n        Set<Class<?>> primitiveTypes = new HashSet<Class<?>>(32);\n        primitiveTypes.addAll(primitiveWrapperTypeMap.values());\n        primitiveTypes.addAll(Arrays.asList(new Class<?>[] { boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class }));\n        primitiveTypes.add(void.class);\n        for (Class<?> primitiveType : primitiveTypes) {\n            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);\n        }\n\n        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);\n        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Object.class, Object[].class, Class.class, Class[].class);\n        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);\n    }\n\n    /**\n     * Register the given common classes with the ClassUtils cache.\n     */\n    private static void registerCommonClasses(Class<?>... commonClasses) {\n        for (Class<?> clazz : commonClasses) {\n            commonClassCache.put(clazz.getName(), clazz);\n        }\n    }\n\n    /**\n     * Return the default ClassLoader to use: typically the thread context\n     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils\n     * class will be used as fallback.\n     * <p>\n     * Call this method if you intend to use the thread context ClassLoader in a\n     * scenario where you clearly prefer a non-null ClassLoader reference: for\n     * example, for class path resource loading (but not necessarily for\n     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference\n     * as well).\n     * \n     * @return the default ClassLoader (only {@code null} if even the system\n     *         ClassLoader isn't accessible)\n     * @see Thread#getContextClassLoader()\n     * @see ClassLoader#getSystemClassLoader()\n     */\n    public static ClassLoader getDefaultClassLoader() {\n        ClassLoader cl = null;\n        try {\n            cl = Thread.currentThread().getContextClassLoader();\n        } catch (Throwable ex) {\n            // Cannot access thread context ClassLoader - falling back...\n        }\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = ClassUtils.class.getClassLoader();\n            if (cl == null) {\n                // getClassLoader() returning null indicates the bootstrap\n                // ClassLoader\n                try {\n                    cl = ClassLoader.getSystemClassLoader();\n                } catch (Throwable ex) {\n                    // Cannot access system ClassLoader - oh well, maybe the\n                    // caller can live with null...\n                }\n            }\n        }\n        return cl;\n    }\n\n    /**\n     * Override the thread context ClassLoader with the environment's bean\n     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent\n     * to the thread context ClassLoader already.\n     * \n     * @param classLoaderToUse\n     *            the actual ClassLoader to use for the thread context\n     * @return the original thread context ClassLoader, or {@code null} if not\n     *         overridden\n     */\n    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {\n        Thread currentThread = Thread.currentThread();\n        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {\n            currentThread.setContextClassLoader(classLoaderToUse);\n            return threadContextClassLoader;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Replacement for {@code Class.forName()} that also returns Class instances\n     * for primitives (e.g. \"int\") and array class names (e.g. \"String[]\").\n     * Furthermore, it is also capable of resolving inner class names in Java\n     * source style (e.g. \"java.lang.Thread.State\" instead of\n     * \"java.lang.Thread$State\").\n     * \n     * @param name\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws ClassNotFoundException\n     *             if the class was not found\n     * @throws LinkageError\n     *             if the class file could not be loaded\n     * @see Class#forName(String, boolean, ClassLoader)\n     */\n    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {\n        Assert.notNull(name, \"Name must not be null\");\n\n        Class<?> clazz = resolvePrimitiveClassName(name);\n        if (clazz == null) {\n            clazz = commonClassCache.get(name);\n        }\n        if (clazz != null) {\n            return clazz;\n        }\n\n        // \"java.lang.String[]\" style arrays\n        if (name.endsWith(ARRAY_SUFFIX)) {\n            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());\n            Class<?> elementClass = forName(elementClassName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[Ljava.lang.String;\" style arrays\n        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(\";\")) {\n            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        // \"[[I\" or \"[[Ljava.lang.String;\" style arrays\n        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {\n            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());\n            Class<?> elementClass = forName(elementName, classLoader);\n            return Array.newInstance(elementClass, 0).getClass();\n        }\n\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = getDefaultClassLoader();\n        }\n        try {\n            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));\n        } catch (ClassNotFoundException ex) {\n            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);\n            if (lastDotIndex != -1) {\n                String innerClassName = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);\n                try {\n                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));\n                } catch (ClassNotFoundException ex2) {\n                    // Swallow - let original exception get through\n                }\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Resolve the given class name into a Class instance. Supports primitives\n     * (like \"int\") and array class names (like \"String[]\").\n     * <p>\n     * This is effectively equivalent to the {@code forName} method with the\n     * same arguments, with the only difference being the exceptions thrown in\n     * case of class loading failure.\n     * \n     * @param className\n     *            the name of the Class\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return Class instance for the supplied name\n     * @throws IllegalArgumentException\n     *             if the class name was not resolvable (that is, the class\n     *             could not be found or the class file could not be loaded)\n     * @see #forName(String, ClassLoader)\n     */\n    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {\n        try {\n            return forName(className, classLoader);\n        } catch (ClassNotFoundException ex) {\n            throw new IllegalArgumentException(\"Cannot find class [\" + className + \"]\", ex);\n        } catch (LinkageError ex) {\n            throw new IllegalArgumentException(\"Error loading class [\" + className + \"]: problem with class file or dependent class.\", ex);\n        }\n    }\n\n    /**\n     * Resolve the given class name as primitive class, if appropriate,\n     * according to the JVM's naming rules for primitive classes.\n     * <p>\n     * Also supports the JVM's internal class names for primitive arrays. Does\n     * <i>not</i> support the \"[]\" suffix notation for primitive arrays; this is\n     * only supported by {@link #forName(String, ClassLoader)}.\n     * \n     * @param name\n     *            the name of the potentially primitive class\n     * @return the primitive class, or {@code null} if the name does not denote\n     *         a primitive class or primitive array class\n     */\n    public static Class<?> resolvePrimitiveClassName(String name) {\n        Class<?> result = null;\n        // Most class names will be quite long, considering that they\n        // SHOULD sit in a package, so a length check is worthwhile.\n        if (name != null && name.length() <= 8) {\n            // Could be a primitive - likely.\n            result = primitiveTypeNameMap.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Determine whether the {@link Class} identified by the supplied name is\n     * present and can be loaded. Will return {@code false} if either the class\n     * or one of its dependencies is not present or cannot be loaded.\n     * \n     * @param className\n     *            the name of the class to check\n     * @param classLoader\n     *            the class loader to use (may be {@code null}, which indicates\n     *            the default class loader)\n     * @return whether the specified class is present\n     */\n    public static boolean isPresent(String className, ClassLoader classLoader) {\n        try {\n            forName(className, classLoader);\n            return true;\n        } catch (Throwable ex) {\n            // Class or one of its dependencies is not present...\n            return false;\n        }\n    }\n\n    /**\n     * Return the user-defined class for the given instance: usually simply the\n     * class of the given instance, but the original class in case of a\n     * CGLIB-generated subclass.\n     * \n     * @param instance\n     *            the instance to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getUserClass(instance.getClass());\n    }\n\n    /**\n     * Return the user-defined class for the given class: usually simply the\n     * given class, but the original class in case of a CGLIB-generated\n     * subclass.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the user-defined class\n     */\n    public static Class<?> getUserClass(Class<?> clazz) {\n        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {\n            Class<?> superclass = clazz.getSuperclass();\n            if (superclass != null && Object.class != superclass) {\n                return superclass;\n            }\n        }\n        return clazz;\n    }\n\n    /**\n     * Check whether the given class is cache-safe in the given context, i.e.\n     * whether it is loaded by the given ClassLoader or a parent of it.\n     * \n     * @param clazz\n     *            the class to analyze\n     * @param classLoader\n     *            the ClassLoader to potentially cache metadata in\n     */\n    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            ClassLoader target = clazz.getClassLoader();\n            if (target == null) {\n                return true;\n            }\n            ClassLoader cur = classLoader;\n            if (cur == target) {\n                return true;\n            }\n            while (cur != null) {\n                cur = cur.getParent();\n                if (cur == target) {\n                    return true;\n                }\n            }\n            return false;\n        } catch (SecurityException ex) {\n            // Probably from the system ClassLoader - let's consider it safe.\n            return true;\n        }\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param className\n     *            the className to get the short name for\n     * @return the class name of the class without the package name\n     * @throws IllegalArgumentException\n     *             if the className is empty\n     */\n    public static String getShortName(String className) {\n        Assert.hasLength(className, \"Class name must not be empty\");\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);\n        if (nameEndIndex == -1) {\n            nameEndIndex = className.length();\n        }\n        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);\n        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);\n        return shortName;\n    }\n\n    /**\n     * Get the class name without the qualified package name.\n     * \n     * @param clazz\n     *            the class to get the short name for\n     * @return the class name of the class without the package name\n     */\n    public static String getShortName(Class<?> clazz) {\n        return getShortName(getQualifiedName(clazz));\n    }\n\n    /**\n     * Return the short string name of a Java class in uncapitalized JavaBeans\n     * property format. Strips the outer class name in case of an inner class.\n     * \n     * @param clazz\n     *            the class\n     * @return the short name rendered in a standard JavaBeans property format\n     * @see java.beans.Introspector#decapitalize(String)\n     */\n    public static String getShortNameAsProperty(Class<?> clazz) {\n        String shortName = ClassUtils.getShortName(clazz);\n        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);\n        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);\n        return Introspector.decapitalize(shortName);\n    }\n\n    /**\n     * Determine the name of the class file, relative to the containing package:\n     * e.g. \"String.class\"\n     * \n     * @param clazz\n     *            the class\n     * @return the file name of the \".class\" file\n     */\n    public static String getClassFileName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        String className = clazz.getName();\n        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n    }\n\n    /**\n     * Determine the name of the package of the given class, e.g. \"java.lang\"\n     * for the {@code java.lang.String} class.\n     * \n     * @param clazz\n     *            the class\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return getPackageName(clazz.getName());\n    }\n\n    /**\n     * Determine the name of the package of the given fully-qualified class\n     * name, e.g. \"java.lang\" for the {@code java.lang.String} class name.\n     * \n     * @param fqClassName\n     *            the fully-qualified class name\n     * @return the package name, or the empty String if the class is defined in\n     *         the default package\n     */\n    public static String getPackageName(String fqClassName) {\n        Assert.notNull(fqClassName, \"Class name must not be null\");\n        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);\n        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : \"\");\n    }\n\n    /**\n     * Return the qualified name of the given class: usually simply the class\n     * name, but component type class name + \"[]\" for arrays.\n     * \n     * @param clazz\n     *            the class\n     * @return the qualified name of the class\n     */\n    public static String getQualifiedName(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Build a nice qualified name for an array: component type class name +\n     * \"[]\".\n     * \n     * @param clazz\n     *            the array class\n     * @return a qualified name for the array class\n     */\n    private static String getQualifiedNameForArray(Class<?> clazz) {\n        StringBuilder result = new StringBuilder();\n        while (clazz.isArray()) {\n            clazz = clazz.getComponentType();\n            result.append(ClassUtils.ARRAY_SUFFIX);\n        }\n        result.insert(0, clazz.getName());\n        return result.toString();\n    }\n\n    /**\n     * Return the qualified name of the given method, consisting of fully\n     * qualified interface/class name + \".\" + method name.\n     * \n     * @param method\n     *            the method\n     * @return the qualified name of the method\n     */\n    public static String getQualifiedMethodName(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return method.getDeclaringClass().getName() + \".\" + method.getName();\n    }\n\n    /**\n     * Return a descriptive name for the given object's type: usually simply the\n     * class name, but component type class name + \"[]\" for arrays, and an\n     * appended list of implemented interfaces for JDK proxies.\n     * \n     * @param value\n     *            the value to introspect\n     * @return the qualified name of the class\n     */\n    public static String getDescriptiveType(Object value) {\n        if (value == null) {\n            return null;\n        }\n        Class<?> clazz = value.getClass();\n        if (Proxy.isProxyClass(clazz)) {\n            StringBuilder result = new StringBuilder(clazz.getName());\n            result.append(\" implementing \");\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (int i = 0; i < ifcs.length; i++) {\n                result.append(ifcs[i].getName());\n                if (i < ifcs.length - 1) {\n                    result.append(',');\n                }\n            }\n            return result.toString();\n        } else if (clazz.isArray()) {\n            return getQualifiedNameForArray(clazz);\n        } else {\n            return clazz.getName();\n        }\n    }\n\n    /**\n     * Check whether the given class matches the user-specified type name.\n     * \n     * @param clazz\n     *            the class to check\n     * @param typeName\n     *            the type name to match\n     */\n    public static boolean matchesTypeName(Class<?> clazz, String typeName) {\n        return (typeName != null && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName()) || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding constructor\n     * @see Class#getMethod\n     */\n    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {\n        return (getConstructorIfAvailable(clazz, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public constructor with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return the constructor, or {@code null} if not found\n     * @see Class#getConstructor\n     */\n    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        try {\n            return clazz.getConstructor(paramTypes);\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to \"false\".\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method\n     * @return whether the class has a corresponding method\n     * @see Class#getMethod\n     */\n    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else throws an\n     * {@code IllegalStateException}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to\n     * {@code IllegalStateException}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method (never {@code null})\n     * @throws IllegalStateException\n     *             if the method has not been found\n     * @see Class#getMethod\n     */\n    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                throw new IllegalStateException(\"Expected method not found: \" + ex);\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            } else if (candidates.isEmpty()) {\n                throw new IllegalStateException(\"Expected method not found: \" + clazz + \".\" + methodName);\n            } else {\n                throw new IllegalStateException(\"No unique method found: \" + clazz + \".\" + methodName);\n            }\n        }\n    }\n\n    /**\n     * Determine whether the given class has a public method with the given\n     * signature, and return it if available (else return {@code null}).\n     * <p>\n     * In case of any signature specified, only returns the method if there is a\n     * unique candidate, i.e. a single public method with the specified name.\n     * <p>\n     * Essentially translates {@code NoSuchMethodException} to {@code null}.\n     * \n     * @param clazz\n     *            the clazz to analyze\n     * @param methodName\n     *            the name of the method\n     * @param paramTypes\n     *            the parameter types of the method (may be {@code null} to\n     *            indicate any signature)\n     * @return the method, or {@code null} if not found\n     * @see Class#getMethod\n     */\n    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        if (paramTypes != null) {\n            try {\n                return clazz.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException ex) {\n                return null;\n            }\n        } else {\n            Set<Method> candidates = new HashSet<Method>(1);\n            Method[] methods = clazz.getMethods();\n            for (Method method : methods) {\n                if (methodName.equals(method.getName())) {\n                    candidates.add(method);\n                }\n            }\n            if (candidates.size() == 1) {\n                return candidates.iterator().next();\n            }\n            return null;\n        }\n    }\n\n    /**\n     * Return the number of methods with a given name (with any argument types),\n     * for the given class and/or its superclasses. Includes non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return the number of methods with the given name\n     */\n    public static int getMethodCountForName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        int count = 0;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (methodName.equals(method.getName())) {\n                count++;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            count += getMethodCountForName(ifc, methodName);\n        }\n        if (clazz.getSuperclass() != null) {\n            count += getMethodCountForName(clazz.getSuperclass(), methodName);\n        }\n        return count;\n    }\n\n    /**\n     * Does the given class or one of its superclasses at least have one or more\n     * methods with the supplied name (with any argument types)? Includes\n     * non-public methods.\n     * \n     * @param clazz\n     *            the clazz to check\n     * @param methodName\n     *            the name of the method\n     * @return whether there is at least one method with the given name\n     */\n    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if (method.getName().equals(methodName)) {\n                return true;\n            }\n        }\n        Class<?>[] ifcs = clazz.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (hasAtLeastOneMethodWithName(ifc, methodName)) {\n                return true;\n            }\n        }\n        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));\n    }\n\n    /**\n     * Given a method, which may come from an interface, and a target class used\n     * in the current reflective invocation, find the corresponding target\n     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the\n     * target class may be {@code DefaultFoo}. In this case, the method may be\n     * {@code DefaultFoo.bar()}. This enables attributes on that method to be\n     * found.\n     * <p>\n     * <b>NOTE:</b> In contrast to\n     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},\n     * this method does <i>not</i> resolve Java 5 bridge methods automatically.\n     * Call\n     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}\n     * if bridge method resolution is desirable (e.g. for obtaining metadata\n     * from the original method definition).\n     * <p>\n     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow\n     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,\n     * this implementation will fall back to returning the originally provided\n     * method.\n     * \n     * @param method\n     *            the method to be invoked, which may come from an interface\n     * @param targetClass\n     *            the target class for the current invocation. May be\n     *            {@code null} or may not even implement the method.\n     * @return the specific target method, or the original method if the\n     *         {@code targetClass} doesn't implement it or is {@code null}\n     */\n    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {\n        if (method != null && isOverridable(method, targetClass) && targetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n            try {\n                if (Modifier.isPublic(method.getModifiers())) {\n                    try {\n                        return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                    } catch (NoSuchMethodException ex) {\n                        return method;\n                    }\n                } else {\n                    Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                    return (specificMethod != null ? specificMethod : method);\n                }\n            } catch (SecurityException ex) {\n                // Security settings are disallowing reflective access; fall\n                // back to 'method' below.\n            }\n        }\n        return method;\n    }\n\n    /**\n     * Determine whether the given method is declared by the user or at least\n     * pointing to a user-declared method.\n     * <p>\n     * Checks {@link Method#isSynthetic()} (for implementation methods) as well\n     * as the {@code GroovyObject} interface (for interface methods; on an\n     * implementation class, implementations of the {@code GroovyObject} methods\n     * will be marked as synthetic anyway). Note that, despite being synthetic,\n     * bridge methods ({@link Method#isBridge()}) are considered as user-level\n     * methods since they are eventually pointing to a user-declared generic\n     * method.\n     * \n     * @param method\n     *            the method to check\n     * @return {@code true} if the method can be considered as user-declared;\n     *         [@code false} otherwise\n     */\n    public static boolean isUserLevelMethod(Method method) {\n        Assert.notNull(method, \"Method must not be null\");\n        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));\n    }\n\n    private static boolean isGroovyObjectMethod(Method method) {\n        return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n    }\n\n    /**\n     * Determine whether the given method is overridable in the given target\n     * class.\n     * \n     * @param method\n     *            the method to check\n     * @param targetClass\n     *            the target class to check against\n     */\n    private static boolean isOverridable(Method method, Class<?> targetClass) {\n        if (Modifier.isPrivate(method.getModifiers())) {\n            return false;\n        }\n        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n            return true;\n        }\n        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));\n    }\n\n    /**\n     * Return a public static method of a class.\n     * \n     * @param clazz\n     *            the class which defines the method\n     * @param methodName\n     *            the static method name\n     * @param args\n     *            the parameter types to the method\n     * @return the static method, or {@code null} if no static method was found\n     * @throws IllegalArgumentException\n     *             if the method name is blank or the clazz is null\n     */\n    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        Assert.notNull(methodName, \"Method name must not be null\");\n        try {\n            Method method = clazz.getMethod(methodName, args);\n            return Modifier.isStatic(method.getModifiers()) ? method : null;\n        } catch (NoSuchMethodException ex) {\n            return null;\n        }\n    }\n\n    /**\n     * Check if the given class represents a primitive wrapper, i.e. Boolean,\n     * Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper class\n     */\n    public static boolean isPrimitiveWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return primitiveWrapperTypeMap.containsKey(clazz);\n    }\n\n    /**\n     * Check if the given class represents a primitive (i.e. boolean, byte,\n     * char, short, int, long, float, or double) or a primitive wrapper (i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive or primitive wrapper class\n     */\n    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));\n    }\n\n    /**\n     * Check if the given class represents an array of primitives, i.e. boolean,\n     * byte, char, short, int, long, float, or double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive array class\n     */\n    public static boolean isPrimitiveArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && clazz.getComponentType().isPrimitive());\n    }\n\n    /**\n     * Check if the given class represents an array of primitive wrappers, i.e.\n     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.\n     * \n     * @param clazz\n     *            the class to check\n     * @return whether the given class is a primitive wrapper array class\n     */\n    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));\n    }\n\n    /**\n     * Resolve the given class if it is a primitive class, returning the\n     * corresponding primitive wrapper type instead.\n     * \n     * @param clazz\n     *            the class to check\n     * @return the original class, or a primitive wrapper for the original\n     *         primitive type\n     */\n    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n    }\n\n    /**\n     * Check if the right-hand side type may be assigned to the left-hand side\n     * type, assuming setting by reflection. Considers primitive wrapper classes\n     * as assignable to the corresponding primitive types.\n     * \n     * @param lhsType\n     *            the target type\n     * @param rhsType\n     *            the value type that should be assigned to the target type\n     * @return if the target type is assignable from the value type\n     * @see TypeUtils#isAssignable\n     */\n    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {\n        Assert.notNull(lhsType, \"Left-hand side type must not be null\");\n        Assert.notNull(rhsType, \"Right-hand side type must not be null\");\n        if (lhsType.isAssignableFrom(rhsType)) {\n            return true;\n        }\n        if (lhsType.isPrimitive()) {\n            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);\n            if (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n                return true;\n            }\n        } else {\n            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);\n            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determine if the given type is assignable from the given value, assuming\n     * setting by reflection. Considers primitive wrapper classes as assignable\n     * to the corresponding primitive types.\n     * \n     * @param type\n     *            the target type\n     * @param value\n     *            the value that should be assigned to the type\n     * @return if the type is assignable from the value\n     */\n    public static boolean isAssignableValue(Class<?> type, Object value) {\n        Assert.notNull(type, \"Type must not be null\");\n        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());\n    }\n\n    /**\n     * Convert a \"/\"-based resource path to a \".\"-based fully qualified class\n     * name.\n     * \n     * @param resourcePath\n     *            the resource path pointing to a class\n     * @return the corresponding fully qualified class name\n     */\n    public static String convertResourcePathToClassName(String resourcePath) {\n        Assert.notNull(resourcePath, \"Resource path must not be null\");\n        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);\n    }\n\n    /**\n     * Convert a \".\"-based fully qualified class name to a \"/\"-based resource\n     * path.\n     * \n     * @param className\n     *            the fully qualified class name\n     * @return the corresponding resource path, pointing to the class\n     */\n    public static String convertClassNameToResourcePath(String className) {\n        Assert.notNull(className, \"Class name must not be null\");\n        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Return a path suitable for use with {@code ClassLoader.getResource} (also\n     * suitable for use with {@code Class.getResource} by prepending a slash\n     * ('/') to the return value). Built by taking the package of the specified\n     * class file, converting all dots ('.') to slashes ('/'), adding a trailing\n     * slash if necessary, and concatenating the specified resource name to\n     * this. <br/>\n     * As such, this function may be used to build a path suitable for loading a\n     * resource file that is in the same package as a class file, although\n     * {@link org.hotswap.agent.util.spring.io.resource.springframework.core.io.ClassPathResource}\n     * is usually even more convenient.\n     * \n     * @param clazz\n     *            the Class whose package will be used as the base\n     * @param resourceName\n     *            the resource name to append. A leading slash is optional.\n     * @return the built-up resource path\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        if (!resourceName.startsWith(\"/\")) {\n            return classPackageAsResourcePath(clazz) + \"/\" + resourceName;\n        }\n        return classPackageAsResourcePath(clazz) + resourceName;\n    }\n\n    /**\n     * Given an input class object, return a string which consists of the\n     * class's package name as a pathname, i.e., all dots ('.') are replaced by\n     * slashes ('/'). Neither a leading nor trailing slash is added. The result\n     * could be concatenated with a slash and the name of a resource and fed\n     * directly to {@code ClassLoader.getResource()}. For it to be fed to\n     * {@code Class.getResource} instead, a leading slash would also have to be\n     * prepended to the returned value.\n     * \n     * @param clazz\n     *            the input class. A {@code null} value or the default (empty)\n     *            package will result in an empty string (\"\") being returned.\n     * @return a path which represents the package name\n     * @see ClassLoader#getResource\n     * @see Class#getResource\n     */\n    public static String classPackageAsResourcePath(Class<?> clazz) {\n        if (clazz == null) {\n            return \"\";\n        }\n        String className = clazz.getName();\n        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n        if (packageEndIndex == -1) {\n            return \"\";\n        }\n        String packageName = className.substring(0, packageEndIndex);\n        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given array.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Class<?>... classes) {\n        return classNamesToString(Arrays.asList(classes));\n    }\n\n    /**\n     * Build a String that consists of the names of the classes/interfaces in\n     * the given collection.\n     * <p>\n     * Basically like {@code AbstractCollection.toString()}, but stripping the\n     * \"class \"/\"interface \" prefix before every class name.\n     * \n     * @param classes\n     *            a Collection of Class objects (may be {@code null})\n     * @return a String of form \"[com.foo.Bar, com.foo.Baz]\"\n     * @see java.util.AbstractCollection#toString()\n     */\n    public static String classNamesToString(Collection<Class<?>> classes) {\n        if (CollectionUtils.isEmpty(classes)) {\n            return \"[]\";\n        }\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n            Class<?> clazz = it.next();\n            sb.append(clazz.getName());\n            if (it.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    /**\n     * Copy the given Collection into a Class array. The Collection must contain\n     * Class elements only.\n     * \n     * @param collection\n     *            the Collection to copy\n     * @return the Class array ({@code null} if the passed-in Collection was\n     *         {@code null})\n     */\n    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {\n        if (collection == null) {\n            return null;\n        }\n        return collection.toArray(new Class<?>[collection.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as array,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as array\n     */\n    public static Class<?>[] getAllInterfaces(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClass(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {\n        return getAllInterfacesForClass(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as array, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as array\n     */\n    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {\n        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);\n        return ifcs.toArray(new Class<?>[ifcs.size()]);\n    }\n\n    /**\n     * Return all interfaces that the given instance implements as Set,\n     * including ones implemented by superclasses.\n     * \n     * @param instance\n     *            the instance to analyze for interfaces\n     * @return all interfaces that the given instance implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {\n        Assert.notNull(instance, \"Instance must not be null\");\n        return getAllInterfacesForClassAsSet(instance.getClass());\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {\n        return getAllInterfacesForClassAsSet(clazz, null);\n    }\n\n    /**\n     * Return all interfaces that the given class implements as Set, including\n     * ones implemented by superclasses.\n     * <p>\n     * If the class itself is an interface, it gets returned as sole interface.\n     * \n     * @param clazz\n     *            the class to analyze for interfaces\n     * @param classLoader\n     *            the ClassLoader that the interfaces need to be visible in (may\n     *            be {@code null} when accepting all declared interfaces)\n     * @return all interfaces that the given object implements as Set\n     */\n    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Assert.notNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>> singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }\n\n    /**\n     * Create a composite interface Class for the given interfaces, implementing\n     * the given interfaces in one single Class.\n     * <p>\n     * This implementation builds a JDK proxy class for the given interfaces.\n     * \n     * @param interfaces\n     *            the interfaces to merge\n     * @param classLoader\n     *            the ClassLoader to create the composite Class in\n     * @return the merged interface as Class\n     * @see java.lang.reflect.Proxy#getProxyClass\n     */\n    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {\n        Assert.notEmpty(interfaces, \"Interfaces must not be empty\");\n        Assert.notNull(classLoader, \"ClassLoader must not be null\");\n        return Proxy.getProxyClass(classLoader, interfaces);\n    }\n\n    /**\n     * Determine the common ancestor of the given classes, if any.\n     * \n     * @param clazz1\n     *            the class to introspect\n     * @param clazz2\n     *            the other class to introspect\n     * @return the common ancestor (i.e. common superclass, one interface\n     *         extending the other), or {@code null} if none found. If any of\n     *         the given classes is {@code null}, the other class will be\n     *         returned.\n     * @since 3.2.6\n     */\n    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {\n        if (clazz1 == null) {\n            return clazz2;\n        }\n        if (clazz2 == null) {\n            return clazz1;\n        }\n        if (clazz1.isAssignableFrom(clazz2)) {\n            return clazz1;\n        }\n        if (clazz2.isAssignableFrom(clazz1)) {\n            return clazz2;\n        }\n        Class<?> ancestor = clazz1;\n        do {\n            ancestor = ancestor.getSuperclass();\n            if (ancestor == null || Object.class == ancestor) {\n                return null;\n            }\n        } while (!ancestor.isAssignableFrom(clazz2));\n        return ancestor;\n    }\n\n    /**\n     * Check whether the given class is visible in the given ClassLoader.\n     * \n     * @param clazz\n     *            the class to check (typically an interface)\n     * @param classLoader\n     *            the ClassLoader to check against (may be {@code null}, in\n     *            which case this method will always return {@code true})\n     */\n    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {\n        if (classLoader == null) {\n            return true;\n        }\n        try {\n            Class<?> actualClass = classLoader.loadClass(clazz.getName());\n            return (clazz == actualClass);\n            // Else: different interface class found...\n        } catch (ClassNotFoundException ex) {\n            // No interface class found...\n            return false;\n        }\n    }\n\n    /**\n     * Check whether the given object is a CGLIB proxy.\n     * \n     * @param object\n     *            the object to check\n     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)\n     */\n    public static boolean isCglibProxy(Object object) {\n        return ClassUtils.isCglibProxyClass(object.getClass());\n    }\n\n    /**\n     * Check whether the specified class is a CGLIB-generated class.\n     * \n     * @param clazz\n     *            the class to check\n     */\n    public static boolean isCglibProxyClass(Class<?> clazz) {\n        return (clazz != null && isCglibProxyClassName(clazz.getName()));\n    }\n\n    /**\n     * Check whether the specified class name is a CGLIB-generated class.\n     * \n     * @param className\n     *            the class name to check\n     */\n    public static boolean isCglibProxyClassName(String className) {\n        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));\n    }\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "ClassPath", "org.hotswap.agent.javassist" ], [ "CtMethod", "org.hotswap.agent.javassist" ], [ "CtField", "org.hotswap.agent.javassist" ], [ "BadHttpRequest", "org.hotswap.agent.javassist.tools.web" ], [ "Viewer", "org.hotswap.agent.javassist.tools.web" ], [ "Webserver", "org.hotswap.agent.javassist.tools.web" ], [ "ServiceThread", "org.hotswap.agent.javassist.tools.web" ], [ "CannotInvokeException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Reflection", "org.hotswap.agent.javassist.tools.reflect" ], [ "Loader", "org.hotswap.agent.javassist.tools.reflect" ], [ "Sample", "org.hotswap.agent.javassist.tools.reflect" ], [ "CompiledClass", "org.hotswap.agent.javassist.tools.reflect" ], [ "Compiler", "org.hotswap.agent.javassist.tools.reflect" ], [ "ClassMetaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotReflectException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metaobject", "org.hotswap.agent.javassist.tools.reflect" ], [ "Metalevel", "org.hotswap.agent.javassist.tools.reflect" ], [ "CannotCreateException", "org.hotswap.agent.javassist.tools.reflect" ], [ "Callback", "org.hotswap.agent.javassist.tools" ], [ "RemoteRef", "org.hotswap.agent.javassist.tools.rmi" ], [ "StubGenerator", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectNotFoundException", "org.hotswap.agent.javassist.tools.rmi" ], [ "Sample", "org.hotswap.agent.javassist.tools.rmi" ], [ "AppletServer", "org.hotswap.agent.javassist.tools.rmi" ], [ "ExportedObject", "org.hotswap.agent.javassist.tools.rmi" ], [ "ObjectImporter", "org.hotswap.agent.javassist.tools.rmi" ], [ "Proxy", "org.hotswap.agent.javassist.tools.rmi" ], [ "RemoteException", "org.hotswap.agent.javassist.tools.rmi" ], [ "framedump", "org.hotswap.agent.javassist.tools" ], [ "Dump", "org.hotswap.agent.javassist.tools" ], [ "ClassPathList", "org.hotswap.agent.javassist" ], [ "DirClassPath", "org.hotswap.agent.javassist" ], [ "JarDirClassPath", "org.hotswap.agent.javassist" ], [ "JarClassPath", "org.hotswap.agent.javassist" ], [ "ClassPoolTail", "org.hotswap.agent.javassist" ], [ "ByteArrayClassPath", "org.hotswap.agent.javassist" ], [ "Modifier", "org.hotswap.agent.javassist" ], [ "Trigger", "org.hotswap.agent.javassist.util" ], [ "HotSwapper", "org.hotswap.agent.javassist.util" ], [ "HotSwapAgent", "org.hotswap.agent.javassist.util" ], [ "ProxyFactory", "org.hotswap.agent.javassist.util.proxy" ], [ "SerializedProxy", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodHandler", "org.hotswap.agent.javassist.util.proxy" ], [ "FactoryHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectOutputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "DefinePackageHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObjectInputStream", "org.hotswap.agent.javassist.util.proxy" ], [ "MethodFilter", "org.hotswap.agent.javassist.util.proxy" ], [ "Proxy", "org.hotswap.agent.javassist.util.proxy" ], [ "DefineClassHelper", "org.hotswap.agent.javassist.util.proxy" ], [ "RuntimeSupport", "org.hotswap.agent.javassist.util.proxy" ], [ "SecurityActions", "org.hotswap.agent.javassist.util.proxy" ], [ "ProxyObject", "org.hotswap.agent.javassist.util.proxy" ], [ "CtNewConstructor", "org.hotswap.agent.javassist" ], [ "ClassClassPath", "org.hotswap.agent.javassist" ], [ "Loader", "org.hotswap.agent.javassist" ], [ "CtNewWrappedMethod", "org.hotswap.agent.javassist" ], [ "Inner", "org.hotswap.agent.javassist.runtime" ], [ "Cflow", "org.hotswap.agent.javassist.runtime" ], [ "DotClass", "org.hotswap.agent.javassist.runtime" ], [ "Desc", "org.hotswap.agent.javassist.runtime" ], [ "ExprEditor", "org.hotswap.agent.javassist.expr" ], [ "Handler", "org.hotswap.agent.javassist.expr" ], [ "FieldAccess", "org.hotswap.agent.javassist.expr" ], [ "NewArray", "org.hotswap.agent.javassist.expr" ], [ "Instanceof", "org.hotswap.agent.javassist.expr" ], [ "Cast", "org.hotswap.agent.javassist.expr" ], [ "ConstructorCall", "org.hotswap.agent.javassist.expr" ], [ "Expr", "org.hotswap.agent.javassist.expr" ], [ "NewExpr", "org.hotswap.agent.javassist.expr" ], [ "MethodCall", "org.hotswap.agent.javassist.expr" ], [ "CtArray", "org.hotswap.agent.javassist" ], [ "CtConstructor", "org.hotswap.agent.javassist" ], [ "CtNewClass", "org.hotswap.agent.javassist" ], [ "Translator", "org.hotswap.agent.javassist" ], [ "CtMember", "org.hotswap.agent.javassist" ], [ "CtNewMethod", "org.hotswap.agent.javassist" ], [ "ClassPool", "org.hotswap.agent.javassist" ], [ "CtClass", "org.hotswap.agent.javassist" ], [ "ClassMap", "org.hotswap.agent.javassist" ], [ "CtClassType", "org.hotswap.agent.javassist" ], [ "FieldInitLink", "org.hotswap.agent.javassist" ], [ "LocalVariableAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "TypeAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "StackMap", "org.hotswap.agent.javassist.bytecode" ], [ "MethodInfo", "org.hotswap.agent.javassist.bytecode" ], [ "AttributeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Analyzer", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "SubroutineScanner", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Subroutine", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Util", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Type", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Frame", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "IntQueue", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "FramePrinter", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "ControlFlow", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "Executor", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "MultiArrayType", "org.hotswap.agent.javassist.bytecode.analysis" ], [ "CodeAnalyzer", "org.hotswap.agent.javassist.bytecode" ], [ "EnclosingMethodAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Descriptor", "org.hotswap.agent.javassist.bytecode" ], [ "NestMembersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SyntheticAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "InstructionPrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFilePrinter", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFile", "org.hotswap.agent.javassist.bytecode" ], [ "StackMapTable", "org.hotswap.agent.javassist.bytecode" ], [ "BootstrapMethodsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Tracer", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypedBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeTag", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "BasicBlock", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "TypeData", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "MapMaker", "org.hotswap.agent.javassist.bytecode.stackmap" ], [ "DeprecatedAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AccessFlag", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationImpl", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ShortMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValueVisitor", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "NoSuchClassError", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "AnnotationMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "MemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "StringMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ArrayMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "FloatMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ClassMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "CharMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "ByteMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "IntegerMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "EnumMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "BooleanMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "TypeAnnotationsWriter", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DoubleMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "LongMemberValue", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "Annotation", "org.hotswap.agent.javassist.bytecode.annotation" ], [ "DuplicateMemberException", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationDefaultAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Opcode", "org.hotswap.agent.javassist.bytecode" ], [ "InnerClassesAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "AnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstantAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTableEntry", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionTable", "org.hotswap.agent.javassist.bytecode" ], [ "CodeIterator", "org.hotswap.agent.javassist.bytecode" ], [ "LineNumberAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "Mnemonic", "org.hotswap.agent.javassist.bytecode" ], [ "BadBytecode", "org.hotswap.agent.javassist.bytecode" ], [ "SignatureAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "MethodParametersAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "SourceFileAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LongVector", "org.hotswap.agent.javassist.bytecode" ], [ "ByteArray", "org.hotswap.agent.javassist.bytecode" ], [ "NestHostAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ConstPool", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ConstInfoPadding", "org.hotswap.agent.javassist.bytecode" ], [ "ClassInfo", "org.hotswap.agent.javassist.bytecode" ], [ "NameAndTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MemberrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FieldrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InterfaceMethodrefInfo", "org.hotswap.agent.javassist.bytecode" ], [ "StringInfo", "org.hotswap.agent.javassist.bytecode" ], [ "IntegerInfo", "org.hotswap.agent.javassist.bytecode" ], [ "FloatInfo", "org.hotswap.agent.javassist.bytecode" ], [ "LongInfo", "org.hotswap.agent.javassist.bytecode" ], [ "DoubleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "Utf8Info", "org.hotswap.agent.javassist.bytecode" ], [ "MethodHandleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "MethodTypeInfo", "org.hotswap.agent.javassist.bytecode" ], [ "InvokeDynamicInfo", "org.hotswap.agent.javassist.bytecode" ], [ "ModuleInfo", "org.hotswap.agent.javassist.bytecode" ], [ "PackageInfo", "org.hotswap.agent.javassist.bytecode" ], [ "CodeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ByteVector", "org.hotswap.agent.javassist.bytecode" ], [ "Bytecode", "org.hotswap.agent.javassist.bytecode" ], [ "ClassFileWriter", "org.hotswap.agent.javassist.bytecode" ], [ "ByteStream", "org.hotswap.agent.javassist.bytecode" ], [ "ParameterAnnotationsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "ExceptionsAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "LocalVariableTypeAttribute", "org.hotswap.agent.javassist.bytecode" ], [ "CodeConverter", "org.hotswap.agent.javassist" ], [ "SerialVersionUID", "org.hotswap.agent.javassist" ], [ "URLClassPath", "org.hotswap.agent.javassist" ], [ "CtPrimitiveType", "org.hotswap.agent.javassist" ], [ "CannotCompileException", "org.hotswap.agent.javassist" ], [ "NotFoundException", "org.hotswap.agent.javassist" ], [ "CtNewWrappedConstructor", "org.hotswap.agent.javassist" ], [ "ScopedClassPoolRepositoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolRepository", "org.hotswap.agent.javassist.scopedpool" ], [ "SoftValueHashMap", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactoryImpl", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPoolFactory", "org.hotswap.agent.javassist.scopedpool" ], [ "ScopedClassPool", "org.hotswap.agent.javassist.scopedpool" ], [ "TypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "JvstTypeChecker", "org.hotswap.agent.javassist.compiler" ], [ "Parser", "org.hotswap.agent.javassist.compiler" ], [ "KeywordTable", "org.hotswap.agent.javassist.compiler" ], [ "CompileError", "org.hotswap.agent.javassist.compiler" ], [ "SymbolTable", "org.hotswap.agent.javassist.compiler" ], [ "Token", "org.hotswap.agent.javassist.compiler" ], [ "Lex", "org.hotswap.agent.javassist.compiler" ], [ "NoFieldException", "org.hotswap.agent.javassist.compiler" ], [ "JvstCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "ProceedHandler", "org.hotswap.agent.javassist.compiler" ], [ "TokenId", "org.hotswap.agent.javassist.compiler" ], [ "CodeGen", "org.hotswap.agent.javassist.compiler" ], [ "MemberCodeGen", "org.hotswap.agent.javassist.compiler" ], [ "Javac", "org.hotswap.agent.javassist.compiler" ], [ "StringL", "org.hotswap.agent.javassist.compiler.ast" ], [ "Stmnt", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTList", "org.hotswap.agent.javassist.compiler.ast" ], [ "InstanceOfExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "ASTree", "org.hotswap.agent.javassist.compiler.ast" ], [ "Pair", "org.hotswap.agent.javassist.compiler.ast" ], [ "Declarator", "org.hotswap.agent.javassist.compiler.ast" ], [ "Visitor", "org.hotswap.agent.javassist.compiler.ast" ], [ "CallExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "AssignExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "DoubleConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "CastExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "BinExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "Variable", "org.hotswap.agent.javassist.compiler.ast" ], [ "MethodDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "CondExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "FieldDecl", "org.hotswap.agent.javassist.compiler.ast" ], [ "Symbol", "org.hotswap.agent.javassist.compiler.ast" ], [ "Member", "org.hotswap.agent.javassist.compiler.ast" ], [ "Expr", "org.hotswap.agent.javassist.compiler.ast" ], [ "NewExpr", "org.hotswap.agent.javassist.compiler.ast" ], [ "IntConst", "org.hotswap.agent.javassist.compiler.ast" ], [ "ArrayInit", "org.hotswap.agent.javassist.compiler.ast" ], [ "Keyword", "org.hotswap.agent.javassist.compiler.ast" ], [ "AccessorMaker", "org.hotswap.agent.javassist.compiler" ], [ "MemberResolver", "org.hotswap.agent.javassist.compiler" ], [ "SyntaxError", "org.hotswap.agent.javassist.compiler" ], [ "LoaderClassPath", "org.hotswap.agent.javassist" ], [ "TransformFieldAccess", "org.hotswap.agent.javassist.convert" ], [ "TransformAfter", "org.hotswap.agent.javassist.convert" ], [ "TransformCall", "org.hotswap.agent.javassist.convert" ], [ "TransformAccessArrayField", "org.hotswap.agent.javassist.convert" ], [ "Transformer", "org.hotswap.agent.javassist.convert" ], [ "TransformNew", "org.hotswap.agent.javassist.convert" ], [ "TransformNewClass", "org.hotswap.agent.javassist.convert" ], [ "TransformWriteField", "org.hotswap.agent.javassist.convert" ], [ "TransformBefore", "org.hotswap.agent.javassist.convert" ], [ "TransformReadField", "org.hotswap.agent.javassist.convert" ], [ "CtBehavior", "org.hotswap.agent.javassist" ], [ "HotswapAgent", "org.hotswap.agent" ], [ "IOUtils", "org.hotswap.agent.util" ], [ "AppClassLoaderExecutor", "org.hotswap.agent.util" ], [ "WaitHelper", "org.hotswap.agent.util.test" ], [ "CtClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureElement", "org.hotswap.agent.util.signature" ], [ "ClassSignatureBase", "org.hotswap.agent.util.signature" ], [ "JavaClassSignature", "org.hotswap.agent.util.signature" ], [ "ClassSignatureComparerHelper", "org.hotswap.agent.util.signature" ], [ "AnnotationHelper", "org.hotswap.agent.util" ], [ "ClassLoaderHelper", "org.hotswap.agent.util.classloader" ], [ "HotswapAgentClassLoaderExt", "org.hotswap.agent.util.classloader" ], [ "WatchResourcesClassLoader", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderProxy", "org.hotswap.agent.util.classloader" ], [ "ClassLoaderDefineClassPatcher", "org.hotswap.agent.util.classloader" ], [ "URLClassPathHelper", "org.hotswap.agent.util.classloader" ], [ "PluginManagerInvoker", "org.hotswap.agent.util" ], [ "HotswapTransformer", "org.hotswap.agent.util" ], [ "HotswapProperties", "org.hotswap.agent.util" ], [ "ReflectionHelper", "org.hotswap.agent.util" ], [ "HaClassFileTransformer", "org.hotswap.agent.util" ], [ "PluginCache", "org.hotswap.agent.util.scanner" ], [ "Scanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathScanner", "org.hotswap.agent.util.scanner" ], [ "ClassPathAnnotationScanner", "org.hotswap.agent.util.scanner" ], [ "ScannerVisitor", "org.hotswap.agent.util.scanner" ], [ "Version", "org.hotswap.agent.util" ], [ "VfsUtils", "org.hotswap.agent.util.spring.util" ], [ "StringUtils", "org.hotswap.agent.util.spring.util" ], [ "ClassUtils", "org.hotswap.agent.util.spring.util" ], [ "CollectionUtils", "org.hotswap.agent.util.spring.util" ], [ "Assert", "org.hotswap.agent.util.spring.util" ], [ "WeakReferenceMonitor", "org.hotswap.agent.util.spring.util" ], [ "PatternMatchUtils", "org.hotswap.agent.util.spring.util" ], [ "ResourceUtils", "org.hotswap.agent.util.spring.util" ], [ "ObjectUtils", "org.hotswap.agent.util.spring.util" ], [ "ReflectionUtils", "org.hotswap.agent.util.spring.util" ], [ "AntPathMatcher", "org.hotswap.agent.util.spring.path" ], [ "ResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "PathMatcher", "org.hotswap.agent.util.spring.path" ], [ "VfsPatternUtils", "org.hotswap.agent.util.spring.path" ], [ "PathMatchingResourcePatternResolver", "org.hotswap.agent.util.spring.path" ], [ "FileSystemResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "DefaultResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ClassRelativeResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "ResourceLoader", "org.hotswap.agent.util.spring.io.loader" ], [ "AbstractResource", "org.hotswap.agent.util.spring.io.resource" ], [ "VfsResource", "org.hotswap.agent.util.spring.io.resource" ], [ "AbstractFileResolvingResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ContextResource", "org.hotswap.agent.util.spring.io.resource" ], [ "Resource", "org.hotswap.agent.util.spring.io.resource" ], [ "PathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedIOException", "org.hotswap.agent.util.spring.io.resource" ], [ "WritableResource", "org.hotswap.agent.util.spring.io.resource" ], [ "FileSystemResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamSource", "org.hotswap.agent.util.spring.io.resource" ], [ "NestedExceptionUtils", "org.hotswap.agent.util.spring.io.resource" ], [ "UrlResource", "org.hotswap.agent.util.spring.io.resource" ], [ "ClassPathResource", "org.hotswap.agent.util.spring.io.resource" ], [ "InputStreamResource", "org.hotswap.agent.util.spring.io.resource" ], [ "LinkedMultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "ConcurrentReferenceHashMap", "org.hotswap.agent.util.spring.collections" ], [ "MultiValueMap", "org.hotswap.agent.util.spring.collections" ], [ "PluginRegistry", "org.hotswap.agent.config" ], [ "PluginInitializedListener", "org.hotswap.agent.config" ], [ "ClassLoaderInitListener", "org.hotswap.agent.config" ], [ "PluginManager", "org.hotswap.agent.config" ], [ "ScheduledHotswapCommand", "org.hotswap.agent.config" ], [ "PluginConfiguration", "org.hotswap.agent.config" ], [ "LogConfigurationHelper", "org.hotswap.agent.config" ], [ "JdkPlugin", "org.hotswap.agent.plugin.jdk" ], [ "AnonymousClassInfos", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassInfo", "org.hotswap.agent.plugin.jvm" ], [ "AnonymousClassPatchPlugin", "org.hotswap.agent.plugin.jvm" ], [ "ClassInitPlugin", "org.hotswap.agent.plugin.jvm" ], [ "WatchResourcesPlugin", "org.hotswap.agent.plugin.watchResources" ], [ "HotSwapper", "org.hotswap.agent.plugin.hotswapper" ], [ "Trigger", "org.hotswap.agent.plugin.hotswapper" ], [ "HotSwapperJpda", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperCommand", "org.hotswap.agent.plugin.hotswapper" ], [ "HotswapperPlugin", "org.hotswap.agent.plugin.hotswapper" ], [ "Restriction", "org.hotswap.agent.versions" ], [ "DeploymentInfo", "org.hotswap.agent.versions" ], [ "ArtifactVersion", "org.hotswap.agent.versions" ], [ "MavenInfo", "org.hotswap.agent.versions" ], [ "VersionRange", "org.hotswap.agent.versions" ], [ "AbstractMatcher", "org.hotswap.agent.versions.matcher" ], [ "MavenMatcher", "org.hotswap.agent.versions.matcher" ], [ "PluginMatcher", "org.hotswap.agent.versions.matcher" ], [ "MethodMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestMatcher", "org.hotswap.agent.versions.matcher" ], [ "ManifestInfo", "org.hotswap.agent.versions" ], [ "InvalidVersionSpecificationException", "org.hotswap.agent.versions" ], [ "VersionMatchResult", "org.hotswap.agent.versions" ], [ "ComparableVersion", "org.hotswap.agent.versions" ], [ "VersionMatcher", "org.hotswap.agent.versions" ], [ "ManifestMiniDumper", "org.hotswap.agent.versions" ], [ "OnClassLoadedHandler", "org.hotswap.agent.annotation.handler" ], [ "PluginAnnotation", "org.hotswap.agent.annotation.handler" ], [ "PluginHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventCommand", "org.hotswap.agent.annotation.handler" ], [ "WatchHandler", "org.hotswap.agent.annotation.handler" ], [ "AnnotationProcessor", "org.hotswap.agent.annotation.handler" ], [ "PluginClassFileTransformer", "org.hotswap.agent.annotation.handler" ], [ "InitHandler", "org.hotswap.agent.annotation.handler" ], [ "WatchEventDTO", "org.hotswap.agent.annotation.handler" ], [ "Init", "org.hotswap.agent.annotation" ], [ "Manifest", "org.hotswap.agent.annotation" ], [ "Plugin", "org.hotswap.agent.annotation" ], [ "Versions", "org.hotswap.agent.annotation" ], [ "OnClassLoadEvent", "org.hotswap.agent.annotation" ], [ "FileEvent", "org.hotswap.agent.annotation" ], [ "Name", "org.hotswap.agent.annotation" ], [ "OnResourceFileEvent", "org.hotswap.agent.annotation" ], [ "OnClassFileEvent", "org.hotswap.agent.annotation" ], [ "LoadEvent", "org.hotswap.agent.annotation" ], [ "Maven", "org.hotswap.agent.annotation" ], [ "WatchFileEvent", "org.hotswap.agent.watch" ], [ "Watcher", "org.hotswap.agent.watch" ], [ "WatcherFactory", "org.hotswap.agent.watch" ], [ "WatchEventListener", "org.hotswap.agent.watch" ], [ "HotswapWatchFileEvent", "org.hotswap.agent.watch.nio" ], [ "EventDispatcher", "org.hotswap.agent.watch.nio" ], [ "WatcherNIO2", "org.hotswap.agent.watch.nio" ], [ "AbstractNIO2Watcher", "org.hotswap.agent.watch.nio" ], [ "TreeWatcherNIO", "org.hotswap.agent.watch.nio" ], [ "SchedulerImpl", "org.hotswap.agent.command.impl" ], [ "CommandExecutor", "org.hotswap.agent.command.impl" ], [ "CommandExecutionListener", "org.hotswap.agent.command" ], [ "Scheduler", "org.hotswap.agent.command" ], [ "Command", "org.hotswap.agent.command" ], [ "ReflectionCommand", "org.hotswap.agent.command" ], [ "MergeableCommand", "org.hotswap.agent.command" ], [ "AgentLogger", "org.hotswap.agent.logging" ], [ "AgentLoggerHandler", "org.hotswap.agent.logging" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtMethod", "public static CtMethod make(MethodInfo minfo, CtClass declaring) throws CannotCompileException" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "CtMethod", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "CtMethod", "static String defaultConstDescriptor()" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(int i)" ], [ "integer", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter integer(long i)" ], [ "string", "org.hotswap.agent.javassist", "ConstParameter", "public static ConstParameter string(String s)" ], [ "defaultDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultDescriptor()" ], [ "defaultConstDescriptor", "org.hotswap.agent.javassist", "ConstParameter", "static String defaultConstDescriptor()" ], [ "make", "org.hotswap.agent.javassist", "CtField", "public static CtField make(String src, CtClass declaring) throws CannotCompileException" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "CtField", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "CtField", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "CtField", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "CtField", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "CtField", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "CtField", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(int i)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(boolean b)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(long l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(float l)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(double d)" ], [ "constant", "org.hotswap.agent.javassist", "Initializer", "public static Initializer constant(String s)" ], [ "byParameter", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byParameter(int nth)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType)" ], [ "byNew", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNew(CtClass objectType, String[] stringParams)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType)" ], [ "byNewWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewWithParams(CtClass objectType, String[] stringParams)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName)" ], [ "byCall", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCall(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName)" ], [ "byCallWithParams", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byCallWithParams(CtClass methodClass, String methodName, String[] stringParams)" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int size) throws NotFoundException" ], [ "byNewArray", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byNewArray(CtClass type, int[] sizes)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "public static Initializer byExpr(String source)" ], [ "byExpr", "org.hotswap.agent.javassist", "Initializer", "static Initializer byExpr(ASTree source)" ], [ "nthParamToLocal", "org.hotswap.agent.javassist", "ParamInitializer", "static int nthParamToLocal(int nth, CtClass[] params, boolean isStatic)" ], [ "trapStatic", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapStatic(Object[] args, int identifier) throws Throwable" ], [ "trapRead", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapRead(Object[] args, String name)" ], [ "trapWrite", "org.hotswap.agent.javassist.tools.reflect", "Sample", "public static Object trapWrite(Object[] args, String name)" ], [ "invoke", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static public Object invoke(Object target, int identifier, Object[] args) throws Throwable" ], [ "insertAt", "org.hotswap.agent.javassist.tools", "Callback", "public static int insertAt(CtBehavior behavior, Callback callback, int lineNum) throws CannotCompileException" ], [ "forwardStatic", "org.hotswap.agent.javassist.tools.rmi", "Sample", "public static Object forwardStatic(Object[] args, int identifier) throws RemoteException" ], [ "readStream", "org.hotswap.agent.javassist", "ClassPoolTail", "public static byte[] readStream(InputStream fin) throws IOException" ], [ "isPublic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPublic(int mod)" ], [ "isPrivate", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPrivate(int mod)" ], [ "isProtected", "org.hotswap.agent.javassist", "Modifier", "public static boolean isProtected(int mod)" ], [ "isPackage", "org.hotswap.agent.javassist", "Modifier", "public static boolean isPackage(int mod)" ], [ "isStatic", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStatic(int mod)" ], [ "isFinal", "org.hotswap.agent.javassist", "Modifier", "public static boolean isFinal(int mod)" ], [ "isSynchronized", "org.hotswap.agent.javassist", "Modifier", "public static boolean isSynchronized(int mod)" ], [ "isVolatile", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVolatile(int mod)" ], [ "isTransient", "org.hotswap.agent.javassist", "Modifier", "public static boolean isTransient(int mod)" ], [ "isNative", "org.hotswap.agent.javassist", "Modifier", "public static boolean isNative(int mod)" ], [ "isInterface", "org.hotswap.agent.javassist", "Modifier", "public static boolean isInterface(int mod)" ], [ "isAnnotation", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAnnotation(int mod)" ], [ "isEnum", "org.hotswap.agent.javassist", "Modifier", "public static boolean isEnum(int mod)" ], [ "isAbstract", "org.hotswap.agent.javassist", "Modifier", "public static boolean isAbstract(int mod)" ], [ "isStrict", "org.hotswap.agent.javassist", "Modifier", "public static boolean isStrict(int mod)" ], [ "isVarArgs", "org.hotswap.agent.javassist", "Modifier", "public static boolean isVarArgs(int mod)" ], [ "setPublic", "org.hotswap.agent.javassist", "Modifier", "public static int setPublic(int mod)" ], [ "setProtected", "org.hotswap.agent.javassist", "Modifier", "public static int setProtected(int mod)" ], [ "setPrivate", "org.hotswap.agent.javassist", "Modifier", "public static int setPrivate(int mod)" ], [ "setPackage", "org.hotswap.agent.javassist", "Modifier", "public static int setPackage(int mod)" ], [ "clear", "org.hotswap.agent.javassist", "Modifier", "public static int clear(int mod, int clearBit)" ], [ "toString", "org.hotswap.agent.javassist", "Modifier", "public static String toString(int mod)" ], [ "createAgentJarFile", "org.hotswap.agent.javassist.util", "HotSwapAgent", "public static File createAgentJarFile(String fileName) throws IOException, CannotCompileException, NotFoundException" ], [ "isProxyClass", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean isProxyClass(Class<?> cl)" ], [ "getFilterSignature", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "static byte[] getFilterSignature(Class<?> clazz)" ], [ "getHandler", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static MethodHandler getHandler(Proxy p)" ], [ "typeIndex", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int typeIndex(Class<?> type)" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, ClassLoader loader) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static Class<?> toClass(ClassFile cf, java.lang.invoke.MethodHandles.Lookup lookup) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(String className, Class<?> neighbor, ClassLoader loader, ProtectionDomain domain, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Class<?> neighbor, byte[] bcode) throws CannotCompileException" ], [ "toClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "public static Class<?> toClass(Lookup lookup, byte[] bcode) throws CannotCompileException" ], [ "toPublicClass", "org.hotswap.agent.javassist.util.proxy", "DefineClassHelper", "static Class<?> toPublicClass(String className, byte[] bcode) throws CannotCompileException" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Object self, String name, String desc)" ], [ "findMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findMethod(Class<?> clazz, String name, String desc)" ], [ "findSuperMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperMethod(Object self, String name, String desc)" ], [ "findSuperClassMethod", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static Method findSuperClassMethod(Class<?> clazz, String name, String desc)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Method m)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(Class<?>[] params, Class<?> retType)" ], [ "makeDescriptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static String makeDescriptor(String params, Class<?> retType)" ], [ "makeSerializedProxy", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static SerializedProxy makeSerializedProxy(Object proxy) throws java.io.InvalidClassException" ], [ "getDeclaredMethods", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method[] getDeclaredMethods(final Class<?> clazz)" ], [ "getDeclaredConstructors", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?>[] getDeclaredConstructors(final Class<?> clazz)" ], [ "getMethodHandle", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static MethodHandle getMethodHandle(final Class<?> clazz, final String name, final Class<?>[] params) throws NoSuchMethodException" ], [ "getDeclaredMethod", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Method getDeclaredMethod(final Class<?> clazz, final String name, final Class<?>[] types) throws NoSuchMethodException" ], [ "getDeclaredConstructor", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static Constructor<?> getDeclaredConstructor(final Class<?> clazz, final Class<?>[] types) throws NoSuchMethodException" ], [ "getSunMiscUnsafeAnonymously", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "static TheUnsafe getSunMiscUnsafeAnonymously() throws ClassNotFoundException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor copy(CtConstructor c, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "defaultConstructor", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor defaultConstructor(CtClass declaring) throws CannotCompileException" ], [ "skeleton", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor skeleton(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewConstructor", "public static CtConstructor make(CtClass[] parameters, CtClass[] exceptions, int howto, CtMethod body, ConstParameter cparam, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static Bytecode makeBody(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, CtClass[] parameters, CtClass returnType, ConstParameter cparam) throws CannotCompileException" ], [ "makeBody0", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "protected static int makeBody0(CtClass clazz, ClassFile classfile, CtMethod wrappedBody, boolean isStatic, CtClass[] parameters, CtClass returnType, ConstParameter cparam, Bytecode code) throws CannotCompileException" ], [ "compileParameterList", "org.hotswap.agent.javassist", "CtNewWrappedMethod", "static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "fail", "org.hotswap.agent.javassist.runtime", "DotClass", "public static NoClassDefFoundError fail(ClassNotFoundException e)" ], [ "getClazz", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getClazz(String name)" ], [ "getParams", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?>[] getParams(String desc)" ], [ "getType", "org.hotswap.agent.javassist.runtime", "Desc", "public static Class<?> getType(String desc)" ], [ "isStatic", "org.hotswap.agent.javassist.expr", "FieldAccess", "static boolean isStatic(int c)" ], [ "checkResultValue", "org.hotswap.agent.javassist.expr", "Expr", "static final boolean checkResultValue(CtClass retType, String prog) throws CannotCompileException" ], [ "count", "org.hotswap.agent.javassist", "CtMember", "static int count(CtMember head, CtMember tail)" ], [ "count", "org.hotswap.agent.javassist", "Cache", "static int count(CtMember head, CtMember tail)" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(String src, CtClass declaring, String delegateObj, String delegateMethod) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "make", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod make(int modifiers, CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, String body, CtClass declaring) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "copy", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod copy(CtMethod src, String name, CtClass declaring, ClassMap map) throws CannotCompileException" ], [ "abstractMethod", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod abstractMethod(CtClass returnType, String mname, CtClass[] parameters, CtClass[] exceptions, CtClass declaring) throws NotFoundException" ], [ "getter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod getter(String methodName, CtField field) throws CannotCompileException" ], [ "setter", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod setter(String methodName, CtField field) throws CannotCompileException" ], [ "delegator", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod delegator(CtMethod delegate, CtClass declaring) throws CannotCompileException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewMethod", "public static CtMethod wrapped(CtClass returnType, String mname, CtClass[] parameterTypes, CtClass[] exceptionTypes, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "getDefault", "org.hotswap.agent.javassist", "ClassPool", "public static synchronized ClassPool getDefault()" ], [ "getContextClassLoader", "org.hotswap.agent.javassist", "ClassPool", "static ClassLoader getContextClassLoader()" ], [ "toJvmName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist", "ClassMap", "public static String toJavaName(String classname)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "hasAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static boolean hasAnnotationType(String annotationTypeName, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2)" ], [ "getAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object getAnnotationType(Class<?> clz, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[] toAnnotationType(boolean ignoreNotFound, ClassPool cp, AnnotationsAttribute a1, AnnotationsAttribute a2) throws ClassNotFoundException" ], [ "toAnnotationType", "org.hotswap.agent.javassist", "CtClassType", "static Object[][] toAnnotationType(boolean ignoreNotFound, ClassPool cp, ParameterAnnotationsAttribute a1, ParameterAnnotationsAttribute a2, MethodInfo minfo) throws ClassNotFoundException" ], [ "read", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo read(ConstPool cp, DataInputStream in) throws IOException" ], [ "getLength", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static int getLength(List<AttributeInfo> attributes)" ], [ "lookup", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static AttributeInfo lookup(List<AttributeInfo> attributes, String name)" ], [ "remove", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static synchronized AttributeInfo remove(List<AttributeInfo> attributes, String name)" ], [ "copyAll", "org.hotswap.agent.javassist.bytecode", "AttributeInfo", "static List<AttributeInfo> copyAll(List<AttributeInfo> attributes, ConstPool cp)" ], [ "getJumpTarget", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static int getJumpTarget(int pos, CodeIterator iter)" ], [ "isJumpInstruction", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJumpInstruction(int opcode)" ], [ "isGoto", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isGoto(int opcode)" ], [ "isJsr", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isJsr(int opcode)" ], [ "isReturn", "org.hotswap.agent.javassist.bytecode.analysis", "Util", "public static boolean isReturn(int opcode)" ], [ "get", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static Type get(CtClass clazz)" ], [ "eq", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "static boolean eq(CtClass one, CtClass two)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(String classname)" ], [ "toJavaName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJavaName(String classname)" ], [ "toJvmName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toJvmName(CtClass clazz)" ], [ "toClassName", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toClassName(String descriptor)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(String classname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, String oldname, String newname)" ], [ "rename", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String rename(String desc, Map<String, String> map)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String of(CtClass type)" ], [ "ofConstructor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofConstructor(CtClass[] paramTypes)" ], [ "ofMethod", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofMethod(CtClass returnType, CtClass[] paramTypes)" ], [ "ofParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String ofParameters(CtClass[] paramTypes)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(String classname, String desc)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(String classname, String desc)" ], [ "appendParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String appendParameter(CtClass type, String descriptor)" ], [ "insertParameter", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String insertParameter(CtClass type, String descriptor)" ], [ "changeReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String changeReturnType(String classname, String desc)" ], [ "getParameterTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass[] getParameterTypes(String desc, ClassPool cp) throws NotFoundException" ], [ "eqParamTypes", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static boolean eqParamTypes(String desc1, String desc2)" ], [ "getParamDescriptor", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String getParamDescriptor(String decl)" ], [ "getReturnType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass getReturnType(String desc, ClassPool cp) throws NotFoundException" ], [ "numOfParameters", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int numOfParameters(String desc)" ], [ "toCtClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static CtClass toCtClass(String desc, ClassPool cp) throws NotFoundException" ], [ "toPrimitiveClass", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static CtClass toPrimitiveClass(char c)" ], [ "arrayDimension", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int arrayDimension(String desc)" ], [ "toArrayComponent", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toArrayComponent(String desc, int dim)" ], [ "dataSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int dataSize(String desc)" ], [ "paramSize", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static int paramSize(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "public static String toString(String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "Descriptor", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "toString", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static String toString(String desc)" ], [ "readType", "org.hotswap.agent.javassist.bytecode", "PrettyPrinter", "static int readType(StringBuffer sbuf, int pos, String desc)" ], [ "instructionString", "org.hotswap.agent.javassist.bytecode", "InstructionPrinter", "public static String instructionString(CodeIterator iter, int pos, ConstPool pool)" ], [ "typeTagOf", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static int typeTagOf(char descriptor)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "insertGap", "org.hotswap.agent.javassist.bytecode", "Shifter", "static byte[] insertGap(byte[] info, int where, int gap)" ], [ "deleteGap", "org.hotswap.agent.javassist.bytecode", "SwitchShifter", "static byte[] deleteGap(byte[] info, int where, int gap)" ], [ "makeBlocks", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static TypedBlock[] makeBlocks(MethodInfo minfo, CodeAttribute ca, boolean optimize) throws BadBytecode" ], [ "getRetType", "org.hotswap.agent.javassist.bytecode.stackmap", "TypedBlock", "public static String getRetType(String desc)" ], [ "find", "org.hotswap.agent.javassist.bytecode.stackmap", "BasicBlock", "public static BasicBlock find(BasicBlock[] blocks, int pos) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData[] make(int size)" ], [ "commonSuperClassEx", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClassEx(CtClass one, CtClass two) throws NotFoundException" ], [ "commonSuperClass", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static CtClass commonSuperClass(CtClass one, CtClass two) throws NotFoundException" ], [ "eq", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static boolean eq(CtClass one, CtClass two)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "TypeData", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "static TypeData make(TypeData element) throws BadBytecode" ], [ "typeName", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayType", "public static String typeName(String elementType)" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "ArrayElement", "public static TypeData make(TypeData array) throws BadBytecode" ], [ "make", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMapTable make(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "make2", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "public static StackMap make2(ClassPool classes, MethodInfo minfo) throws BadBytecode" ], [ "recordTypeData", "org.hotswap.agent.javassist.bytecode.stackmap", "MapMaker", "protected static int recordTypeData(int n, TypeData[] srcTypes, TypeData[] destTypes)" ], [ "setPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPublic(int accflags)" ], [ "setProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setProtected(int accflags)" ], [ "setPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPrivate(int accflags)" ], [ "setPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int setPackage(int accflags)" ], [ "isPublic", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPublic(int accflags)" ], [ "isProtected", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isProtected(int accflags)" ], [ "isPrivate", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPrivate(int accflags)" ], [ "isPackage", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static boolean isPackage(int accflags)" ], [ "clear", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int clear(int accflags, int clearBit)" ], [ "of", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int of(int modifier)" ], [ "toModifier", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static int toModifier(int accflags)" ], [ "make", "org.hotswap.agent.javassist.bytecode.annotation", "AnnotationImpl", "public static Object make(ClassLoader cl, Class<?> clazz, ClassPool cp, Annotation anon) throws IllegalArgumentException" ], [ "loadClass", "org.hotswap.agent.javassist.bytecode.annotation", "MemberValue", "static Class<?> loadClass(ClassLoader cl, String classname) throws ClassNotFoundException, NoSuchClassError" ], [ "createMemberValue", "org.hotswap.agent.javassist.bytecode.annotation", "Annotation", "public static MemberValue createMemberValue(ConstPool cp, CtClass type) throws NotFoundException" ], [ "nextOpcode", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int nextOpcode(byte[] code, int index) throws BadBytecode" ], [ "insertGapCore0", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] insertGapCore0(byte[] code, int where, int gapLength, boolean exclusive, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "changeLdcToLdcW", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static byte[] changeLdcToLdcW(byte[] code, ExceptionTable etable, CodeAttribute ca, CodeAttribute.LdcEntry ldcs) throws BadBytecode" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "shiftOffset", "org.hotswap.agent.javassist.bytecode", "Branch", "static int shiftOffset(int i, int offset, int where, int gapLength, boolean exclusive)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, String oldname, String newname)" ], [ "renameClass", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static String renameClass(String desc, Map<String, String> map)" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "toClassSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassSignature toClassSignature(String sig) throws BadBytecode" ], [ "toMethodSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static MethodSignature toMethodSignature(String sig) throws BadBytecode" ], [ "toFieldSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ObjectType toFieldSignature(String sig) throws BadBytecode" ], [ "toTypeSignature", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static Type toTypeSignature(String sig) throws BadBytecode" ], [ "subclassOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument subclassOf(ObjectType t)" ], [ "superOf", "org.hotswap.agent.javassist.bytecode", "TypeArgument", "public static TypeArgument superOf(ObjectType t)" ], [ "make", "org.hotswap.agent.javassist.bytecode", "ClassType", "static ClassType make(String s, int b, int e, TypeArgument[] targs, ClassType parent)" ], [ "readU16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readU16bit(byte[] code, int index)" ], [ "readS16bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int readS16bit(byte[] code, int index)" ], [ "read32bit", "org.hotswap.agent.javassist.bytecode", "ByteArray", "public static int read32bit(byte[] code, int index)" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "doit", "org.hotswap.agent.javassist.bytecode", "LdcEntry", "static byte[] doit(byte[] code, LdcEntry ldc, ExceptionTable etable, CodeAttribute ca) throws BadBytecode" ], [ "calculateDefault", "org.hotswap.agent.javassist", "SerialVersionUID", "public static long calculateDefault(CtClass clazz) throws CannotCompileException" ], [ "fetchClass", "org.hotswap.agent.javassist", "URLClassPath", "public static byte[] fetchClass(String host, int port, String directory, String classname) throws IOException" ], [ "wrapped", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "public static CtConstructor wrapped(CtClass[] parameterTypes, CtClass[] exceptionTypes, int howToCallSuper, CtMethod body, ConstParameter constParam, CtClass declaring) throws CannotCompileException" ], [ "makeBody", "org.hotswap.agent.javassist", "CtNewWrappedConstructor", "protected static Bytecode makeBody(CtClass declaring, ClassFile classfile, int howToCallSuper, CtMethod wrappedBody, CtClass[] parameters, ConstParameter cparam) throws CannotCompileException" ], [ "getInstance", "org.hotswap.agent.javassist.scopedpool", "ScopedClassPoolRepositoryImpl", "public static ScopedClassPoolRepository getInstance()" ], [ "argTypesToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static String argTypesToString(int[] types, int[] dims, String[] cnames)" ], [ "typeToString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "protected static StringBuffer typeToString(StringBuffer sbuf, int type, int dim, String cname)" ], [ "stripPlusExpr", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static ASTree stripPlusExpr(ASTree expr)" ], [ "getConstantFieldValue", "org.hotswap.agent.javassist.compiler", "TypeChecker", "public static ASTree getConstantFieldValue(CtField f)" ], [ "isDotSuper", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static String isDotSuper(ASTree target)" ], [ "compileParameterList", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static int compileParameterList(Bytecode code, CtClass[] params, int regno)" ], [ "is2word", "org.hotswap.agent.javassist.compiler", "CodeGen", "public static boolean is2word(int type, int dim)" ], [ "toJvmArrayName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmArrayName(String name, int dim)" ], [ "toJvmTypeName", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static String toJvmTypeName(int type, int dim)" ], [ "lookupBinOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int lookupBinOp(int token)" ], [ "getCompOperator", "org.hotswap.agent.javassist.compiler", "CodeGen", "static int getCompOperator(ASTree expr) throws CompileError" ], [ "isRefType", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static boolean isRefType(int type)" ], [ "isP_INT", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean isP_INT(int type)" ], [ "rightIsStrong", "org.hotswap.agent.javassist.compiler", "CodeGen", "static boolean rightIsStrong(int type1, int type2)" ], [ "getArrayReadOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayReadOp(int type, int dim)" ], [ "getArrayWriteOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "protected static int getArrayWriteOp(int type, int dim)" ], [ "parseExpr", "org.hotswap.agent.javassist.compiler", "Javac", "public static ASTree parseExpr(String src, SymbolTable st) throws CompileError" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Stmnt", "public static Stmnt make(int op, ASTree op1, ASTree op2, ASTree op3)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList make(ASTree e1, ASTree e2, ASTree e3)" ], [ "length", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static int length(ASTList list)" ], [ "append", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList append(ASTList a, ASTree b)" ], [ "concat", "org.hotswap.agent.javassist.compiler.ast", "ASTList", "public static ASTList concat(ASTList a, ASTList b)" ], [ "astToClassName", "org.hotswap.agent.javassist.compiler.ast", "Declarator", "public static String astToClassName(ASTList name, char sep)" ], [ "makeCall", "org.hotswap.agent.javassist.compiler.ast", "CallExpr", "public static CallExpr makeCall(ASTree target, ASTree args)" ], [ "makeAssign", "org.hotswap.agent.javassist.compiler.ast", "AssignExpr", "public static AssignExpr makeAssign(int op, ASTree oprand1, ASTree oprand2)" ], [ "makeBin", "org.hotswap.agent.javassist.compiler.ast", "BinExpr", "public static BinExpr makeBin(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1, ASTree oprand2)" ], [ "make", "org.hotswap.agent.javassist.compiler.ast", "Expr", "public static Expr make(int op, ASTree oprand1)" ], [ "makeObjectArray", "org.hotswap.agent.javassist.compiler.ast", "NewExpr", "public static NewExpr makeObjectArray(ASTList className, ASTList arraySize, ArrayInit init)" ], [ "getTypeName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "static String getTypeName(int type) throws CompileError" ], [ "getInvalidMapSize", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getInvalidMapSize()" ], [ "getSuperclass", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperclass(CtClass c) throws CompileError" ], [ "getSuperInterface", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static CtClass getSuperInterface(CtClass c, String interfaceName) throws CompileError" ], [ "javaToJvmName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String javaToJvmName(String classname)" ], [ "jvmToJavaName", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static String jvmToJavaName(String classname)" ], [ "descToType", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int descToType(char c) throws CompileError" ], [ "getModifiers", "org.hotswap.agent.javassist.compiler", "MemberResolver", "public static int getModifiers(ASTList mods)" ], [ "isField", "org.hotswap.agent.javassist.convert", "TransformReadField", "static String isField(ClassPool pool, ConstPool cp, CtClass fclass, String fname, boolean is_private, int index)" ], [ "isFieldInSuper", "org.hotswap.agent.javassist.convert", "TransformReadField", "static boolean isFieldInSuper(CtClass clazz, CtClass fclass, String fname)" ], [ "getExternalPropertiesFile", "org.hotswap.agent", "HotswapAgent", "public static String getExternalPropertiesFile()" ], [ "isPluginDisabled", "org.hotswap.agent", "HotswapAgent", "public static boolean isPluginDisabled(String pluginName)" ], [ "isAutoHotswap", "org.hotswap.agent", "HotswapAgent", "public static boolean isAutoHotswap()" ], [ "toByteArray", "org.hotswap.agent.util", "IOUtils", "public static byte[] toByteArray(URI uri)" ], [ "streamToString", "org.hotswap.agent.util", "IOUtils", "public static String streamToString(InputStream is)" ], [ "isFileURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isFileURL(URL url)" ], [ "isDirectoryURL", "org.hotswap.agent.util", "IOUtils", "public static boolean isDirectoryURL(URL url)" ], [ "urlToClassName", "org.hotswap.agent.util", "IOUtils", "public static String urlToClassName(URI uri) throws IOException" ], [ "extractFileNameFromInputStream", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputStream(InputStream is)" ], [ "extractFileNameFromReader", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromReader(Reader reader)" ], [ "extractFileNameFromInputSource", "org.hotswap.agent.util", "IOUtils", "public static String extractFileNameFromInputSource(InputSource inputSource)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder)" ], [ "waitForResult", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForResult(WaitHelper.ResultHolder resultHolder, int timeout)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command)" ], [ "waitForCommand", "org.hotswap.agent.util.test", "WaitHelper", "public static boolean waitForCommand(Command command, int timeout)" ], [ "getCtClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getCtClassSignature(CtClass ctClass, ClassSignatureElement[] signatureElements) throws Exception" ], [ "getJavaClassSignature", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static String getJavaClassSignature(Class<?> clazz, ClassSignatureElement[] signatureElements) throws Exception" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(CtClass ctClass, Class<?> clazz, ClassSignatureElement[] signatureElements)" ], [ "isDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isDifferent(Class<?> clazz1, Class<?> clazz2, ClassSignatureElement[] signatureElements)" ], [ "isPoolClassDifferent", "org.hotswap.agent.util.signature", "ClassSignatureComparerHelper", "public static boolean isPoolClassDifferent(Class<?> clazz, ClassPool cp, ClassSignatureElement[] signatureElements)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, String annotationClass)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(Class<?> clazz, Iterable<String> annotationClasses)" ], [ "hasAnnotation", "org.hotswap.agent.util", "AnnotationHelper", "public static boolean hasAnnotation(CtClass clazz, Iterable<String> annotationClasses)" ], [ "isClassLoaded", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoaded(ClassLoader classLoader, String className)" ], [ "isClassLoderStarted", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static boolean isClassLoderStarted(ClassLoader classLoader)" ], [ "isApplicable", "org.hotswap.agent.util.classloader", "URLClassPathHelper", "public static boolean isApplicable(ClassLoader classLoader)" ], [ "callInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static <T> T callInitializePlugin(Class<T> pluginClass, ClassLoader appClassLoader)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass)" ], [ "buildInitializePlugin", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildInitializePlugin(Class pluginClass, String classLoaderVar)" ], [ "buildCallCloseClassLoader", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallCloseClassLoader(String classLoaderVar)" ], [ "callPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static Object callPluginMethod(Class pluginClass, ClassLoader appClassLoader, String method, Class[] paramTypes, Object[] params)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(Class pluginClass, String method, String... paramValueAndType)" ], [ "buildCallPluginMethod", "org.hotswap.agent.util", "PluginManagerInvoker", "public static String buildCallPluginMethod(String appClassLoaderVar, Class pluginClass, String method, String... paramValueAndType)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invokeNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invokeNoException(Object target, String className, ClassLoader cl, String methodName, Class<?>[] parameterTypes, Object... args)" ], [ "invoke", "org.hotswap.agent.util", "ReflectionHelper", "public static Object invoke(Object target, String methodName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, String fieldName)" ], [ "get", "org.hotswap.agent.util", "ReflectionHelper", "public static Object get(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, Class<?> clazz, String fieldName)" ], [ "getNoException", "org.hotswap.agent.util", "ReflectionHelper", "public static Object getNoException(Object target, String className, ClassLoader cl, String fieldName)" ], [ "toURI", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static URI toURI(String location) throws URISyntaxException" ], [ "version", "org.hotswap.agent.util", "Version", "public static String version()" ], [ "invokeVfsMethod", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T invokeVfsMethod(Method method, Object target, Object... args) throws IOException" ], [ "exists", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean exists(Object vfsResource)" ], [ "isReadable", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static boolean isReadable(Object vfsResource)" ], [ "getSize", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getSize(Object vfsResource) throws IOException" ], [ "getLastModified", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static long getLastModified(Object vfsResource) throws IOException" ], [ "getInputStream", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static InputStream getInputStream(Object vfsResource) throws IOException" ], [ "getURL", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URL getURL(Object vfsResource) throws IOException" ], [ "getURI", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static URI getURI(Object vfsResource) throws IOException" ], [ "getName", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static String getName(Object vfsResource)" ], [ "getRelative", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRelative(URL url) throws IOException" ], [ "getChild", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getChild(Object vfsResource, String path) throws IOException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static File getFile(Object vfsResource) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URI url) throws IOException" ], [ "getRoot", "org.hotswap.agent.util.spring.util", "VfsUtils", "public static <T> T getRoot(URL url) throws IOException" ], [ "doGetVisitorAttribute", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static <T> T doGetVisitorAttribute()" ], [ "doGetPath", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static String doGetPath(Object resource)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean isEmpty(Object str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(CharSequence str)" ], [ "hasLength", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasLength(String str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(CharSequence str)" ], [ "hasText", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean hasText(String str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(CharSequence str)" ], [ "containsWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean containsWhitespace(String str)" ], [ "trimWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimWhitespace(String str)" ], [ "trimAllWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimAllWhitespace(String str)" ], [ "trimLeadingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingWhitespace(String str)" ], [ "trimTrailingWhitespace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingWhitespace(String str)" ], [ "trimLeadingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimLeadingCharacter(String str, char leadingCharacter)" ], [ "trimTrailingCharacter", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String trimTrailingCharacter(String str, char trailingCharacter)" ], [ "startsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean startsWithIgnoreCase(String str, String prefix)" ], [ "endsWithIgnoreCase", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean endsWithIgnoreCase(String str, String suffix)" ], [ "substringMatch", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean substringMatch(CharSequence str, int index, CharSequence substring)" ], [ "countOccurrencesOf", "org.hotswap.agent.util.spring.util", "StringUtils", "public static int countOccurrencesOf(String str, String sub)" ], [ "replace", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String replace(String inString, String oldPattern, String newPattern)" ], [ "delete", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String delete(String inString, String pattern)" ], [ "deleteAny", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String deleteAny(String inString, String charsToDelete)" ], [ "quote", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String quote(String str)" ], [ "quoteIfString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Object quoteIfString(Object obj)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName)" ], [ "unqualify", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String unqualify(String qualifiedName, char separator)" ], [ "capitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String capitalize(String str)" ], [ "uncapitalize", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String uncapitalize(String str)" ], [ "getFilename", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilename(String path)" ], [ "getFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String getFilenameExtension(String path)" ], [ "stripFilenameExtension", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String stripFilenameExtension(String path)" ], [ "applyRelativePath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String applyRelativePath(String path, String relativePath)" ], [ "cleanPath", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String cleanPath(String path)" ], [ "pathEquals", "org.hotswap.agent.util.spring.util", "StringUtils", "public static boolean pathEquals(String path1, String path2)" ], [ "parseLocaleString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Locale parseLocaleString(String localeString)" ], [ "toLanguageTag", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String toLanguageTag(Locale locale)" ], [ "parseTimeZoneString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static TimeZone parseTimeZoneString(String timeZoneString)" ], [ "addStringToArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] addStringToArray(String[] array, String str)" ], [ "concatenateStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] concatenateStringArrays(String[] array1, String[] array2)" ], [ "mergeStringArrays", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] mergeStringArrays(String[] array1, String[] array2)" ], [ "sortStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] sortStringArray(String[] array)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Collection<String> collection)" ], [ "toStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] toStringArray(Enumeration<String> enumeration)" ], [ "trimArrayElements", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] trimArrayElements(String[] array)" ], [ "removeDuplicateStrings", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] removeDuplicateStrings(String[] array)" ], [ "split", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] split(String toSplit, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter)" ], [ "splitArrayElementsIntoProperties", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters)" ], [ "tokenizeToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] tokenizeToStringArray(String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter)" ], [ "delimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete)" ], [ "commaDelimitedListToStringArray", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String[] commaDelimitedListToStringArray(String str)" ], [ "commaDelimitedListToSet", "org.hotswap.agent.util.spring.util", "StringUtils", "public static Set<String> commaDelimitedListToSet(String str)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix)" ], [ "collectionToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToDelimitedString(Collection<?> coll, String delim)" ], [ "collectionToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String collectionToCommaDelimitedString(Collection<?> coll)" ], [ "arrayToDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToDelimitedString(Object[] arr, String delim)" ], [ "arrayToCommaDelimitedString", "org.hotswap.agent.util.spring.util", "StringUtils", "public static String arrayToCommaDelimitedString(Object[] arr)" ], [ "getDefaultClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader getDefaultClassLoader()" ], [ "overrideThreadContextClassLoader", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse)" ], [ "forName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError" ], [ "resolveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException" ], [ "resolvePrimitiveClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveClassName(String name)" ], [ "isPresent", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPresent(String className, ClassLoader classLoader)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Object instance)" ], [ "getUserClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> getUserClass(Class<?> clazz)" ], [ "isCacheSafe", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(String className)" ], [ "getShortName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortName(Class<?> clazz)" ], [ "getShortNameAsProperty", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getShortNameAsProperty(Class<?> clazz)" ], [ "getClassFileName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getClassFileName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(Class<?> clazz)" ], [ "getPackageName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getPackageName(String fqClassName)" ], [ "getQualifiedName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedName(Class<?> clazz)" ], [ "getQualifiedMethodName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getQualifiedMethodName(Method method)" ], [ "getDescriptiveType", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String getDescriptiveType(Object value)" ], [ "matchesTypeName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean matchesTypeName(Class<?> clazz, String typeName)" ], [ "hasConstructor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes)" ], [ "getConstructorIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes)" ], [ "hasMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodIfAvailable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes)" ], [ "getMethodCountForName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static int getMethodCountForName(Class<?> clazz, String methodName)" ], [ "hasAtLeastOneMethodWithName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName)" ], [ "getMostSpecificMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getMostSpecificMethod(Method method, Class<?> targetClass)" ], [ "isUserLevelMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isUserLevelMethod(Method method)" ], [ "getStaticMethod", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args)" ], [ "isPrimitiveWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapper(Class<?> clazz)" ], [ "isPrimitiveOrWrapper", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveOrWrapper(Class<?> clazz)" ], [ "isPrimitiveArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveArray(Class<?> clazz)" ], [ "isPrimitiveWrapperArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isPrimitiveWrapperArray(Class<?> clazz)" ], [ "resolvePrimitiveIfNecessary", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz)" ], [ "isAssignable", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType)" ], [ "isAssignableValue", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isAssignableValue(Class<?> type, Object value)" ], [ "convertResourcePathToClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertResourcePathToClassName(String resourcePath)" ], [ "convertClassNameToResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String convertClassNameToResourcePath(String className)" ], [ "addResourcePathToPackagePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName)" ], [ "classPackageAsResourcePath", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classPackageAsResourcePath(Class<?> clazz)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Class<?>... classes)" ], [ "classNamesToString", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static String classNamesToString(Collection<Class<?>> classes)" ], [ "toClassArray", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] toClassArray(Collection<Class<?>> collection)" ], [ "getAllInterfaces", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfaces(Object instance)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz)" ], [ "getAllInterfacesForClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader)" ], [ "getAllInterfacesAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesAsSet(Object instance)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz)" ], [ "getAllInterfacesForClassAsSet", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader)" ], [ "createCompositeInterface", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader)" ], [ "determineCommonAncestor", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2)" ], [ "isVisible", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isVisible(Class<?> clazz, ClassLoader classLoader)" ], [ "isCglibProxy", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxy(Object object)" ], [ "isCglibProxyClass", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClass(Class<?> clazz)" ], [ "isCglibProxyClassName", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static boolean isCglibProxyClassName(String className)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Collection<?> collection)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean isEmpty(Map<?, ?> map)" ], [ "arrayToList", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static List arrayToList(Object source)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Iterator<?> iterator, Object element)" ], [ "contains", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean contains(Enumeration<?> enumeration, Object element)" ], [ "containsInstance", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsInstance(Collection<?> collection, Object element)" ], [ "containsAny", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean containsAny(Collection<?> source, Collection<?> candidates)" ], [ "findFirstMatch", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <T> T findValueOfType(Collection<?> collection, Class<T> type)" ], [ "findValueOfType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Object findValueOfType(Collection<?> collection, Class<?>[] types)" ], [ "hasUniqueObject", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static boolean hasUniqueObject(Collection<?> collection)" ], [ "findCommonElementType", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static Class<?> findCommonElementType(Collection<?> collection)" ], [ "toArray", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array)" ], [ "toIterator", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <E> Iterator<E> toIterator(Enumeration<E> enumeration)" ], [ "toMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map)" ], [ "unmodifiableMultiValueMap", "org.hotswap.agent.util.spring.util", "CollectionUtils", "public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map)" ], [ "regexMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean regexMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String pattern, String str)" ], [ "simpleMatch", "org.hotswap.agent.util.spring.util", "PatternMatchUtils", "public static boolean simpleMatch(String[] patterns, String str)" ], [ "isUrl", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isUrl(String resourceLocation)" ], [ "getURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL getURL(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(String resourceLocation) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URL resourceUrl, String description) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri) throws FileNotFoundException" ], [ "getFile", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static File getFile(URI resourceUri, String description) throws FileNotFoundException" ], [ "isFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isFileURL(URL url)" ], [ "isJarURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarURL(URL url)" ], [ "isJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static boolean isJarFileURL(URL url)" ], [ "extractJarFileURL", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(URL url) throws URISyntaxException" ], [ "toURI", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static URI toURI(String location) throws URISyntaxException" ], [ "isCheckedException", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCheckedException(Throwable ex)" ], [ "isCompatibleWithThrowsClause", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions)" ], [ "isArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isArray(Object obj)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object[] array)" ], [ "isEmpty", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean isEmpty(Object obj)" ], [ "containsElement", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsElement(Object[] array, Object element)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant)" ], [ "containsConstant", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive)" ], [ "caseInsensitiveValueOf", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant)" ], [ "addObjectToArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static <A, O extends A> A[] addObjectToArray(A[] array, O obj)" ], [ "toObjectArray", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static Object[] toObjectArray(Object source)" ], [ "nullSafeEquals", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static boolean nullSafeEquals(Object o1, Object o2)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object obj)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(Object[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(boolean[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(byte[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(char[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(double[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(float[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(int[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(long[] array)" ], [ "nullSafeHashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int nullSafeHashCode(short[] array)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(boolean bool)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(double dbl)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(float flt)" ], [ "hashCode", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static int hashCode(long lng)" ], [ "identityToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String identityToString(Object obj)" ], [ "getIdentityHexString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getIdentityHexString(Object obj)" ], [ "getDisplayString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String getDisplayString(Object obj)" ], [ "nullSafeClassName", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeClassName(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object obj)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(Object[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(boolean[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(byte[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(char[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(double[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(float[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(int[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(long[] array)" ], [ "nullSafeToString", "org.hotswap.agent.util.spring.util", "ObjectUtils", "public static String nullSafeToString(short[] array)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name)" ], [ "findField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Field findField(Class<?> clazz, String name, Class<?> type)" ], [ "getField", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T getField(Field field, Object target)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name)" ], [ "findMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target)" ], [ "invokeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeMethod(Method method, Object target, Object... args)" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target) throws SQLException" ], [ "invokeJdbcMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static <T> T invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException" ], [ "declaresException", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean declaresException(Method method, Class<?> exceptionType)" ], [ "isPublicStaticFinal", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isPublicStaticFinal(Field field)" ], [ "isEqualsMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isEqualsMethod(Method method)" ], [ "isHashCodeMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isHashCodeMethod(Method method)" ], [ "isToStringMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isToStringMethod(Method method)" ], [ "isObjectMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isObjectMethod(Method method)" ], [ "isCglibRenamedMethod", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static boolean isCglibRenamedMethod(Method renamedMethod)" ], [ "getAllDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getAllDeclaredMethods(Class<?> leafClass)" ], [ "getUniqueDeclaredMethods", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static Method[] getUniqueDeclaredMethods(Class<?> leafClass)" ], [ "getVisitorAttribute", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object getVisitorAttribute()" ], [ "getPath", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static String getPath(Object resource)" ], [ "findRoot", "org.hotswap.agent.util.spring.path", "VfsPatternUtils", "static Object findRoot(URL url) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "PathMatchingResourcePatternResolver", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "findMatchingResources", "org.hotswap.agent.util.spring.path", "VfsResourceMatchingDelegate", "public static Set<Resource> findMatchingResources(Resource rootResource, String locationPattern, PathMatcher pathMatcher) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "AbstractFileResolvingResource", "public static Resource getResource(URI uri) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URL url) throws IOException" ], [ "getResource", "org.hotswap.agent.util.spring.io.resource", "VfsResourceDelegate", "public static Resource getResource(URI uri) throws IOException" ], [ "buildMessage", "org.hotswap.agent.util.spring.io.resource", "NestedExceptionUtils", "public static String buildMessage(String message, Throwable cause)" ], [ "calculateShift", "org.hotswap.agent.util.spring.collections", "ConcurrentReferenceHashMap", "protected static int calculateShift(int minimumValue, int maximumValue)" ], [ "getInstance", "org.hotswap.agent.config", "PluginManager", "public static PluginManager getInstance()" ], [ "patchAnonymousClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static CtClass patchAnonymousClass(ClassLoader classLoader, ClassPool classPool, String className, Class original) throws IOException, NotFoundException, CannotCompileException" ], [ "patchMainClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "public static byte[] patchMainClass(String className, ClassPool classPool, CtClass ctClass, ClassLoader classLoader, ProtectionDomain protectionDomain) throws IOException, CannotCompileException, NotFoundException" ], [ "newClass", "org.hotswap.agent.plugin.hotswapper", "HotSwapper", "public static Class newClass(String className, String directory, ClassLoader cl)" ], [ "fromClassLoader", "org.hotswap.agent.versions", "DeploymentInfo", "public static DeploymentInfo fromClassLoader(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static Set<ManifestInfo> getManifest(ClassLoader classloader)" ], [ "getManifest", "org.hotswap.agent.versions", "DeploymentInfo", "public static ManifestInfo getManifest(Resource resource)" ], [ "any", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange any()" ], [ "createFromVersionSpec", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersionSpec(String spec) throws InvalidVersionSpecificationException" ], [ "createFromVersion", "org.hotswap.agent.versions", "VersionRange", "public static VersionRange createFromVersion(String version)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "ComparableVersion", "public static String comparableQualifier(String qualifier)" ], [ "comparableQualifier", "org.hotswap.agent.versions", "StringItem", "public static String comparableQualifier(String qualifier)" ], [ "dump", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static String dump(Attributes attr)" ], [ "createCmdForEvent", "org.hotswap.agent.annotation.handler", "WatchEventCommand", "public static <T extends Annotation> WatchEventCommand<T> createCmdForEvent(PluginAnnotation<T> pluginAnnotation, WatchFileEvent event, ClassLoader classLoader)" ], [ "isSyntheticClass", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static boolean isSyntheticClass(String className)" ], [ "parse", "org.hotswap.agent.annotation.handler", "WatchEventDTO", "public static <T extends Annotation> WatchEventDTO parse(T annotation)" ], [ "getVersion", "org.hotswap.agent.watch", "WatcherFactory", "static double getVersion()" ], [ "isWindows", "org.hotswap.agent.watch", "WatcherFactory", "static boolean isWindows()" ], [ "toAgentEvent", "org.hotswap.agent.watch.nio", "HotswapWatchFileEvent", "static FileEvent toAgentEvent(WatchEvent.Kind<?> kind)" ], [ "cast", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static <T> WatchEvent<T> cast(WatchEvent<?> event)" ], [ "getWatchEventModifier", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "static WatchEvent.Modifier getWatchEventModifier(String claz, String field)" ], [ "getLogger", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLogger getLogger(Class clazz)" ], [ "getHandler", "org.hotswap.agent.logging", "AgentLogger", "public static AgentLoggerHandler getHandler()" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "javaLangString", "org.hotswap.agent.javassist", "CtField", "static final String javaLangString = \"java.lang.String\";" ], [ "classobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectField = \"_classobject\";" ], [ "classobjectAccessor", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classobjectAccessor = \"_getClass\";" ], [ "metaobjectField", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectField = \"_metaobject\";" ], [ "metaobjectGetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectGetter = \"_getMetaobject\";" ], [ "metaobjectSetter", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectSetter = \"_setMetaobject\";" ], [ "readPrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String readPrefix = \"_r_\";" ], [ "writePrefix", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String writePrefix = \"_w_\";" ], [ "metaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String metaobjectClassName = \"org.hotswap.agent.javassist.tools.reflect.Metaobject\";" ], [ "classMetaobjectClassName", "org.hotswap.agent.javassist.tools.reflect", "Reflection", "static final String classMetaobjectClassName = \"org.hotswap.agenta.javassist.tools.reflect.ClassMetaobject\";" ], [ "methodPrefix", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final String methodPrefix = \"_m_\";" ], [ "methodPrefixLen", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "static final int methodPrefixLen = 3;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.tools.reflect", "ClassMetaobject", "public static boolean useContextClassLoader = false;" ], [ "callbacks", "org.hotswap.agent.javassist.tools", "Callback", "public static Map<String,Callback> callbacks = new HashMap<String, Callback>();" ], [ "PUBLIC", "org.hotswap.agent.javassist", "Modifier", "public static final int PUBLIC = AccessFlag.PUBLIC;" ], [ "PRIVATE", "org.hotswap.agent.javassist", "Modifier", "public static final int PRIVATE = AccessFlag.PRIVATE;" ], [ "PROTECTED", "org.hotswap.agent.javassist", "Modifier", "public static final int PROTECTED = AccessFlag.PROTECTED;" ], [ "STATIC", "org.hotswap.agent.javassist", "Modifier", "public static final int STATIC = AccessFlag.STATIC;" ], [ "FINAL", "org.hotswap.agent.javassist", "Modifier", "public static final int FINAL = AccessFlag.FINAL;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist", "Modifier", "public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;" ], [ "VOLATILE", "org.hotswap.agent.javassist", "Modifier", "public static final int VOLATILE = AccessFlag.VOLATILE;" ], [ "VARARGS", "org.hotswap.agent.javassist", "Modifier", "public static final int VARARGS = AccessFlag.VARARGS;" ], [ "TRANSIENT", "org.hotswap.agent.javassist", "Modifier", "public static final int TRANSIENT = AccessFlag.TRANSIENT;" ], [ "NATIVE", "org.hotswap.agent.javassist", "Modifier", "public static final int NATIVE = AccessFlag.NATIVE;" ], [ "INTERFACE", "org.hotswap.agent.javassist", "Modifier", "public static final int INTERFACE = AccessFlag.INTERFACE;" ], [ "ABSTRACT", "org.hotswap.agent.javassist", "Modifier", "public static final int ABSTRACT = AccessFlag.ABSTRACT;" ], [ "STRICT", "org.hotswap.agent.javassist", "Modifier", "public static final int STRICT = AccessFlag.STRICT;" ], [ "ANNOTATION", "org.hotswap.agent.javassist", "Modifier", "public static final int ANNOTATION = AccessFlag.ANNOTATION;" ], [ "ENUM", "org.hotswap.agent.javassist", "Modifier", "public static final int ENUM = AccessFlag.ENUM;" ], [ "onlyPublicMethods", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static boolean onlyPublicMethods = false;" ], [ "useCache", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useCache = true;" ], [ "useWriteReplace", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static volatile boolean useWriteReplace = true;" ], [ "classLoaderProvider", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static ClassLoaderProvider classLoaderProvider = new ClassLoaderProvider() {\n\n    @Override\n    public ClassLoader get(ProxyFactory pf) {\n        return pf.getClassLoader0();\n    }\n};" ], [ "nameGenerator", "org.hotswap.agent.javassist.util.proxy", "ProxyFactory", "public static UniqueName nameGenerator = new UniqueName() {\n\n    private final String sep = \"_$$_jvst\" + Integer.toHexString(this.hashCode() & 0xfff) + \"_\";\n\n    private int counter = 0;\n\n    @Override\n    public String get(String classname) {\n        return classname + sep + Integer.toHexString(counter++);\n    }\n};" ], [ "primitiveTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final Class<?>[] primitiveTypes = { Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, Void.TYPE };" ], [ "wrapperTypes", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperTypes = { \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Void\" };" ], [ "wrapperDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] wrapperDesc = { \"(Z)V\", \"(B)V\", \"(C)V\", \"(S)V\", \"(I)V\", \"(J)V\", \"(F)V\", \"(D)V\" };" ], [ "unwarpMethods", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwarpMethods = { \"booleanValue\", \"byteValue\", \"charValue\", \"shortValue\", \"intValue\", \"longValue\", \"floatValue\", \"doubleValue\" };" ], [ "unwrapDesc", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final String[] unwrapDesc = { \"()Z\", \"()B\", \"()C\", \"()S\", \"()I\", \"()J\", \"()F\", \"()D\" };" ], [ "dataSize", "org.hotswap.agent.javassist.util.proxy", "FactoryHelper", "public static final int[] dataSize = { 1, 1, 1, 1, 1, 2, 1, 2 };" ], [ "default_interceptor", "org.hotswap.agent.javassist.util.proxy", "RuntimeSupport", "public static MethodHandler default_interceptor = new DefaultMethodHandler();" ], [ "stack", "org.hotswap.agent.javassist.util.proxy", "SecurityActions", "public static final SecurityActions stack = new SecurityActions();" ], [ "PASS_NONE", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_NONE = 0;" ], [ "PASS_ARRAY", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_ARRAY = 1;" ], [ "PASS_PARAMS", "org.hotswap.agent.javassist", "CtNewConstructor", "public static final int PASS_PARAMS = 2;" ], [ "useContextClassLoader", "org.hotswap.agent.javassist.runtime", "Desc", "public static boolean useContextClassLoader = false;" ], [ "javaLangObject", "org.hotswap.agent.javassist.expr", "Expr", "static final String javaLangObject = \"java.lang.Object\";" ], [ "doPruning", "org.hotswap.agent.javassist", "ClassPool", "public static boolean doPruning = false;" ], [ "releaseUnmodifiedClassFile", "org.hotswap.agent.javassist", "ClassPool", "public static boolean releaseUnmodifiedClassFile = true;" ], [ "debugDump", "org.hotswap.agent.javassist", "CtClass", "public static String debugDump = null;" ], [ "version", "org.hotswap.agent.javassist", "CtClass", "public static final String version = \"3.24.0-GA\";" ], [ "javaLangObject", "org.hotswap.agent.javassist", "CtClass", "static final String javaLangObject = \"java.lang.Object\";" ], [ "booleanType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass booleanType;" ], [ "charType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass charType;" ], [ "byteType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass byteType;" ], [ "shortType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass shortType;" ], [ "intType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass intType;" ], [ "longType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass longType;" ], [ "floatType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass floatType;" ], [ "doubleType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass doubleType;" ], [ "voidType", "org.hotswap.agent.javassist", "CtClass", "public static CtClass voidType;" ], [ "primitiveTypes", "org.hotswap.agent.javassist", "CtClass", "static CtClass[] primitiveTypes;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String tag = \"LocalVariableTable\";" ], [ "typeTag", "org.hotswap.agent.javassist.bytecode", "LocalVariableAttribute", "public static final String typeTag = \"LocalVariableTypeTable\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleTypeAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "TypeAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleTypeAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final String tag = \"StackMap\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMap", "public static final int UNINIT = 8;" ], [ "doPreverify", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static boolean doPreverify = false;" ], [ "nameInit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameInit = \"<init>\";" ], [ "nameClinit", "org.hotswap.agent.javassist.bytecode", "MethodInfo", "public static final String nameClinit = \"<clinit>\";" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type DOUBLE = new Type(CtClass.doubleType);" ], [ "BOOLEAN", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOOLEAN = new Type(CtClass.booleanType);" ], [ "LONG", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type LONG = new Type(CtClass.longType);" ], [ "CHAR", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CHAR = new Type(CtClass.charType);" ], [ "BYTE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BYTE = new Type(CtClass.byteType);" ], [ "SHORT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SHORT = new Type(CtClass.shortType);" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type INTEGER = new Type(CtClass.intType);" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type FLOAT = new Type(CtClass.floatType);" ], [ "VOID", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type VOID = new Type(CtClass.voidType);" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type UNINIT = new Type(null);" ], [ "RETURN_ADDRESS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type RETURN_ADDRESS = new Type(null, true);" ], [ "TOP", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type TOP = new Type(null, true);" ], [ "BOGUS", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type BOGUS = new Type(null, true);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type OBJECT = lookupType(\"java.lang.Object\");" ], [ "SERIALIZABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type SERIALIZABLE = lookupType(\"java.io.Serializable\");" ], [ "CLONEABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type CLONEABLE = lookupType(\"java.lang.Cloneable\");" ], [ "THROWABLE", "org.hotswap.agent.javassist.bytecode.analysis", "Type", "public static final Type THROWABLE = lookupType(\"java.lang.Throwable\");" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "EnclosingMethodAttribute", "public static final String tag = \"EnclosingMethod\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestMembersAttribute", "public static final String tag = \"NestMembers\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SyntheticAttribute", "public static final String tag = \"Synthetic\";" ], [ "JAVA_1", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_1 = 45;" ], [ "JAVA_2", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_2 = 46;" ], [ "JAVA_3", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_3 = 47;" ], [ "JAVA_4", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_4 = 48;" ], [ "JAVA_5", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_5 = 49;" ], [ "JAVA_6", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_6 = 50;" ], [ "JAVA_7", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_7 = 51;" ], [ "JAVA_8", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_8 = 52;" ], [ "JAVA_9", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_9 = 53;" ], [ "JAVA_10", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_10 = 54;" ], [ "JAVA_11", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_11 = 55;" ], [ "JAVA_12", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_12 = 56;" ], [ "JAVA_13", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_13 = 57;" ], [ "JAVA_14", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_14 = 58;" ], [ "JAVA_15", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_15 = 59;" ], [ "JAVA_16", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_16 = 60;" ], [ "JAVA_17", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static final int JAVA_17 = 61;" ], [ "MAJOR_VERSION", "org.hotswap.agent.javassist.bytecode", "ClassFile", "public static int MAJOR_VERSION;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final String tag = \"StackMapTable\";" ], [ "TOP", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int TOP = 0;" ], [ "INTEGER", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int INTEGER = 1;" ], [ "FLOAT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int FLOAT = 2;" ], [ "DOUBLE", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int DOUBLE = 3;" ], [ "LONG", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int LONG = 4;" ], [ "NULL", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int NULL = 5;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int THIS = 6;" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int OBJECT = 7;" ], [ "UNINIT", "org.hotswap.agent.javassist.bytecode", "StackMapTable", "public static final int UNINIT = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "BootstrapMethodsAttribute", "public static final String tag = \"BootstrapMethods\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DeprecatedAttribute", "public static final String tag = \"Deprecated\";" ], [ "PUBLIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PUBLIC = 0x0001;" ], [ "PRIVATE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PRIVATE = 0x0002;" ], [ "PROTECTED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int PROTECTED = 0x0004;" ], [ "STATIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STATIC = 0x0008;" ], [ "FINAL", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int FINAL = 0x0010;" ], [ "SYNCHRONIZED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNCHRONIZED = 0x0020;" ], [ "VOLATILE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VOLATILE = 0x0040;" ], [ "BRIDGE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int BRIDGE = 0x0040;" ], [ "TRANSIENT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int TRANSIENT = 0x0080;" ], [ "VARARGS", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int VARARGS = 0x0080;" ], [ "NATIVE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int NATIVE = 0x0100;" ], [ "INTERFACE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int INTERFACE = 0x0200;" ], [ "ABSTRACT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ABSTRACT = 0x0400;" ], [ "STRICT", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int STRICT = 0x0800;" ], [ "SYNTHETIC", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SYNTHETIC = 0x1000;" ], [ "ANNOTATION", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ANNOTATION = 0x2000;" ], [ "ENUM", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int ENUM = 0x4000;" ], [ "MANDATED", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MANDATED = 0x8000;" ], [ "SUPER", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int SUPER = 0x0020;" ], [ "MODULE", "org.hotswap.agent.javassist.bytecode", "AccessFlag", "public static final int MODULE = 0x8000;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "AnnotationDefaultAttribute", "public static final String tag = \"AnnotationDefault\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InnerClassesAttribute", "public static final String tag = \"InnerClasses\";" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "AnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ConstantAttribute", "public static final String tag = \"ConstantValue\";" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "CodeIterator", "static final int BIT32 = 2;" ], [ "BIT16", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT16 = 0;" ], [ "EXPAND", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int EXPAND = 1;" ], [ "BIT32", "org.hotswap.agent.javassist.bytecode", "Branch16", "static final int BIT32 = 2;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LineNumberAttribute", "public static final String tag = \"LineNumberTable\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static final String tag = \"Signature\";" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "SignatureAttribute", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "OBJECT", "org.hotswap.agent.javassist.bytecode", "ClassType", "public static ClassType OBJECT = new ClassType(\"java.lang.Object\", null);" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodParametersAttribute", "public static final String tag = \"MethodParameters\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "SourceFileAttribute", "public static final String tag = \"SourceFile\";" ], [ "ASIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ASIZE = 128;" ], [ "ABITS", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int ABITS = 7;" ], [ "VSIZE", "org.hotswap.agent.javassist.bytecode", "LongVector", "static final int VSIZE = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NestHostAttribute", "public static final String tag = \"NestHost\";" ], [ "CONST_Class", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Class = ClassInfo.tag;" ], [ "CONST_Fieldref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Fieldref = FieldrefInfo.tag;" ], [ "CONST_Methodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Methodref = MethodrefInfo.tag;" ], [ "CONST_InterfaceMethodref", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InterfaceMethodref = InterfaceMethodrefInfo.tag;" ], [ "CONST_String", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_String = StringInfo.tag;" ], [ "CONST_Integer", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Integer = IntegerInfo.tag;" ], [ "CONST_Float", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Float = FloatInfo.tag;" ], [ "CONST_Long", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Long = LongInfo.tag;" ], [ "CONST_Double", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Double = DoubleInfo.tag;" ], [ "CONST_NameAndType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_NameAndType = NameAndTypeInfo.tag;" ], [ "CONST_Utf8", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Utf8 = Utf8Info.tag;" ], [ "CONST_MethodHandle", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodHandle = MethodHandleInfo.tag;" ], [ "CONST_MethodType", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_MethodType = MethodTypeInfo.tag;" ], [ "CONST_InvokeDynamic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_InvokeDynamic = InvokeDynamicInfo.tag;" ], [ "CONST_Module", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Module = ModuleInfo.tag;" ], [ "CONST_Package", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int CONST_Package = PackageInfo.tag;" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final CtClass THIS = null;" ], [ "REF_getField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getField = 1;" ], [ "REF_getStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_getStatic = 2;" ], [ "REF_putField", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putField = 3;" ], [ "REF_putStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_putStatic = 4;" ], [ "REF_invokeVirtual", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeVirtual = 5;" ], [ "REF_invokeStatic", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeStatic = 6;" ], [ "REF_invokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeSpecial = 7;" ], [ "REF_newInvokeSpecial", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_newInvokeSpecial = 8;" ], [ "REF_invokeInterface", "org.hotswap.agent.javassist.bytecode", "ConstPool", "public static final int REF_invokeInterface = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ClassInfo", "static final int tag = 7;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "NameAndTypeInfo", "static final int tag = 12;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FieldrefInfo", "static final int tag = 9;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodrefInfo", "static final int tag = 10;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InterfaceMethodrefInfo", "static final int tag = 11;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "StringInfo", "static final int tag = 8;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "IntegerInfo", "static final int tag = 3;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "FloatInfo", "static final int tag = 4;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LongInfo", "static final int tag = 5;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "DoubleInfo", "static final int tag = 6;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "Utf8Info", "static final int tag = 1;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodHandleInfo", "static final int tag = 15;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "MethodTypeInfo", "static final int tag = 16;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "InvokeDynamicInfo", "static final int tag = 18;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ModuleInfo", "static final int tag = 19;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "PackageInfo", "static final int tag = 20;" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "CodeAttribute", "public static final String tag = \"Code\";" ], [ "THIS", "org.hotswap.agent.javassist.bytecode", "Bytecode", "public static final CtClass THIS = ConstPool.THIS;" ], [ "visibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String visibleTag = \"RuntimeVisibleParameterAnnotations\";" ], [ "invisibleTag", "org.hotswap.agent.javassist.bytecode", "ParameterAnnotationsAttribute", "public static final String invisibleTag = \"RuntimeInvisibleParameterAnnotations\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "ExceptionsAttribute", "public static final String tag = \"Exceptions\";" ], [ "tag", "org.hotswap.agent.javassist.bytecode", "LocalVariableTypeAttribute", "public static final String tag = LocalVariableAttribute.typeTag;" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "jvmJavaLangClass", "org.hotswap.agent.javassist.compiler", "TypeChecker", "static final String jvmJavaLangClass = \"java/lang/Class\";" ], [ "sigName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String sigName = \"$sig\";" ], [ "dollarTypeName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String dollarTypeName = \"$type\";" ], [ "clazzName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String clazzName = \"$class\";" ], [ "wrapperCastName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String wrapperCastName = \"$w\";" ], [ "cflowName", "org.hotswap.agent.javassist.compiler", "JvstCodeGen", "public static final String cflowName = \"$cflow\";" ], [ "javaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangObject = \"java.lang.Object\";" ], [ "jvmJavaLangObject", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangObject = \"java/lang/Object\";" ], [ "javaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String javaLangString = \"java.lang.String\";" ], [ "jvmJavaLangString", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final String jvmJavaLangString = \"java/lang/String\";" ], [ "binOp", "org.hotswap.agent.javassist.compiler", "CodeGen", "static final int[] binOp = { '+', DADD, FADD, LADD, IADD, '-', DSUB, FSUB, LSUB, ISUB, '*', DMUL, FMUL, LMUL, IMUL, '/', DDIV, FDIV, LDIV, IDIV, '%', DREM, FREM, LREM, IREM, '|', NOP, NOP, LOR, IOR, '^', NOP, NOP, LXOR, IXOR, '&', NOP, NOP, LAND, IAND, LSHIFT, NOP, NOP, LSHL, ISHL, RSHIFT, NOP, NOP, LSHR, ISHR, ARSHIFT, NOP, NOP, LUSHR, IUSHR };" ], [ "param0Name", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String param0Name = \"$0\";" ], [ "resultVarName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String resultVarName = \"$_\";" ], [ "proceedName", "org.hotswap.agent.javassist.compiler", "Javac", "public static final String proceedName = \"$proceed\";" ], [ "initName", "org.hotswap.agent.javassist.compiler.ast", "MethodDecl", "public static final String initName = \"<init>\";" ], [ "lastParamType", "org.hotswap.agent.javassist.compiler", "AccessorMaker", "static final String lastParamType = \"org.hotswap.agent.javassist.runtime.Inner\";" ], [ "HOTSWAP_AGENT_EXPORT_PACKAGES", "org.hotswap.agent", "HotswapAgent", "public static final String HOTSWAP_AGENT_EXPORT_PACKAGES = //\n\"org.hotswap.agent.annotation,\" + //\n\"org.hotswap.agent.command,\" + //\n\"org.hotswap.agent.config,\" + \"org.hotswap.agent.logging,\" + //\n\"org.hotswap.agent.plugin,\" + //\n\"org.hotswap.agent.util,\" + //\n\"org.hotswap.agent.watch,\" + //\n\"org.hotswap.agent.versions,\" + \"org.hotswap.agent.javassist\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util", "IOUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassSignature", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "CtClassComparator", "public static final CtClassComparator INSTANCE = new CtClassComparator();" ], [ "SWITCH_TABLE_METHOD_PREFIX", "org.hotswap.agent.util.signature", "ClassSignatureBase", "protected static final String SWITCH_TABLE_METHOD_PREFIX = \"$SWITCH_TABLE$\";" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ClassSignatureBase", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "INSTANCE", "org.hotswap.agent.util.signature", "ToStringComparator", "public static final ToStringComparator INSTANCE = new ToStringComparator();" ], [ "findLoadedClass", "org.hotswap.agent.util.classloader", "ClassLoaderHelper", "public static Method findLoadedClass;" ], [ "PLUGIN_PATH", "org.hotswap.agent.util.scanner", "PluginCache", "public static final String PLUGIN_PATH = \"org/hotswap/agent/plugin\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "ZIP_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String ZIP_URL_PREFIX = \"zip:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.scanner", "ClassPathScanner", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "VIRTUAL_FILE_VISITOR_INTERFACE", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Class<?> VIRTUAL_FILE_VISITOR_INTERFACE;" ], [ "VIRTUAL_FILE_METHOD_VISIT", "org.hotswap.agent.util.spring.util", "VfsUtils", "protected static Method VIRTUAL_FILE_METHOD_VISIT;" ], [ "ARRAY_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String ARRAY_SUFFIX = \"[]\";" ], [ "CGLIB_CLASS_SEPARATOR", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CGLIB_CLASS_SEPARATOR = \"$$\";" ], [ "CLASS_FILE_SUFFIX", "org.hotswap.agent.util.spring.util", "ClassUtils", "public static final String CLASS_FILE_SUFFIX = \".class\";" ], [ "CLASSPATH_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String CLASSPATH_URL_PREFIX = \"classpath:\";" ], [ "FILE_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String FILE_URL_PREFIX = \"file:\";" ], [ "JAR_URL_PREFIX", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_PREFIX = \"jar:\";" ], [ "URL_PROTOCOL_FILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_FILE = \"file\";" ], [ "URL_PROTOCOL_JAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_JAR = \"jar\";" ], [ "URL_PROTOCOL_ZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_ZIP = \"zip\";" ], [ "URL_PROTOCOL_WSJAR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_WSJAR = \"wsjar\";" ], [ "URL_PROTOCOL_VFSZIP", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSZIP = \"vfszip\";" ], [ "URL_PROTOCOL_VFSFILE", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFSFILE = \"vfsfile\";" ], [ "URL_PROTOCOL_VFS", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String URL_PROTOCOL_VFS = \"vfs\";" ], [ "JAR_FILE_EXTENSION", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_FILE_EXTENSION = \".jar\";" ], [ "JAR_URL_SEPARATOR", "org.hotswap.agent.util.spring.util", "ResourceUtils", "public static final String JAR_URL_SEPARATOR = \"!/\";" ], [ "COPYABLE_FIELDS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static FieldFilter COPYABLE_FIELDS = new FieldFilter() {\n\n    @Override\n    public boolean matches(Field field) {\n        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));\n    }\n};" ], [ "NON_BRIDGED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter NON_BRIDGED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return !method.isBridge();\n    }\n};" ], [ "USER_DECLARED_METHODS", "org.hotswap.agent.util.spring.util", "ReflectionUtils", "public static MethodFilter USER_DECLARED_METHODS = new MethodFilter() {\n\n    @Override\n    public boolean matches(Method method) {\n        return (!method.isBridge() && method.getDeclaringClass() != Object.class);\n    }\n};" ], [ "DEFAULT_PATH_SEPARATOR", "org.hotswap.agent.util.spring.path", "AntPathMatcher", "public static final String DEFAULT_PATH_SEPARATOR = \"/\";" ], [ "PLUGIN_PACKAGE", "org.hotswap.agent.config", "PluginManager", "public static final String PLUGIN_PACKAGE = \"org.hotswap.agent.plugin\";" ], [ "LOGGER_PREFIX", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String LOGGER_PREFIX = \"LOGGER\";" ], [ "DATETIME_FORMAT", "org.hotswap.agent.config", "LogConfigurationHelper", "public static final String DATETIME_FORMAT = \"LOGGER_DATETIME_FORMAT\";" ], [ "reloadFlag", "org.hotswap.agent.plugin.jdk", "JdkPlugin", "public static boolean reloadFlag;" ], [ "UNIQUE_CLASS_START_INDEX", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "public static final int UNIQUE_CLASS_START_INDEX = 10000;" ], [ "uniqueClass", "org.hotswap.agent.plugin.jvm", "AnonymousClassInfos", "static int uniqueClass = UNIQUE_CLASS_START_INDEX;" ], [ "hotswapTransformer", "org.hotswap.agent.plugin.jvm", "AnonymousClassPatchPlugin", "static HotswapTransformer hotswapTransformer;" ], [ "reloadFlag", "org.hotswap.agent.plugin.jvm", "ClassInitPlugin", "public static boolean reloadFlag;" ], [ "EVERYTHING", "org.hotswap.agent.versions", "Restriction", "public static final Restriction EVERYTHING = new Restriction(null, false, null, false);" ], [ "NONE", "org.hotswap.agent.versions", "Restriction", "public static final Restriction NONE = new Restriction(new ArtifactVersion(\"0\"), true, new ArtifactVersion(String.valueOf(Integer.MAX_VALUE)), true);" ], [ "ZERO", "org.hotswap.agent.versions", "ComparableVersion", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "ZERO", "org.hotswap.agent.versions", "IntegerItem", "public static final IntegerItem ZERO = new IntegerItem();" ], [ "EXTENSION_LIST", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_LIST = new Name(\"Extension-List\");" ], [ "EXTENSION_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name EXTENSION_NAME = new Name(\"Extension-Name\");" ], [ "IMPLEMENTATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_TITLE = new Name(\"Implementation-Title\");" ], [ "IMPLEMENTATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VERSION = new Name(\"Implementation-Version\");" ], [ "IMPLEMENTATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR = new Name(\"Implementation-Vendor\");" ], [ "IMPLEMENTATION_VENDOR_ID", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name IMPLEMENTATION_VENDOR_ID = new Name(\"Implementation-Vendor-Id\");" ], [ "SPECIFICATION_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VERSION = new Name(\"Specification-Version\");" ], [ "SPECIFICATION_VENDOR", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_VENDOR = new Name(\"Specification-Vendor\");" ], [ "SPECIFICATION_TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name SPECIFICATION_TITLE = new Name(\"Specification-Title\");" ], [ "BUNDLE_SYMBOLIC_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_SYMBOLIC_NAME = new Name(\"Bundle-SymbolicName\");" ], [ "BUNDLE_NAME", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_NAME = new Name(\"Bundle-Name\");" ], [ "BUNDLE_VERSION", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name BUNDLE_VERSION = new Name(\"Bundle-Version\");" ], [ "VERSIONS", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] VERSIONS = new Name[] { BUNDLE_VERSION, IMPLEMENTATION_VERSION, SPECIFICATION_VENDOR };" ], [ "PACKAGE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] PACKAGE = new Name[] { BUNDLE_SYMBOLIC_NAME, IMPLEMENTATION_VENDOR_ID, SPECIFICATION_VENDOR };" ], [ "TITLE", "org.hotswap.agent.versions", "ManifestMiniDumper", "public static final Name[] TITLE = new Name[] { BUNDLE_NAME, IMPLEMENTATION_TITLE, SPECIFICATION_VENDOR };" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "OnClassLoadedHandler", "protected static AgentLogger LOGGER = AgentLogger.getLogger(OnClassLoadedHandler.class);" ], [ "LOGGER", "org.hotswap.agent.annotation.handler", "PluginClassFileTransformer", "protected static AgentLogger LOGGER = AgentLogger.getLogger(PluginClassFileTransformer.class);" ], [ "BundleVersion", "org.hotswap.agent.annotation", "Name", "static String BundleVersion = \"Bundle-Version\";" ], [ "BundleSymbolicName", "org.hotswap.agent.annotation", "Name", "static String BundleSymbolicName = \"Bundle-SymbolicName\";" ], [ "BundleName", "org.hotswap.agent.annotation", "Name", "static String BundleName = \"Bundle-Name\";" ], [ "ImplementationVersion", "org.hotswap.agent.annotation", "Name", "static String ImplementationVersion = \"Implementation-Version\";" ], [ "ImplementationTitle", "org.hotswap.agent.annotation", "Name", "static String ImplementationTitle = \"Implementation-Title\";" ], [ "ImplementationVendor", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendor = \"Implementation-Vendor\";" ], [ "ImplementationVendorId", "org.hotswap.agent.annotation", "Name", "static String ImplementationVendorId = \"Implementation-Vendor-Id\";" ], [ "ImplementationURL", "org.hotswap.agent.annotation", "Name", "static String ImplementationURL = \"Implementation-URL\";" ], [ "ImplementationUrl", "org.hotswap.agent.annotation", "Name", "static String ImplementationUrl = \"Implementation-Url\";" ], [ "SpecificationVersion", "org.hotswap.agent.annotation", "Name", "static String SpecificationVersion = \"Specification-Version\";" ], [ "SpecificationTitle", "org.hotswap.agent.annotation", "Name", "static String SpecificationTitle = \"Specification-Title\";" ], [ "SpecificationVendor", "org.hotswap.agent.annotation", "Name", "static String SpecificationVendor = \"Specification-Vendor\";" ], [ "JAVA_VERSION", "org.hotswap.agent.watch", "WatcherFactory", "public static double JAVA_VERSION = getVersion();" ], [ "IS_WINDOWS", "org.hotswap.agent.watch", "WatcherFactory", "public static boolean IS_WINDOWS = isWindows();" ], [ "KINDS", "org.hotswap.agent.watch.nio", "AbstractNIO2Watcher", "protected final static WatchEvent.Kind<?>[] KINDS = new WatchEvent.Kind<?>[] { ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY };" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "3.2", "double" ], [ "6", "int" ] ],
  "tokensMethodArguments" : [ [ "clazz1", "java.lang.Class", "Class<?>" ], [ "clazz2", "java.lang.Class", "Class<?>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "isRecord", "java.lang", "Class", "public boolean isRecord()" ], [ "getSigners", "java.lang", "Class", "public native Object[] getSigners()" ], [ "getTypeName", "java.lang", "Class", "public String getTypeName()" ], [ "getConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getConstructors() throws SecurityException" ], [ "getDeclaredMethods", "java.lang", "Class", "public Method[] getDeclaredMethods() throws SecurityException" ], [ "getComponentType", "java.lang", "Class", "public Class<? extends Object> getComponentType()" ], [ "getSimpleName", "java.lang", "Class", "public String getSimpleName()" ], [ "toString", "java.lang", "Class", "public String toString()" ], [ "getDeclaredConstructors", "java.lang", "Class", "public Constructor<? extends Object>[] getDeclaredConstructors() throws SecurityException" ], [ "getField", "java.lang", "Class", "public Field getField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getDeclaredFields", "java.lang", "Class", "public Field[] getDeclaredFields() throws SecurityException" ], [ "getAnnotationsByType", "java.lang", "Class", "public <A> A[] getAnnotationsByType(Class<A> arg0)" ], [ "getAnnotatedInterfaces", "java.lang", "Class", "public AnnotatedType[] getAnnotatedInterfaces()" ], [ "getClassLoader", "java.lang", "Class", "public ClassLoader getClassLoader()" ], [ "getClassLoader0", "java.lang", "Class", "ClassLoader getClassLoader0()" ], [ "isInstance", "java.lang", "Class", "public native boolean isInstance(Object arg0)" ], [ "getAnnotatedSuperclass", "java.lang", "Class", "public AnnotatedType getAnnotatedSuperclass()" ], [ "getCanonicalName", "java.lang", "Class", "public String getCanonicalName()" ], [ "getNestMembers", "java.lang", "Class", "public Class<? extends Object>[] getNestMembers()" ], [ "getEnclosingMethod", "java.lang", "Class", "public Method getEnclosingMethod() throws SecurityException" ], [ "isAssignableFrom", "java.lang", "Class", "public native boolean isAssignableFrom(Class<? extends Object> arg0)" ], [ "describeConstable", "java.lang", "Class", "public Optional<ClassDesc> describeConstable()" ], [ "desiredAssertionStatus", "java.lang", "Class", "public boolean desiredAssertionStatus()" ], [ "getDeclaredAnnotations", "java.lang", "Class", "public Annotation[] getDeclaredAnnotations()" ], [ "getRawAnnotations", "java.lang", "Class", "native byte[] getRawAnnotations()" ], [ "getEnumConstants", "java.lang", "Class", "public T[] getEnumConstants()" ], [ "getResource", "java.lang", "Class", "public URL getResource(String arg0)" ], [ "getRecordComponents", "java.lang", "Class", "public RecordComponent[] getRecordComponents()" ], [ "getDeclaredClasses", "java.lang", "Class", "public Class<? extends Object>[] getDeclaredClasses() throws SecurityException" ], [ "getPermittedSubclasses", "java.lang", "Class", "public Class<? extends Object>[] getPermittedSubclasses()" ], [ "isMemberClass", "java.lang", "Class", "public boolean isMemberClass()" ], [ "newInstance", "java.lang", "Class", "public T newInstance() throws InstantiationException, IllegalAccessException" ], [ "componentType", "java.lang", "Class", "public Class<? extends Object> componentType()" ], [ "getEnclosingClass", "java.lang", "Class", "public Class<? extends Object> getEnclosingClass() throws SecurityException" ], [ "protectionDomain", "java.lang", "Class", "ProtectionDomain protectionDomain()" ], [ "isAnonymousClass", "java.lang", "Class", "public boolean isAnonymousClass()" ], [ "getRawTypeAnnotations", "java.lang", "Class", "native byte[] getRawTypeAnnotations()" ], [ "getConstantPool", "java.lang", "Class", "native ConstantPool getConstantPool()" ], [ "descriptorString", "java.lang", "Class", "public String descriptorString()" ], [ "getGenericInterfaces", "java.lang", "Class", "public Type[] getGenericInterfaces()" ], [ "isAnnotation", "java.lang", "Class", "public boolean isAnnotation()" ], [ "arrayType", "java.lang", "Class", "public Class<? extends Object> arrayType()" ], [ "getResourceAsStream", "java.lang", "Class", "public InputStream getResourceAsStream(String arg0)" ], [ "getDeclaredConstructor", "java.lang", "Class", "public Constructor<T> getDeclaredConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "isSynthetic", "java.lang", "Class", "public boolean isSynthetic()" ], [ "getConstructor", "java.lang", "Class", "public Constructor<T> getConstructor(Class<? extends Object>[] arg0) throws NoSuchMethodException, SecurityException" ], [ "getDeclaredAnnotation", "java.lang", "Class", "public <A> A getDeclaredAnnotation(Class<A> arg0)" ], [ "getInterfaces", "java.lang", "Class", "public Class<? extends Object>[] getInterfaces()" ], [ "getDeclaredField", "java.lang", "Class", "public Field getDeclaredField(String arg0) throws NoSuchFieldException, SecurityException" ], [ "getModifiers", "java.lang", "Class", "public native int getModifiers()" ], [ "isNestmateOf", "java.lang", "Class", "public boolean isNestmateOf(Class<? extends Object> arg0)" ], [ "getPackage", "java.lang", "Class", "public Package getPackage()" ], [ "getDeclaringClass", "java.lang", "Class", "public Class<? extends Object> getDeclaringClass() throws SecurityException" ], [ "getClassData", "java.lang", "Class", "Object getClassData()" ], [ "getModule", "java.lang", "Class", "public Module getModule()" ], [ "getAnnotations", "java.lang", "Class", "public Annotation[] getAnnotations()" ], [ "enumConstantDirectory", "java.lang", "Class", "Map<String, T> enumConstantDirectory()" ], [ "isPrimitive", "java.lang", "Class", "public native boolean isPrimitive()" ], [ "getEnumConstantsShared", "java.lang", "Class", "T[] getEnumConstantsShared()" ], [ "getProtectionDomain", "java.lang", "Class", "public ProtectionDomain getProtectionDomain()" ], [ "getClasses", "java.lang", "Class", "public Class<? extends Object>[] getClasses()" ], [ "getAnnotation", "java.lang", "Class", "public <A> A getAnnotation(Class<A> arg0)" ], [ "getMethods", "java.lang", "Class", "public Method[] getMethods() throws SecurityException" ], [ "isLocalClass", "java.lang", "Class", "public boolean isLocalClass()" ], [ "isInterface", "java.lang", "Class", "public native boolean isInterface()" ], [ "getNestHost", "java.lang", "Class", "public Class<? extends Object> getNestHost()" ], [ "isArray", "java.lang", "Class", "public native boolean isArray()" ], [ "isSealed", "java.lang", "Class", "public boolean isSealed()" ], [ "getTypeParameters", "java.lang", "Class", "public TypeVariable<Class<T>>[] getTypeParameters()" ], [ "getDeclaredAnnotationMap", "java.lang", "Class", "Map<Class<? extends Annotation>, Annotation> getDeclaredAnnotationMap()" ], [ "getDeclaredPublicMethods", "java.lang", "Class", "List<Method> getDeclaredPublicMethods(String arg0, Class<? extends Object>[] arg1)" ], [ "getName", "java.lang", "Class", "public String getName()" ], [ "getEnclosingConstructor", "java.lang", "Class", "public Constructor<? extends Object> getEnclosingConstructor() throws SecurityException" ], [ "getDeclaredMethod", "java.lang", "Class", "public Method getDeclaredMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "getSuperclass", "java.lang", "Class", "public native Class<? super T> getSuperclass()" ], [ "getMethod", "java.lang", "Class", "public Method getMethod(String arg0, Class<? extends Object>[] arg1) throws NoSuchMethodException, SecurityException" ], [ "isEnum", "java.lang", "Class", "public boolean isEnum()" ], [ "cast", "java.lang", "Class", "public T cast(Object arg0)" ], [ "casAnnotationType", "java.lang", "Class", "boolean casAnnotationType(AnnotationType arg0, AnnotationType arg1)" ], [ "getGenericSuperclass", "java.lang", "Class", "public Type getGenericSuperclass()" ], [ "isAnnotationPresent", "java.lang", "Class", "public boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getDeclaredAnnotationsByType", "java.lang", "Class", "public <A> A[] getDeclaredAnnotationsByType(Class<A> arg0)" ], [ "toGenericString", "java.lang", "Class", "public String toGenericString()" ], [ "asSubclass", "java.lang", "Class", "public <U> Class<? extends U> asSubclass(Class<U> arg0)" ], [ "getAnnotationType", "java.lang", "Class", "AnnotationType getAnnotationType()" ], [ "isHidden", "java.lang", "Class", "public native boolean isHidden()" ], [ "getFields", "java.lang", "Class", "public Field[] getFields() throws SecurityException" ], [ "getPackageName", "java.lang", "Class", "public String getPackageName()" ], [ "getTypeParameters", "java.lang.reflect", "GenericDeclaration", "public abstract TypeVariable<? extends Object>[] getTypeParameters()" ], [ "getDeclaredAnnotation", "java.lang.reflect", "AnnotatedElement", "public default <T> T getDeclaredAnnotation(Class<T> arg0)" ], [ "getDeclaredAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getDeclaredAnnotations()" ], [ "getAnnotation", "java.lang.reflect", "AnnotatedElement", "public abstract <T> T getAnnotation(Class<T> arg0)" ], [ "isAnnotationPresent", "java.lang.reflect", "AnnotatedElement", "public default boolean isAnnotationPresent(Class<? extends Annotation> arg0)" ], [ "getDeclaredAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getDeclaredAnnotationsByType(Class<T> arg0)" ], [ "getAnnotationsByType", "java.lang.reflect", "AnnotatedElement", "public default <T> T[] getAnnotationsByType(Class<T> arg0)" ], [ "getAnnotations", "java.lang.reflect", "AnnotatedElement", "public abstract Annotation[] getAnnotations()" ], [ "getTypeName", "java.lang.reflect", "Type", "public default String getTypeName()" ], [ "isPrimitive", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isPrimitive()" ], [ "componentType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F componentType()" ], [ "arrayType", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract F arrayType()" ], [ "isArray", "java.lang.invoke", "TypeDescriptor.OfField", "public abstract boolean isArray()" ], [ "descriptorString", "java.lang.invoke", "TypeDescriptor", "public abstract String descriptorString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "classValueMap", "java.lang", "Class", "transient ClassValue.ClassValueMap classValueMap;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]