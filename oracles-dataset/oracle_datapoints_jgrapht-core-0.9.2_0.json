[ {
  "id" : 25721,
  "oracle" : "graph==null || startVertex==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "KShortestPaths",
  "javadocTag" : "@throws NullPointerException if the specified graph or startVertex is\n<code>null</code>.",
  "methodJavadoc" : "    /**\n     * Creates an object to calculate ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param nPaths number of ranking paths between the start vertex and an end\n     * vertex.\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     *\n     * @throws NullPointerException if the specified graph or startVertex is\n     * <code>null</code>.\n     * @throws IllegalArgumentException if nPaths is negative or 0.\n     * @throws IllegalArgumentException if nMaxHops is negative or 0.\n     */",
  "methodSourceCode" : "public KShortestPaths(Graph<V, E> graph, V startVertex, int nPaths, int nMaxHops){\n    assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n    this.graph = graph;\n    this.startVertex = startVertex;\n    this.nPaths = nPaths;\n    this.nMaxHops = nMaxHops;\n}",
  "classJavadoc" : "/**\n * The algorithm determines the k shortest simple paths in increasing order of\n * weight. Weights can be negative (but no negative cycle is allowed), and paths\n * can be constrained by a maximum number of edges. Multigraphs are allowed.\n *\n * <p>The algorithm is a variant of the Bellman-Ford algorithm but instead of\n * only storing the best path it stores the \"k\" best paths at each pass,\n * yielding a complexity of O(k*n*(m^2)) where m is the number of edges and n is\n * the number of vertices.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * KShortestPaths.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * The algorithm determines the k shortest simple paths in increasing order of\n * weight. Weights can be negative (but no negative cycle is allowed), and paths\n * can be constrained by a maximum number of edges. Multigraphs are allowed.\n *\n * <p>The algorithm is a variant of the Bellman-Ford algorithm but instead of\n * only storing the best path it stores the \"k\" best paths at each pass,\n * yielding a complexity of O(k*n*(m^2)) where m is the number of edges and n is\n * the number of vertices.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\npublic class KShortestPaths<V, E>\n{\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    private Graph<V, E> graph;\n\n    private int nMaxHops;\n\n    private int nPaths;\n\n    private V startVertex;\n\n    /**\n     * Creates an object to compute ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph\n     * @param startVertex\n     * @param k number of paths to be computed.\n     */\n    public KShortestPaths(Graph<V, E> graph, V startVertex, int k)\n    {\n        this(graph, startVertex, k, graph.vertexSet().size() - 1);\n    }\n\n    /**\n     * Creates an object to calculate ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param nPaths number of ranking paths between the start vertex and an end\n     * vertex.\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     *\n     * @throws NullPointerException if the specified graph or startVertex is\n     * <code>null</code>.\n     * @throws IllegalArgumentException if nPaths is negative or 0.\n     * @throws IllegalArgumentException if nMaxHops is negative or 0.\n     */\n    public KShortestPaths(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.nPaths = nPaths;\n        this.nMaxHops = nMaxHops;\n    }\n\n    /**\n     * Returns the k shortest simple paths in increasing order of weight.\n     *\n     * @param endVertex target vertex of the calculated paths.\n     *\n     * @return list of paths, or <code>null</code> if no path exists between the\n     * start vertex and the end vertex.\n     */\n    public List<GraphPath<V, E>> getPaths(V endVertex)\n    {\n        assertGetPaths(endVertex);\n\n        KShortestPathsIterator<V, E> iter =\n            new KShortestPathsIterator<V, E>(\n                this.graph,\n                this.startVertex,\n                endVertex,\n                this.nPaths);\n\n        // at the i-th pass the shortest paths with less (or equal) than i edges\n        // are calculated.\n        for (\n            int passNumber = 1;\n            (passNumber <= this.nMaxHops)\n            && iter.hasNext();\n            passNumber++)\n        {\n            iter.next();\n        }\n\n        List<RankingPathElement<V, E>> list = iter.getPathElements(endVertex);\n\n        if (list == null) {\n            return null;\n        }\n\n        List<GraphPath<V, E>> pathList = new ArrayList<GraphPath<V, E>>();\n\n        for (RankingPathElement<V, E> element : list) {\n            pathList.add(new PathWrapper(element));\n        }\n\n        return pathList;\n    }\n\n    private void assertGetPaths(V endVertex)\n    {\n        if (endVertex == null) {\n            throw new NullPointerException(\"endVertex is null\");\n        }\n        if (endVertex.equals(this.startVertex)) {\n            throw new IllegalArgumentException(\n                \"The end vertex is the same as the start vertex!\");\n        }\n        if (!this.graph.vertexSet().contains(endVertex)) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the end vertex!\");\n        }\n    }\n\n    private void assertKShortestPathsFinder(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        if (graph == null) {\n            throw new NullPointerException(\"graph is null\");\n        }\n        if (startVertex == null) {\n            throw new NullPointerException(\"startVertex is null\");\n        }\n        if (nPaths <= 0) {\n            throw new NullPointerException(\"nPaths is negative or 0\");\n        }\n        if (nMaxHops <= 0) {\n            throw new NullPointerException(\"nMaxHops is negative or 0\");\n        }\n    }\n\n    private class PathWrapper\n        implements GraphPath<V, E>\n    {\n        private RankingPathElement<V, E> rankingPathElement;\n\n        private List<E> edgeList;\n\n        PathWrapper(RankingPathElement<V, E> rankingPathElement)\n        {\n            this.rankingPathElement = rankingPathElement;\n        }\n\n        // implement GraphPath\n        @Override public Graph<V, E> getGraph()\n        {\n            return graph;\n        }\n\n        // implement GraphPath\n        @Override public V getStartVertex()\n        {\n            return startVertex;\n        }\n\n        // implement GraphPath\n        @Override public V getEndVertex()\n        {\n            return rankingPathElement.getVertex();\n        }\n\n        // implement GraphPath\n        @Override public List<E> getEdgeList()\n        {\n            if (edgeList == null) {\n                edgeList = rankingPathElement.createEdgeListPath();\n            }\n            return edgeList;\n        }\n\n        // implement GraphPath\n        @Override public double getWeight()\n        {\n            return rankingPathElement.getWeight();\n        }\n\n        // override Object\n        @Override public String toString()\n        {\n            return getEdgeList().toString();\n        }\n    }\n}\n\n// End KShortestPaths.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "startVertex", "", "V" ], [ "nPaths", "", "int" ], [ "nMaxHops", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getPaths", "org.jgrapht.alg", "KShortestPaths", "public List<GraphPath<V, E>> getPaths(V endVertex)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25722,
  "oracle" : "nPaths<0 || nPaths==0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "KShortestPaths",
  "javadocTag" : "@throws IllegalArgumentException if nMaxHops is negative or 0.",
  "methodJavadoc" : "    /**\n     * Creates an object to calculate ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param nPaths number of ranking paths between the start vertex and an end\n     * vertex.\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     *\n     * @throws NullPointerException if the specified graph or startVertex is\n     * <code>null</code>.\n     * @throws IllegalArgumentException if nPaths is negative or 0.\n     * @throws IllegalArgumentException if nMaxHops is negative or 0.\n     */",
  "methodSourceCode" : "public KShortestPaths(Graph<V, E> graph, V startVertex, int nPaths, int nMaxHops){\n    assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n    this.graph = graph;\n    this.startVertex = startVertex;\n    this.nPaths = nPaths;\n    this.nMaxHops = nMaxHops;\n}",
  "classJavadoc" : "/**\n * The algorithm determines the k shortest simple paths in increasing order of\n * weight. Weights can be negative (but no negative cycle is allowed), and paths\n * can be constrained by a maximum number of edges. Multigraphs are allowed.\n *\n * <p>The algorithm is a variant of the Bellman-Ford algorithm but instead of\n * only storing the best path it stores the \"k\" best paths at each pass,\n * yielding a complexity of O(k*n*(m^2)) where m is the number of edges and n is\n * the number of vertices.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * KShortestPaths.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * The algorithm determines the k shortest simple paths in increasing order of\n * weight. Weights can be negative (but no negative cycle is allowed), and paths\n * can be constrained by a maximum number of edges. Multigraphs are allowed.\n *\n * <p>The algorithm is a variant of the Bellman-Ford algorithm but instead of\n * only storing the best path it stores the \"k\" best paths at each pass,\n * yielding a complexity of O(k*n*(m^2)) where m is the number of edges and n is\n * the number of vertices.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\npublic class KShortestPaths<V, E>\n{\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    private Graph<V, E> graph;\n\n    private int nMaxHops;\n\n    private int nPaths;\n\n    private V startVertex;\n\n    /**\n     * Creates an object to compute ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph\n     * @param startVertex\n     * @param k number of paths to be computed.\n     */\n    public KShortestPaths(Graph<V, E> graph, V startVertex, int k)\n    {\n        this(graph, startVertex, k, graph.vertexSet().size() - 1);\n    }\n\n    /**\n     * Creates an object to calculate ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param nPaths number of ranking paths between the start vertex and an end\n     * vertex.\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     *\n     * @throws NullPointerException if the specified graph or startVertex is\n     * <code>null</code>.\n     * @throws IllegalArgumentException if nPaths is negative or 0.\n     * @throws IllegalArgumentException if nMaxHops is negative or 0.\n     */\n    public KShortestPaths(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.nPaths = nPaths;\n        this.nMaxHops = nMaxHops;\n    }\n\n    /**\n     * Returns the k shortest simple paths in increasing order of weight.\n     *\n     * @param endVertex target vertex of the calculated paths.\n     *\n     * @return list of paths, or <code>null</code> if no path exists between the\n     * start vertex and the end vertex.\n     */\n    public List<GraphPath<V, E>> getPaths(V endVertex)\n    {\n        assertGetPaths(endVertex);\n\n        KShortestPathsIterator<V, E> iter =\n            new KShortestPathsIterator<V, E>(\n                this.graph,\n                this.startVertex,\n                endVertex,\n                this.nPaths);\n\n        // at the i-th pass the shortest paths with less (or equal) than i edges\n        // are calculated.\n        for (\n            int passNumber = 1;\n            (passNumber <= this.nMaxHops)\n            && iter.hasNext();\n            passNumber++)\n        {\n            iter.next();\n        }\n\n        List<RankingPathElement<V, E>> list = iter.getPathElements(endVertex);\n\n        if (list == null) {\n            return null;\n        }\n\n        List<GraphPath<V, E>> pathList = new ArrayList<GraphPath<V, E>>();\n\n        for (RankingPathElement<V, E> element : list) {\n            pathList.add(new PathWrapper(element));\n        }\n\n        return pathList;\n    }\n\n    private void assertGetPaths(V endVertex)\n    {\n        if (endVertex == null) {\n            throw new NullPointerException(\"endVertex is null\");\n        }\n        if (endVertex.equals(this.startVertex)) {\n            throw new IllegalArgumentException(\n                \"The end vertex is the same as the start vertex!\");\n        }\n        if (!this.graph.vertexSet().contains(endVertex)) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the end vertex!\");\n        }\n    }\n\n    private void assertKShortestPathsFinder(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        if (graph == null) {\n            throw new NullPointerException(\"graph is null\");\n        }\n        if (startVertex == null) {\n            throw new NullPointerException(\"startVertex is null\");\n        }\n        if (nPaths <= 0) {\n            throw new NullPointerException(\"nPaths is negative or 0\");\n        }\n        if (nMaxHops <= 0) {\n            throw new NullPointerException(\"nMaxHops is negative or 0\");\n        }\n    }\n\n    private class PathWrapper\n        implements GraphPath<V, E>\n    {\n        private RankingPathElement<V, E> rankingPathElement;\n\n        private List<E> edgeList;\n\n        PathWrapper(RankingPathElement<V, E> rankingPathElement)\n        {\n            this.rankingPathElement = rankingPathElement;\n        }\n\n        // implement GraphPath\n        @Override public Graph<V, E> getGraph()\n        {\n            return graph;\n        }\n\n        // implement GraphPath\n        @Override public V getStartVertex()\n        {\n            return startVertex;\n        }\n\n        // implement GraphPath\n        @Override public V getEndVertex()\n        {\n            return rankingPathElement.getVertex();\n        }\n\n        // implement GraphPath\n        @Override public List<E> getEdgeList()\n        {\n            if (edgeList == null) {\n                edgeList = rankingPathElement.createEdgeListPath();\n            }\n            return edgeList;\n        }\n\n        // implement GraphPath\n        @Override public double getWeight()\n        {\n            return rankingPathElement.getWeight();\n        }\n\n        // override Object\n        @Override public String toString()\n        {\n            return getEdgeList().toString();\n        }\n    }\n}\n\n// End KShortestPaths.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "startVertex", "", "V" ], [ "nPaths", "", "int" ], [ "nMaxHops", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getPaths", "org.jgrapht.alg", "KShortestPaths", "public List<GraphPath<V, E>> getPaths(V endVertex)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25723,
  "oracle" : "nMaxHops<0 || nMaxHops==0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "KShortestPaths",
  "javadocTag" : "@throws IllegalArgumentException if nPaths is negative or 0.",
  "methodJavadoc" : "    /**\n     * Creates an object to calculate ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param nPaths number of ranking paths between the start vertex and an end\n     * vertex.\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     *\n     * @throws NullPointerException if the specified graph or startVertex is\n     * <code>null</code>.\n     * @throws IllegalArgumentException if nPaths is negative or 0.\n     * @throws IllegalArgumentException if nMaxHops is negative or 0.\n     */",
  "methodSourceCode" : "public KShortestPaths(Graph<V, E> graph, V startVertex, int nPaths, int nMaxHops){\n    assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n    this.graph = graph;\n    this.startVertex = startVertex;\n    this.nPaths = nPaths;\n    this.nMaxHops = nMaxHops;\n}",
  "classJavadoc" : "/**\n * The algorithm determines the k shortest simple paths in increasing order of\n * weight. Weights can be negative (but no negative cycle is allowed), and paths\n * can be constrained by a maximum number of edges. Multigraphs are allowed.\n *\n * <p>The algorithm is a variant of the Bellman-Ford algorithm but instead of\n * only storing the best path it stores the \"k\" best paths at each pass,\n * yielding a complexity of O(k*n*(m^2)) where m is the number of edges and n is\n * the number of vertices.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * KShortestPaths.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * The algorithm determines the k shortest simple paths in increasing order of\n * weight. Weights can be negative (but no negative cycle is allowed), and paths\n * can be constrained by a maximum number of edges. Multigraphs are allowed.\n *\n * <p>The algorithm is a variant of the Bellman-Ford algorithm but instead of\n * only storing the best path it stores the \"k\" best paths at each pass,\n * yielding a complexity of O(k*n*(m^2)) where m is the number of edges and n is\n * the number of vertices.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\npublic class KShortestPaths<V, E>\n{\n    /**\n     * Graph on which shortest paths are searched.\n     */\n    private Graph<V, E> graph;\n\n    private int nMaxHops;\n\n    private int nPaths;\n\n    private V startVertex;\n\n    /**\n     * Creates an object to compute ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph\n     * @param startVertex\n     * @param k number of paths to be computed.\n     */\n    public KShortestPaths(Graph<V, E> graph, V startVertex, int k)\n    {\n        this(graph, startVertex, k, graph.vertexSet().size() - 1);\n    }\n\n    /**\n     * Creates an object to calculate ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param nPaths number of ranking paths between the start vertex and an end\n     * vertex.\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     *\n     * @throws NullPointerException if the specified graph or startVertex is\n     * <code>null</code>.\n     * @throws IllegalArgumentException if nPaths is negative or 0.\n     * @throws IllegalArgumentException if nMaxHops is negative or 0.\n     */\n    public KShortestPaths(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.nPaths = nPaths;\n        this.nMaxHops = nMaxHops;\n    }\n\n    /**\n     * Returns the k shortest simple paths in increasing order of weight.\n     *\n     * @param endVertex target vertex of the calculated paths.\n     *\n     * @return list of paths, or <code>null</code> if no path exists between the\n     * start vertex and the end vertex.\n     */\n    public List<GraphPath<V, E>> getPaths(V endVertex)\n    {\n        assertGetPaths(endVertex);\n\n        KShortestPathsIterator<V, E> iter =\n            new KShortestPathsIterator<V, E>(\n                this.graph,\n                this.startVertex,\n                endVertex,\n                this.nPaths);\n\n        // at the i-th pass the shortest paths with less (or equal) than i edges\n        // are calculated.\n        for (\n            int passNumber = 1;\n            (passNumber <= this.nMaxHops)\n            && iter.hasNext();\n            passNumber++)\n        {\n            iter.next();\n        }\n\n        List<RankingPathElement<V, E>> list = iter.getPathElements(endVertex);\n\n        if (list == null) {\n            return null;\n        }\n\n        List<GraphPath<V, E>> pathList = new ArrayList<GraphPath<V, E>>();\n\n        for (RankingPathElement<V, E> element : list) {\n            pathList.add(new PathWrapper(element));\n        }\n\n        return pathList;\n    }\n\n    private void assertGetPaths(V endVertex)\n    {\n        if (endVertex == null) {\n            throw new NullPointerException(\"endVertex is null\");\n        }\n        if (endVertex.equals(this.startVertex)) {\n            throw new IllegalArgumentException(\n                \"The end vertex is the same as the start vertex!\");\n        }\n        if (!this.graph.vertexSet().contains(endVertex)) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the end vertex!\");\n        }\n    }\n\n    private void assertKShortestPathsFinder(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        if (graph == null) {\n            throw new NullPointerException(\"graph is null\");\n        }\n        if (startVertex == null) {\n            throw new NullPointerException(\"startVertex is null\");\n        }\n        if (nPaths <= 0) {\n            throw new NullPointerException(\"nPaths is negative or 0\");\n        }\n        if (nMaxHops <= 0) {\n            throw new NullPointerException(\"nMaxHops is negative or 0\");\n        }\n    }\n\n    private class PathWrapper\n        implements GraphPath<V, E>\n    {\n        private RankingPathElement<V, E> rankingPathElement;\n\n        private List<E> edgeList;\n\n        PathWrapper(RankingPathElement<V, E> rankingPathElement)\n        {\n            this.rankingPathElement = rankingPathElement;\n        }\n\n        // implement GraphPath\n        @Override public Graph<V, E> getGraph()\n        {\n            return graph;\n        }\n\n        // implement GraphPath\n        @Override public V getStartVertex()\n        {\n            return startVertex;\n        }\n\n        // implement GraphPath\n        @Override public V getEndVertex()\n        {\n            return rankingPathElement.getVertex();\n        }\n\n        // implement GraphPath\n        @Override public List<E> getEdgeList()\n        {\n            if (edgeList == null) {\n                edgeList = rankingPathElement.createEdgeListPath();\n            }\n            return edgeList;\n        }\n\n        // implement GraphPath\n        @Override public double getWeight()\n        {\n            return rankingPathElement.getWeight();\n        }\n\n        // override Object\n        @Override public String toString()\n        {\n            return getEdgeList().toString();\n        }\n    }\n}\n\n// End KShortestPaths.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "startVertex", "", "V" ], [ "nPaths", "", "int" ], [ "nMaxHops", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getPaths", "org.jgrapht.alg", "KShortestPaths", "public List<GraphPath<V, E>> getPaths(V endVertex)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25724,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "PatonCycleBase",
  "javadocTag" : "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Create a cycle base finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public PatonCycleBase(UndirectedGraph<V, E> graph){\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}",
  "classJavadoc" : "/**\n * Find a cycle base of an undirected graph using the Paton's algorithm.\n *\n * <p>See:<br>\n * K. Paton, An algorithm for finding a fundamental set of cycles for an\n * undirected linear graph, Comm. ACM 12 (1969), pp. 514-518.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * PatonCycleBase.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Find a cycle base of an undirected graph using the Paton's algorithm.\n *\n * <p>See:<br>\n * K. Paton, An algorithm for finding a fundamental set of cycles for an\n * undirected linear graph, Comm. ACM 12 (1969), pp. 514-518.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic class PatonCycleBase<V, E>\n    implements UndirectedCycleBase<V, E>\n{\n    private UndirectedGraph<V, E> graph;\n\n    /**\n     * Create a cycle base finder with an unspecified graph.\n     */\n    public PatonCycleBase()\n    {\n    }\n\n    /**\n     * Create a cycle base finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */\n    public PatonCycleBase(UndirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public UndirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void setGraph(UndirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public List<List<V>> findCycleBase()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        Map<V, Set<V>> used = new HashMap<V, Set<V>>();\n        Map<V, V> parent = new HashMap<V, V>();\n        ArrayDeque<V> stack = new ArrayDeque<V>();\n        List<List<V>> cycles = new ArrayList<List<V>>();\n\n        for (V root : graph.vertexSet()) {\n            // Loop over the connected\n            // components of the graph.\n            if (parent.containsKey(root)) {\n                continue;\n            }\n\n            // Free some memory in case of\n            // multiple connected components.\n            used.clear();\n\n            // Prepare to walk the spanning tree.\n            parent.put(root, root);\n            used.put(root, new HashSet<V>());\n            stack.push(root);\n\n            // Do the walk. It is a BFS with\n            // a LIFO instead of the usual\n            // FIFO. Thus it is easier to\n            // find the cycles in the tree.\n            while (!stack.isEmpty()) {\n                V current = stack.pop();\n                Set<V> currentUsed = used.get(current);\n                for (E e : graph.edgesOf(current)) {\n                    V neighbor = graph.getEdgeTarget(e);\n                    if (neighbor.equals(current)) {\n                        neighbor = graph.getEdgeSource(e);\n                    }\n                    if (!used.containsKey(neighbor)) {\n                        // found a new node\n                        parent.put(neighbor, current);\n                        Set<V> neighbourUsed = new HashSet<V>();\n                        neighbourUsed.add(current);\n                        used.put(neighbor, neighbourUsed);\n                        stack.push(neighbor);\n                    } else if (neighbor.equals(current)) {\n                        // found a self loop\n                        List<V> cycle = new ArrayList<V>();\n                        cycle.add(current);\n                        cycles.add(cycle);\n                    } else if (!currentUsed.contains(neighbor)) {\n                        // found a cycle\n                        Set<V> neighbourUsed = used.get(neighbor);\n                        List<V> cycle = new ArrayList<V>();\n                        cycle.add(neighbor);\n                        cycle.add(current);\n                        V p = parent.get(current);\n                        while (!neighbourUsed.contains(p)) {\n                            cycle.add(p);\n                            p = parent.get(p);\n                        }\n                        cycle.add(p);\n                        cycles.add(cycle);\n                        neighbourUsed.add(current);\n                    }\n                }\n            }\n        }\n        return cycles;\n    }\n}\n\n// End PatonCycleBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.UndirectedGraph", "UndirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getGraph", "org.jgrapht.alg.cycle", "PatonCycleBase", "public UndirectedGraph<V, E> getGraph()" ], [ "findCycleBase", "org.jgrapht.alg.cycle", "PatonCycleBase", "public List<List<V>> findCycleBase()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "degreeOf", "org.jgrapht", "UndirectedGraph", "public abstract int degreeOf(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25725,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.event",
  "className" : "GraphEdgeChangeEvent",
  "javadocTag" : "@return event edge",
  "methodJavadoc" : "    /**\n     * Returns the edge that this event is related to.\n     *\n     * @return event edge\n     */",
  "methodSourceCode" : "public E getEdge(){\n    return edge;\n}",
  "classJavadoc" : "/**\n * An event which indicates that a graph edge has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the edge\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * GraphEdgeChangeEvent.java\n * -------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n *\n */\npackage org.jgrapht.event;\n\n/**\n * An event which indicates that a graph edge has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the edge\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */\npublic class GraphEdgeChangeEvent<V, E>\n    extends GraphChangeEvent\n{\n    private static final long serialVersionUID = 3618134563335844662L;\n\n    /**\n     * Before edge added event. This event is fired before an edge is added to a\n     * graph.\n     */\n    public static final int BEFORE_EDGE_ADDED = 21;\n\n    /**\n     * Before edge removed event. This event is fired before an edge is removed\n     * from a graph.\n     */\n    public static final int BEFORE_EDGE_REMOVED = 22;\n\n    /**\n     * Edge added event. This event is fired after an edge is added to a graph.\n     */\n    public static final int EDGE_ADDED = 23;\n\n    /**\n     * Edge removed event. This event is fired after an edge is removed from a\n     * graph.\n     */\n    public static final int EDGE_REMOVED = 24;\n\n    /**\n     * The edge that this event is related to.\n     */\n    protected E edge;\n\n    /**\n     * The source vertex of the edge that this event is related to.\n     */\n    protected V edgeSource;\n\n    /**\n     * The target vertex of the edge that this event is related to.\n     */\n    protected V edgeTarget;\n\n    /**\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     *\n     * @deprecated Use new constructor which takes vertex parameters.\n     */\n    @Deprecated public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge)\n    {\n        this(eventSource, type, edge, null, null);\n    }\n\n    /**\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     * @param edgeSource edge source vertex\n     * @param edgeTarget edge target vertex\n     */\n    public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge,\n        V edgeSource,\n        V edgeTarget)\n    {\n        super(eventSource, type);\n        this.edge = edge;\n        this.edgeSource = edgeSource;\n        this.edgeTarget = edgeTarget;\n    }\n\n    /**\n     * Returns the edge that this event is related to.\n     *\n     * @return event edge\n     */\n    public E getEdge()\n    {\n        return edge;\n    }\n\n    /**\n     * Returns the source vertex that this event is related to.\n     *\n     * @return event source vertex\n     */\n    public V getEdgeSource()\n    {\n        return edgeSource;\n    }\n\n    /**\n     * Returns the target vertex that this event is related to.\n     *\n     * @return event target vertex\n     */\n    public V getEdgeTarget()\n    {\n        return edgeTarget;\n    }\n}\n\n// End GraphEdgeChangeEvent.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getType", "org.jgrapht.event", "GraphChangeEvent", "public int getType()" ], [ "getEdgeTarget", "org.jgrapht.event", "GraphEdgeChangeEvent", "public V getEdgeTarget()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getEdgeSource", "org.jgrapht.event", "GraphEdgeChangeEvent", "public V getEdgeSource()" ], [ "toString", "java.util", "EventObject", "public String toString()" ], [ "getEdge", "org.jgrapht.event", "GraphEdgeChangeEvent", "public E getEdge()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getSource", "java.util", "EventObject", "public Object getSource()" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "edge", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected E edge;" ], [ "edgeSource", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected V edgeSource;" ], [ "edgeTarget", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected V edgeTarget;" ], [ "type", "org.jgrapht.event", "GraphChangeEvent", "protected int type;" ], [ "source", "java.util", "EventObject", "protected Object source;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25726,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.event",
  "className" : "GraphEdgeChangeEvent",
  "javadocTag" : "@return event source vertex",
  "methodJavadoc" : "    /**\n     * Returns the source vertex that this event is related to.\n     *\n     * @return event source vertex\n     */",
  "methodSourceCode" : "public V getEdgeSource(){\n    return edgeSource;\n}",
  "classJavadoc" : "/**\n * An event which indicates that a graph edge has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the edge\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * GraphEdgeChangeEvent.java\n * -------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n *\n */\npackage org.jgrapht.event;\n\n/**\n * An event which indicates that a graph edge has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the edge\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */\npublic class GraphEdgeChangeEvent<V, E>\n    extends GraphChangeEvent\n{\n    private static final long serialVersionUID = 3618134563335844662L;\n\n    /**\n     * Before edge added event. This event is fired before an edge is added to a\n     * graph.\n     */\n    public static final int BEFORE_EDGE_ADDED = 21;\n\n    /**\n     * Before edge removed event. This event is fired before an edge is removed\n     * from a graph.\n     */\n    public static final int BEFORE_EDGE_REMOVED = 22;\n\n    /**\n     * Edge added event. This event is fired after an edge is added to a graph.\n     */\n    public static final int EDGE_ADDED = 23;\n\n    /**\n     * Edge removed event. This event is fired after an edge is removed from a\n     * graph.\n     */\n    public static final int EDGE_REMOVED = 24;\n\n    /**\n     * The edge that this event is related to.\n     */\n    protected E edge;\n\n    /**\n     * The source vertex of the edge that this event is related to.\n     */\n    protected V edgeSource;\n\n    /**\n     * The target vertex of the edge that this event is related to.\n     */\n    protected V edgeTarget;\n\n    /**\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     *\n     * @deprecated Use new constructor which takes vertex parameters.\n     */\n    @Deprecated public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge)\n    {\n        this(eventSource, type, edge, null, null);\n    }\n\n    /**\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     * @param edgeSource edge source vertex\n     * @param edgeTarget edge target vertex\n     */\n    public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge,\n        V edgeSource,\n        V edgeTarget)\n    {\n        super(eventSource, type);\n        this.edge = edge;\n        this.edgeSource = edgeSource;\n        this.edgeTarget = edgeTarget;\n    }\n\n    /**\n     * Returns the edge that this event is related to.\n     *\n     * @return event edge\n     */\n    public E getEdge()\n    {\n        return edge;\n    }\n\n    /**\n     * Returns the source vertex that this event is related to.\n     *\n     * @return event source vertex\n     */\n    public V getEdgeSource()\n    {\n        return edgeSource;\n    }\n\n    /**\n     * Returns the target vertex that this event is related to.\n     *\n     * @return event target vertex\n     */\n    public V getEdgeTarget()\n    {\n        return edgeTarget;\n    }\n}\n\n// End GraphEdgeChangeEvent.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdgeSource", "org.jgrapht.event", "GraphEdgeChangeEvent", "public V getEdgeSource()" ], [ "getType", "org.jgrapht.event", "GraphChangeEvent", "public int getType()" ], [ "getEdge", "org.jgrapht.event", "GraphEdgeChangeEvent", "public E getEdge()" ], [ "getEdgeTarget", "org.jgrapht.event", "GraphEdgeChangeEvent", "public V getEdgeTarget()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.util", "EventObject", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getSource", "java.util", "EventObject", "public Object getSource()" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "edge", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected E edge;" ], [ "edgeSource", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected V edgeSource;" ], [ "edgeTarget", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected V edgeTarget;" ], [ "type", "org.jgrapht.event", "GraphChangeEvent", "protected int type;" ], [ "source", "java.util", "EventObject", "protected Object source;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25727,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.event",
  "className" : "GraphEdgeChangeEvent",
  "javadocTag" : "@return event target vertex",
  "methodJavadoc" : "    /**\n     * Returns the target vertex that this event is related to.\n     *\n     * @return event target vertex\n     */",
  "methodSourceCode" : "public V getEdgeTarget(){\n    return edgeTarget;\n}",
  "classJavadoc" : "/**\n * An event which indicates that a graph edge has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the edge\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * GraphEdgeChangeEvent.java\n * -------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Aug-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n *\n */\npackage org.jgrapht.event;\n\n/**\n * An event which indicates that a graph edge has changed, or is about to\n * change. The event can be used either as an indication <i>after</i> the edge\n * has been added or removed, or <i>before</i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n */\npublic class GraphEdgeChangeEvent<V, E>\n    extends GraphChangeEvent\n{\n    private static final long serialVersionUID = 3618134563335844662L;\n\n    /**\n     * Before edge added event. This event is fired before an edge is added to a\n     * graph.\n     */\n    public static final int BEFORE_EDGE_ADDED = 21;\n\n    /**\n     * Before edge removed event. This event is fired before an edge is removed\n     * from a graph.\n     */\n    public static final int BEFORE_EDGE_REMOVED = 22;\n\n    /**\n     * Edge added event. This event is fired after an edge is added to a graph.\n     */\n    public static final int EDGE_ADDED = 23;\n\n    /**\n     * Edge removed event. This event is fired after an edge is removed from a\n     * graph.\n     */\n    public static final int EDGE_REMOVED = 24;\n\n    /**\n     * The edge that this event is related to.\n     */\n    protected E edge;\n\n    /**\n     * The source vertex of the edge that this event is related to.\n     */\n    protected V edgeSource;\n\n    /**\n     * The target vertex of the edge that this event is related to.\n     */\n    protected V edgeTarget;\n\n    /**\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     *\n     * @deprecated Use new constructor which takes vertex parameters.\n     */\n    @Deprecated public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge)\n    {\n        this(eventSource, type, edge, null, null);\n    }\n\n    /**\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     * @param edgeSource edge source vertex\n     * @param edgeTarget edge target vertex\n     */\n    public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge,\n        V edgeSource,\n        V edgeTarget)\n    {\n        super(eventSource, type);\n        this.edge = edge;\n        this.edgeSource = edgeSource;\n        this.edgeTarget = edgeTarget;\n    }\n\n    /**\n     * Returns the edge that this event is related to.\n     *\n     * @return event edge\n     */\n    public E getEdge()\n    {\n        return edge;\n    }\n\n    /**\n     * Returns the source vertex that this event is related to.\n     *\n     * @return event source vertex\n     */\n    public V getEdgeSource()\n    {\n        return edgeSource;\n    }\n\n    /**\n     * Returns the target vertex that this event is related to.\n     *\n     * @return event target vertex\n     */\n    public V getEdgeTarget()\n    {\n        return edgeTarget;\n    }\n}\n\n// End GraphEdgeChangeEvent.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getType", "org.jgrapht.event", "GraphChangeEvent", "public int getType()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.util", "EventObject", "public String toString()" ], [ "getEdgeSource", "org.jgrapht.event", "GraphEdgeChangeEvent", "public V getEdgeSource()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getEdge", "org.jgrapht.event", "GraphEdgeChangeEvent", "public E getEdge()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getSource", "java.util", "EventObject", "public Object getSource()" ], [ "getEdgeTarget", "org.jgrapht.event", "GraphEdgeChangeEvent", "public V getEdgeTarget()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "edge", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected E edge;" ], [ "edgeSource", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected V edgeSource;" ], [ "edgeTarget", "org.jgrapht.event", "GraphEdgeChangeEvent", "protected V edgeTarget;" ], [ "type", "org.jgrapht.event", "GraphChangeEvent", "protected int type;" ], [ "source", "java.util", "EventObject", "protected Object source;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25728,
  "oracle" : "g==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.traverse",
  "className" : "CrossComponentIterator",
  "javadocTag" : "@throws IllegalArgumentException if <code>g==null</code> or does not\ncontain <code>startVertex</code>",
  "methodJavadoc" : "    /**\n     * Creates a new iterator for the specified graph. Iteration will start at\n     * the specified start vertex. If the specified start vertex is <code>\n     * null</code>, Iteration will start at an arbitrary graph vertex.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     *\n     * @throws IllegalArgumentException if <code>g==null</code> or does not\n     * contain <code>startVertex</code>\n     */",
  "methodSourceCode" : "public CrossComponentIterator(Graph<V, E> g, V startVertex){\n    super();\n    if (g == null) {\n        throw new IllegalArgumentException(\"graph must not be null\");\n    }\n    graph = g;\n    specifics = createGraphSpecifics(g);\n    vertexIterator = g.vertexSet().iterator();\n    setCrossComponentTraversal(startVertex == null);\n    reusableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, null);\n    reusableVertexEvent = new FlyweightVertexEvent<V>(this, null);\n    if (startVertex == null) {\n        // pick a start vertex if graph not empty\n        if (vertexIterator.hasNext()) {\n            this.startVertex = vertexIterator.next();\n        } else {\n            this.startVertex = null;\n        }\n    } else if (g.containsVertex(startVertex)) {\n        this.startVertex = startVertex;\n    } else {\n        throw new IllegalArgumentException(\"graph must contain the start vertex\");\n    }\n}",
  "classJavadoc" : "/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * CrossComponentIterator.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 31-Jul-2003 : Initial revision (BN);\n * 11-Aug-2003 : Adaptation to new event model (BN);\n * 31-Jan-2004 : Extracted cross-component traversal functionality (BN);\n * 04-May-2004 : Made generic (CH)\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\n\n\n/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */\npublic abstract class CrossComponentIterator<V, E, D>\n    extends AbstractGraphIterator<V, E>\n{\n    private static final int CCS_BEFORE_COMPONENT = 1;\n    private static final int CCS_WITHIN_COMPONENT = 2;\n    private static final int CCS_AFTER_COMPONENT = 3;\n\n    /**\n     * Standard vertex visit state enumeration.\n     */\n    protected static enum VisitColor\n    {\n        /**\n         * Vertex has not been returned via iterator yet.\n         */\n        WHITE,\n\n        /**\n         * Vertex has been returned via iterator, but we're not done with all of\n         * its out-edges yet.\n         */\n        GRAY,\n\n        /**\n         * Vertex has been returned via iterator, and we're done with all of its\n         * out-edges.\n         */\n        BLACK\n    }\n\n    //\n    private final ConnectedComponentTraversalEvent ccFinishedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_FINISHED);\n    private final ConnectedComponentTraversalEvent ccStartedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_STARTED);\n\n    // TODO: support ConcurrentModificationException if graph modified\n    // during iteration.\n    private FlyweightEdgeEvent<V, E> reusableEdgeEvent;\n    private FlyweightVertexEvent<V> reusableVertexEvent;\n    private Iterator<V> vertexIterator = null;\n\n    /**\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     */\n    private Map<V, D> seen = new HashMap<V, D>();\n    private V startVertex;\n    private Specifics<V, E> specifics;\n\n    private final Graph<V, E> graph;\n\n    /**\n     * The connected component state\n     */\n    private int state = CCS_BEFORE_COMPONENT;\n\n    /**\n     * Creates a new iterator for the specified graph. Iteration will start at\n     * the specified start vertex. If the specified start vertex is <code>\n     * null</code>, Iteration will start at an arbitrary graph vertex.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     *\n     * @throws IllegalArgumentException if <code>g==null</code> or does not\n     * contain <code>startVertex</code>\n     */\n    public CrossComponentIterator(Graph<V, E> g, V startVertex)\n    {\n        super();\n\n        if (g == null) {\n            throw new IllegalArgumentException(\"graph must not be null\");\n        }\n        graph = g;\n\n        specifics = createGraphSpecifics(g);\n        vertexIterator = g.vertexSet().iterator();\n        setCrossComponentTraversal(startVertex == null);\n\n        reusableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, null);\n        reusableVertexEvent = new FlyweightVertexEvent<V>(this, null);\n\n        if (startVertex == null) {\n            // pick a start vertex if graph not empty\n            if (vertexIterator.hasNext()) {\n                this.startVertex = vertexIterator.next();\n            } else {\n                this.startVertex = null;\n            }\n        } else if (g.containsVertex(startVertex)) {\n            this.startVertex = startVertex;\n        } else {\n            throw new IllegalArgumentException(\n                \"graph must contain the start vertex\");\n        }\n    }\n\n    /**\n     * @return the graph being traversed\n     */\n    public Graph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * @see java.util.Iterator#hasNext()\n     */\n    @Override public boolean hasNext()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (isConnectedComponentExhausted()) {\n            if (state == CCS_WITHIN_COMPONENT) {\n                state = CCS_AFTER_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentFinished(ccFinishedEvent);\n                }\n            }\n\n            if (isCrossComponentTraversal()) {\n                while (vertexIterator.hasNext()) {\n                    V v = vertexIterator.next();\n\n                    if (!isSeenVertex(v)) {\n                        encounterVertex(v, null);\n                        state = CCS_BEFORE_COMPONENT;\n\n                        return true;\n                    }\n                }\n\n                return false;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @see java.util.Iterator#next()\n     */\n    @Override public V next()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            if (state == CCS_BEFORE_COMPONENT) {\n                state = CCS_WITHIN_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentStarted(ccStartedEvent);\n                }\n            }\n\n            V nextVertex = provideNextVertex();\n            if (nListeners != 0) {\n                fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n            }\n\n            addUnseenChildrenOf(nextVertex);\n\n            return nextVertex;\n        } else {\n            throw new NoSuchElementException();\n        }\n    }\n\n    /**\n     * Returns <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     */\n    protected abstract boolean isConnectedComponentExhausted();\n\n    /**\n     * Update data structures the first time we see a vertex.\n     *\n     * @param vertex the vertex encountered\n     * @param edge the edge via which the vertex was encountered, or null if the\n     * vertex is a starting point\n     */\n    protected abstract void encounterVertex(V vertex, E edge);\n\n    /**\n     * Returns the vertex to be returned in the following call to the iterator\n     * <code>next</code> method.\n     *\n     * @return the next vertex to be returned by this iterator.\n     */\n    protected abstract V provideNextVertex();\n\n    /**\n     * Access the data stored for a seen vertex.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex. A <code>null</code> return can also\n     * indicate that the vertex was explicitly associated with <code>\n     * null</code>.\n     */\n    protected D getSeenData(V vertex)\n    {\n        return seen.get(vertex);\n    }\n\n    /**\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question\n     *\n     * @return <tt>true</tt> if vertex has already been seen\n     */\n    protected boolean isSeenVertex(Object vertex)\n    {\n        return seen.containsKey(vertex);\n    }\n\n    /**\n     * Called whenever we re-encounter a vertex. The default implementation does\n     * nothing.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     */\n    protected abstract void encounterVertexAgain(V vertex, E edge);\n\n    /**\n     * Stores iterator-dependent data for a vertex that has been seen.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null</code> if no data was associated with the vertex. A <code>\n     * null</code> return can also indicate that the vertex was explicitly\n     * associated with <code>null</code>.\n     */\n    protected D putSeenData(V vertex, D data)\n    {\n        return seen.put(vertex, data);\n    }\n\n    /**\n     * Called when a vertex has been finished (meaning is dependent on traversal\n     * represented by subclass).\n     *\n     * @param vertex vertex which has been finished\n     */\n    protected void finishVertex(V vertex)\n    {\n        if (nListeners != 0) {\n            fireVertexFinished(createVertexTraversalEvent(vertex));\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    /**\n     * @param <V>\n     * @param <E>\n     * @param g\n     *\n     * @return TODO Document me\n     */\n    static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n        } else {\n            return new UndirectedSpecifics<V, E>(g);\n        }\n    }\n\n    private void addUnseenChildrenOf(V vertex)\n    {\n        for (E edge : specifics.edgesOf(vertex)) {\n            if (nListeners != 0) {\n                fireEdgeTraversed(createEdgeTraversalEvent(edge));\n            }\n\n            V oppositeV = Graphs.getOppositeVertex(graph, edge, vertex);\n\n            if (isSeenVertex(oppositeV)) {\n                encounterVertexAgain(oppositeV, edge);\n            } else {\n                encounterVertex(oppositeV, edge);\n            }\n        }\n    }\n\n    private EdgeTraversalEvent<V, E> createEdgeTraversalEvent(E edge)\n    {\n        if (isReuseEvents()) {\n            reusableEdgeEvent.setEdge(edge);\n\n            return reusableEdgeEvent;\n        } else {\n            return new EdgeTraversalEvent<V, E>(this, edge);\n        }\n    }\n\n    private VertexTraversalEvent<V> createVertexTraversalEvent(V vertex)\n    {\n        if (isReuseEvents()) {\n            reusableVertexEvent.setVertex(vertex);\n\n            return reusableVertexEvent;\n        } else {\n            return new VertexTraversalEvent<V>(this, vertex);\n        }\n    }\n\n    private void encounterStartVertex()\n    {\n        encounterVertex(startVertex, null);\n        startVertex = null;\n    }\n\n    static interface SimpleContainer<T>\n    {\n        /**\n         * Tests if this container is empty.\n         *\n         * @return <code>true</code> if empty, otherwise <code>false</code>.\n         */\n        public boolean isEmpty();\n\n        /**\n         * Adds the specified object to this container.\n         *\n         * @param o the object to be added.\n         */\n        public void add(T o);\n\n        /**\n         * Remove an object from this container and return it.\n         *\n         * @return the object removed from this container.\n         */\n        public T remove();\n    }\n\n    /**\n     * Provides unified interface for operations that are different in directed\n     * graphs and in undirected graphs.\n     */\n    abstract static class Specifics<VV, EE>\n    {\n        /**\n         * Returns the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         *\n         * @param vertex the vertex whose outgoing edges are to be returned.\n         *\n         * @return the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         */\n        public abstract Set<? extends EE> edgesOf(VV vertex);\n    }\n\n    /**\n     * A reusable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightEdgeEvent<VV, localE>\n        extends EdgeTraversalEvent<VV, localE>\n    {\n        private static final long serialVersionUID = 4051327833765000755L;\n\n        /**\n         * @see EdgeTraversalEvent#EdgeTraversalEvent(Object, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, localE edge)\n        {\n            super(eventSource, edge);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param edge the edge to be set.\n         */\n        protected void setEdge(localE edge)\n        {\n            this.edge = edge;\n        }\n    }\n\n    /**\n     * A reusable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightVertexEvent<VV>\n        extends VertexTraversalEvent<VV>\n    {\n        private static final long serialVersionUID = 3834024753848399924L;\n\n        /**\n         * @see VertexTraversalEvent#VertexTraversalEvent(Object, Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, VV vertex)\n        {\n            super(eventSource, vertex);\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} for a directed graph.\n     */\n    private static class DirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private DirectedGraph<VV, EE> graph;\n\n        /**\n         * Creates a new DirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public DirectedSpecifics(DirectedGraph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<? extends EE> edgesOf(VV vertex)\n        {\n            return graph.outgoingEdgesOf(vertex);\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} in which edge direction (if any)\n     * is ignored.\n     */\n    private static class UndirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private Graph<VV, EE> graph;\n\n        /**\n         * Creates a new UndirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public UndirectedSpecifics(Graph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<EE> edgesOf(VV vertex)\n        {\n            return graph.edgesOf(vertex);\n        }\n    }\n}\n\n// End CrossComponentIterator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "g", "org.jgrapht.Graph", "Graph<V, E>" ], [ "startVertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "provideNextVertex", "org.jgrapht.traverse", "CrossComponentIterator", "protected abstract V provideNextVertex()" ], [ "putSeenData", "org.jgrapht.traverse", "CrossComponentIterator", "protected D putSeenData(V vertex, D data)" ], [ "isReuseEvents", "org.jgrapht.traverse", "AbstractGraphIterator", "public boolean isReuseEvents()" ], [ "isCrossComponentTraversal", "org.jgrapht.traverse", "AbstractGraphIterator", "public boolean isCrossComponentTraversal()" ], [ "hasNext", "org.jgrapht.traverse", "CrossComponentIterator", "public boolean hasNext()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getSeenData", "org.jgrapht.traverse", "CrossComponentIterator", "protected D getSeenData(V vertex)" ], [ "getGraph", "org.jgrapht.traverse", "CrossComponentIterator", "public Graph<V, E> getGraph()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "isConnectedComponentExhausted", "org.jgrapht.traverse", "CrossComponentIterator", "protected abstract boolean isConnectedComponentExhausted()" ], [ "next", "org.jgrapht.traverse", "CrossComponentIterator", "public V next()" ], [ "isSeenVertex", "org.jgrapht.traverse", "CrossComponentIterator", "protected boolean isSeenVertex(Object vertex)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "nListeners", "org.jgrapht.traverse", "AbstractGraphIterator", "protected int nListeners;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25729,
  "oracle" : "this.hasNext();",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.traverse",
  "className" : "CrossComponentIterator",
  "javadocTag" : "@param edge the edge via which the vertex was encountered, or null if the\nvertex is a starting point",
  "methodJavadoc" : "    /**\n     * Update data structures the first time we see a vertex.\n     *\n     * @param vertex the vertex encountered\n     * @param edge the edge via which the vertex was encountered, or null if the\n     * vertex is a starting point\n     */",
  "methodSourceCode" : "protected abstract void encounterVertex(V vertex, E edge);",
  "classJavadoc" : "/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * CrossComponentIterator.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 31-Jul-2003 : Initial revision (BN);\n * 11-Aug-2003 : Adaptation to new event model (BN);\n * 31-Jan-2004 : Extracted cross-component traversal functionality (BN);\n * 04-May-2004 : Made generic (CH)\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\n\n\n/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n */\npublic abstract class CrossComponentIterator<V, E, D>\n    extends AbstractGraphIterator<V, E>\n{\n    private static final int CCS_BEFORE_COMPONENT = 1;\n    private static final int CCS_WITHIN_COMPONENT = 2;\n    private static final int CCS_AFTER_COMPONENT = 3;\n\n    /**\n     * Standard vertex visit state enumeration.\n     */\n    protected static enum VisitColor\n    {\n        /**\n         * Vertex has not been returned via iterator yet.\n         */\n        WHITE,\n\n        /**\n         * Vertex has been returned via iterator, but we're not done with all of\n         * its out-edges yet.\n         */\n        GRAY,\n\n        /**\n         * Vertex has been returned via iterator, and we're done with all of its\n         * out-edges.\n         */\n        BLACK\n    }\n\n    //\n    private final ConnectedComponentTraversalEvent ccFinishedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_FINISHED);\n    private final ConnectedComponentTraversalEvent ccStartedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_STARTED);\n\n    // TODO: support ConcurrentModificationException if graph modified\n    // during iteration.\n    private FlyweightEdgeEvent<V, E> reusableEdgeEvent;\n    private FlyweightVertexEvent<V> reusableVertexEvent;\n    private Iterator<V> vertexIterator = null;\n\n    /**\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     */\n    private Map<V, D> seen = new HashMap<V, D>();\n    private V startVertex;\n    private Specifics<V, E> specifics;\n\n    private final Graph<V, E> graph;\n\n    /**\n     * The connected component state\n     */\n    private int state = CCS_BEFORE_COMPONENT;\n\n    /**\n     * Creates a new iterator for the specified graph. Iteration will start at\n     * the specified start vertex. If the specified start vertex is <code>\n     * null</code>, Iteration will start at an arbitrary graph vertex.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     *\n     * @throws IllegalArgumentException if <code>g==null</code> or does not\n     * contain <code>startVertex</code>\n     */\n    public CrossComponentIterator(Graph<V, E> g, V startVertex)\n    {\n        super();\n\n        if (g == null) {\n            throw new IllegalArgumentException(\"graph must not be null\");\n        }\n        graph = g;\n\n        specifics = createGraphSpecifics(g);\n        vertexIterator = g.vertexSet().iterator();\n        setCrossComponentTraversal(startVertex == null);\n\n        reusableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, null);\n        reusableVertexEvent = new FlyweightVertexEvent<V>(this, null);\n\n        if (startVertex == null) {\n            // pick a start vertex if graph not empty\n            if (vertexIterator.hasNext()) {\n                this.startVertex = vertexIterator.next();\n            } else {\n                this.startVertex = null;\n            }\n        } else if (g.containsVertex(startVertex)) {\n            this.startVertex = startVertex;\n        } else {\n            throw new IllegalArgumentException(\n                \"graph must contain the start vertex\");\n        }\n    }\n\n    /**\n     * @return the graph being traversed\n     */\n    public Graph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * @see java.util.Iterator#hasNext()\n     */\n    @Override public boolean hasNext()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (isConnectedComponentExhausted()) {\n            if (state == CCS_WITHIN_COMPONENT) {\n                state = CCS_AFTER_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentFinished(ccFinishedEvent);\n                }\n            }\n\n            if (isCrossComponentTraversal()) {\n                while (vertexIterator.hasNext()) {\n                    V v = vertexIterator.next();\n\n                    if (!isSeenVertex(v)) {\n                        encounterVertex(v, null);\n                        state = CCS_BEFORE_COMPONENT;\n\n                        return true;\n                    }\n                }\n\n                return false;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @see java.util.Iterator#next()\n     */\n    @Override public V next()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            if (state == CCS_BEFORE_COMPONENT) {\n                state = CCS_WITHIN_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentStarted(ccStartedEvent);\n                }\n            }\n\n            V nextVertex = provideNextVertex();\n            if (nListeners != 0) {\n                fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n            }\n\n            addUnseenChildrenOf(nextVertex);\n\n            return nextVertex;\n        } else {\n            throw new NoSuchElementException();\n        }\n    }\n\n    /**\n     * Returns <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false</tt> otherwise.\n     */\n    protected abstract boolean isConnectedComponentExhausted();\n\n    /**\n     * Update data structures the first time we see a vertex.\n     *\n     * @param vertex the vertex encountered\n     * @param edge the edge via which the vertex was encountered, or null if the\n     * vertex is a starting point\n     */\n    protected abstract void encounterVertex(V vertex, E edge);\n\n    /**\n     * Returns the vertex to be returned in the following call to the iterator\n     * <code>next</code> method.\n     *\n     * @return the next vertex to be returned by this iterator.\n     */\n    protected abstract V provideNextVertex();\n\n    /**\n     * Access the data stored for a seen vertex.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null</code> if no\n     * data was associated with the vertex. A <code>null</code> return can also\n     * indicate that the vertex was explicitly associated with <code>\n     * null</code>.\n     */\n    protected D getSeenData(V vertex)\n    {\n        return seen.get(vertex);\n    }\n\n    /**\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question\n     *\n     * @return <tt>true</tt> if vertex has already been seen\n     */\n    protected boolean isSeenVertex(Object vertex)\n    {\n        return seen.containsKey(vertex);\n    }\n\n    /**\n     * Called whenever we re-encounter a vertex. The default implementation does\n     * nothing.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     */\n    protected abstract void encounterVertexAgain(V vertex, E edge);\n\n    /**\n     * Stores iterator-dependent data for a vertex that has been seen.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null</code> if no data was associated with the vertex. A <code>\n     * null</code> return can also indicate that the vertex was explicitly\n     * associated with <code>null</code>.\n     */\n    protected D putSeenData(V vertex, D data)\n    {\n        return seen.put(vertex, data);\n    }\n\n    /**\n     * Called when a vertex has been finished (meaning is dependent on traversal\n     * represented by subclass).\n     *\n     * @param vertex vertex which has been finished\n     */\n    protected void finishVertex(V vertex)\n    {\n        if (nListeners != 0) {\n            fireVertexFinished(createVertexTraversalEvent(vertex));\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    /**\n     * @param <V>\n     * @param <E>\n     * @param g\n     *\n     * @return TODO Document me\n     */\n    static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n        } else {\n            return new UndirectedSpecifics<V, E>(g);\n        }\n    }\n\n    private void addUnseenChildrenOf(V vertex)\n    {\n        for (E edge : specifics.edgesOf(vertex)) {\n            if (nListeners != 0) {\n                fireEdgeTraversed(createEdgeTraversalEvent(edge));\n            }\n\n            V oppositeV = Graphs.getOppositeVertex(graph, edge, vertex);\n\n            if (isSeenVertex(oppositeV)) {\n                encounterVertexAgain(oppositeV, edge);\n            } else {\n                encounterVertex(oppositeV, edge);\n            }\n        }\n    }\n\n    private EdgeTraversalEvent<V, E> createEdgeTraversalEvent(E edge)\n    {\n        if (isReuseEvents()) {\n            reusableEdgeEvent.setEdge(edge);\n\n            return reusableEdgeEvent;\n        } else {\n            return new EdgeTraversalEvent<V, E>(this, edge);\n        }\n    }\n\n    private VertexTraversalEvent<V> createVertexTraversalEvent(V vertex)\n    {\n        if (isReuseEvents()) {\n            reusableVertexEvent.setVertex(vertex);\n\n            return reusableVertexEvent;\n        } else {\n            return new VertexTraversalEvent<V>(this, vertex);\n        }\n    }\n\n    private void encounterStartVertex()\n    {\n        encounterVertex(startVertex, null);\n        startVertex = null;\n    }\n\n    static interface SimpleContainer<T>\n    {\n        /**\n         * Tests if this container is empty.\n         *\n         * @return <code>true</code> if empty, otherwise <code>false</code>.\n         */\n        public boolean isEmpty();\n\n        /**\n         * Adds the specified object to this container.\n         *\n         * @param o the object to be added.\n         */\n        public void add(T o);\n\n        /**\n         * Remove an object from this container and return it.\n         *\n         * @return the object removed from this container.\n         */\n        public T remove();\n    }\n\n    /**\n     * Provides unified interface for operations that are different in directed\n     * graphs and in undirected graphs.\n     */\n    abstract static class Specifics<VV, EE>\n    {\n        /**\n         * Returns the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         *\n         * @param vertex the vertex whose outgoing edges are to be returned.\n         *\n         * @return the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         */\n        public abstract Set<? extends EE> edgesOf(VV vertex);\n    }\n\n    /**\n     * A reusable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightEdgeEvent<VV, localE>\n        extends EdgeTraversalEvent<VV, localE>\n    {\n        private static final long serialVersionUID = 4051327833765000755L;\n\n        /**\n         * @see EdgeTraversalEvent#EdgeTraversalEvent(Object, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, localE edge)\n        {\n            super(eventSource, edge);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param edge the edge to be set.\n         */\n        protected void setEdge(localE edge)\n        {\n            this.edge = edge;\n        }\n    }\n\n    /**\n     * A reusable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     */\n    static class FlyweightVertexEvent<VV>\n        extends VertexTraversalEvent<VV>\n    {\n        private static final long serialVersionUID = 3834024753848399924L;\n\n        /**\n         * @see VertexTraversalEvent#VertexTraversalEvent(Object, Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, VV vertex)\n        {\n            super(eventSource, vertex);\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} for a directed graph.\n     */\n    private static class DirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private DirectedGraph<VV, EE> graph;\n\n        /**\n         * Creates a new DirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public DirectedSpecifics(DirectedGraph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<? extends EE> edgesOf(VV vertex)\n        {\n            return graph.outgoingEdgesOf(vertex);\n        }\n    }\n\n    /**\n     * An implementation of {@link Specifics} in which edge direction (if any)\n     * is ignored.\n     */\n    private static class UndirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private Graph<VV, EE> graph;\n\n        /**\n         * Creates a new UndirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         */\n        public UndirectedSpecifics(Graph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        /**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         */\n        @Override public Set<EE> edgesOf(VV vertex)\n        {\n            return graph.edgesOf(vertex);\n        }\n    }\n}\n\n// End CrossComponentIterator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ], [ "edge", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "isReuseEvents", "org.jgrapht.traverse", "AbstractGraphIterator", "public boolean isReuseEvents()" ], [ "isCrossComponentTraversal", "org.jgrapht.traverse", "AbstractGraphIterator", "public boolean isCrossComponentTraversal()" ], [ "getSeenData", "org.jgrapht.traverse", "CrossComponentIterator", "protected D getSeenData(V vertex)" ], [ "isSeenVertex", "org.jgrapht.traverse", "CrossComponentIterator", "protected boolean isSeenVertex(Object vertex)" ], [ "next", "org.jgrapht.traverse", "CrossComponentIterator", "public V next()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "putSeenData", "org.jgrapht.traverse", "CrossComponentIterator", "protected D putSeenData(V vertex, D data)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "isConnectedComponentExhausted", "org.jgrapht.traverse", "CrossComponentIterator", "protected abstract boolean isConnectedComponentExhausted()" ], [ "provideNextVertex", "org.jgrapht.traverse", "CrossComponentIterator", "protected abstract V provideNextVertex()" ], [ "getGraph", "org.jgrapht.traverse", "CrossComponentIterator", "public Graph<V, E> getGraph()" ], [ "hasNext", "org.jgrapht.traverse", "CrossComponentIterator", "public boolean hasNext()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "nListeners", "org.jgrapht.traverse", "AbstractGraphIterator", "protected int nListeners;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25730,
  "oracle" : "((queue==null)==false) && (queue.isEmpty());",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.traverse",
  "className" : "TopologicalOrderIterator",
  "javadocTag" : "@param queue queue to use for tie-break in case of partial order (e.g. a\nPriorityQueue can be used to break ties according to vertex priority);\nmust be initially empty",
  "methodJavadoc" : "    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with a user-supplied queue implementation to allow customized\n     * control over tie-breaking in case of partial order. Traversal will start\n     * at one of the graph's <i>sources</i>. See the definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue queue to use for tie-break in case of partial order (e.g. a\n     * PriorityQueue can be used to break ties according to vertex priority);\n     * must be initially empty\n     */",
  "methodSourceCode" : "public TopologicalOrderIterator(DirectedGraph<V, E> dg, Queue<V> queue){\n    this(dg, queue, new HashMap<V, ModifiableInteger>());\n}",
  "classJavadoc" : "/**\n * Implements topological order traversal for a directed acyclic graph. A\n * topological sort is a permutation <tt>p</tt> of the vertices of a graph such\n * that an edge <tt>(i,j)</tt> implies that <tt>i</tt> appears before <tt>j</tt>\n * in <tt>p</tt> (Skiena 1990, p. 208). See also <a\n * href=\"http://mathworld.wolfram.com/TopologicalSort.html\">\n * http://mathworld.wolfram.com/TopologicalSort.html</a>.\n *\n * <p>See \"Algorithms in Java, Third Edition, Part 5: Graph Algorithms\" by\n * Robert Sedgewick and \"Data Structures and Algorithms with Object-Oriented\n * Design Patterns in Java\" by Bruno R. Preiss for implementation alternatives.\n * The latter can be found online at <a\n * href=\"http://www.brpreiss.com/books/opus5/\">\n * http://www.brpreiss.com/books/opus5/</a></p>\n *\n * <p>For this iterator to work correctly the graph must be acyclic, and must\n * not be modified during iteration. Currently there are no means to ensure\n * that, nor to fail-fast; the results with cyclic input (including self-loops)\n * or concurrent modifications are undefined. To precheck a graph for cycles,\n * consider using {@link org.jgrapht.alg.CycleDetector} or {@link\n * KosarajuStrongConnectivityInspector}.</p>\n *\n * @author Marden Neubert\n * @since Dec 18, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------------------\n * TopologicalOrderIterator.java\n * -----------------------------\n * (C) Copyright 2004-2008, by Marden Neubert and Contributors.\n *\n * Original Author:  Marden Neubert\n * Contributor(s):   Barak Naveh, John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Dec-2004 : Initial revision (MN);\n * 25-Apr-2005 : Fixes for start vertex order (JVS);\n * 06-Jun-2005 : Made generic (CH);\n *\n */\npackage org.jgrapht.traverse;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * Implements topological order traversal for a directed acyclic graph. A\n * topological sort is a permutation <tt>p</tt> of the vertices of a graph such\n * that an edge <tt>(i,j)</tt> implies that <tt>i</tt> appears before <tt>j</tt>\n * in <tt>p</tt> (Skiena 1990, p. 208). See also <a\n * href=\"http://mathworld.wolfram.com/TopologicalSort.html\">\n * http://mathworld.wolfram.com/TopologicalSort.html</a>.\n *\n * <p>See \"Algorithms in Java, Third Edition, Part 5: Graph Algorithms\" by\n * Robert Sedgewick and \"Data Structures and Algorithms with Object-Oriented\n * Design Patterns in Java\" by Bruno R. Preiss for implementation alternatives.\n * The latter can be found online at <a\n * href=\"http://www.brpreiss.com/books/opus5/\">\n * http://www.brpreiss.com/books/opus5/</a></p>\n *\n * <p>For this iterator to work correctly the graph must be acyclic, and must\n * not be modified during iteration. Currently there are no means to ensure\n * that, nor to fail-fast; the results with cyclic input (including self-loops)\n * or concurrent modifications are undefined. To precheck a graph for cycles,\n * consider using {@link org.jgrapht.alg.CycleDetector} or {@link\n * KosarajuStrongConnectivityInspector}.</p>\n *\n * @author Marden Neubert\n * @since Dec 18, 2004\n */\npublic class TopologicalOrderIterator<V, E>\n    extends CrossComponentIterator<V, E, Object>\n{\n    private Queue<V> queue;\n    private Map<V, ModifiableInteger> inDegreeMap;\n\n    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with arbitrary tie-breaking in case of partial order.\n     * Traversal will start at one of the graph's <i>sources</i>. See the\n     * definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     */\n    public TopologicalOrderIterator(DirectedGraph<V, E> dg)\n    {\n        this(dg, new LinkedListQueue<V>());\n    }\n\n    /**\n     * Creates a new topological order iterator over the directed graph\n     * specified, with a user-supplied queue implementation to allow customized\n     * control over tie-breaking in case of partial order. Traversal will start\n     * at one of the graph's <i>sources</i>. See the definition of source at <a\n     * href=\"http://mathworld.wolfram.com/Source.html\">\n     * http://mathworld.wolfram.com/Source.html</a>.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue queue to use for tie-break in case of partial order (e.g. a\n     * PriorityQueue can be used to break ties according to vertex priority);\n     * must be initially empty\n     */\n    public TopologicalOrderIterator(DirectedGraph<V, E> dg, Queue<V> queue)\n    {\n        this(dg, queue, new HashMap<V, ModifiableInteger>());\n    }\n\n    // NOTE: This is a hack to deal with the fact that CrossComponentIterator\n    // needs to know the start vertex in its constructor\n    private TopologicalOrderIterator(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        this(dg, initialize(dg, queue, inDegreeMap));\n        this.queue = queue;\n        this.inDegreeMap = inDegreeMap;\n\n        // empty queue for non-empty graph would indicate presence of\n        // cycles (no roots found)\n        assert dg.vertexSet().isEmpty() || !queue.isEmpty();\n    }\n\n    // NOTE: This is intentionally private, because starting the sort \"in the\n    // middle\" doesn't make sense.\n    private TopologicalOrderIterator(DirectedGraph<V, E> dg, V start)\n    {\n        super(dg, start);\n    }\n\n    /**\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     */\n    @Override protected boolean isConnectedComponentExhausted()\n    {\n        // FIXME jvs 25-Apr-2005: This isn't correct for a graph with more than\n        // one component.  We will actually exhaust a connected component\n        // before the queue is empty, because initialize adds roots from all\n        // components to the queue.\n        return queue.isEmpty();\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     */\n    @Override protected void encounterVertex(V vertex, E edge)\n    {\n        putSeenData(vertex, null);\n        decrementInDegree(vertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#encounterVertexAgain(Object, Object)\n     */\n    @Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        decrementInDegree(vertex);\n    }\n\n    /**\n     * @see CrossComponentIterator#provideNextVertex()\n     */\n    @Override protected V provideNextVertex()\n    {\n        return queue.remove();\n    }\n\n    /**\n     * Decrements the in-degree of a vertex.\n     *\n     * @param vertex the vertex whose in-degree will be decremented.\n     */\n    private void decrementInDegree(V vertex)\n    {\n        ModifiableInteger inDegree = inDegreeMap.get(vertex);\n\n        if (inDegree.value > 0) {\n            inDegree.value--;\n\n            if (inDegree.value == 0) {\n                queue.offer(vertex);\n            }\n        }\n    }\n\n    /**\n     * Initializes the internal traversal object structure. Sets up the internal\n     * queue with the directed graph vertices and creates the control structure\n     * for the in-degrees.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue initializer for queue\n     * @param inDegreeMap initializer for inDegreeMap\n     *\n     * @return start vertex\n     */\n    private static <V, E> V initialize(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        for (Iterator<V> i = dg.vertexSet().iterator(); i.hasNext();) {\n            V vertex = i.next();\n\n            int inDegree = dg.inDegreeOf(vertex);\n            inDegreeMap.put(vertex, new ModifiableInteger(inDegree));\n\n            if (inDegree == 0) {\n                queue.offer(vertex);\n            }\n        }\n\n        if (queue.isEmpty()) {\n            return null;\n        } else {\n            return queue.peek();\n        }\n    }\n\n    // NOTE jvs 22-Dec-2006:  For JDK1.4-compatibility, we can't assume\n    // that LinkedList implements Queue, since that wasn't introduced\n    // until JDK1.5, so use an adapter here.  Move this to\n    // top-level in org.jgrapht.util if anyone else needs it.\n    private static class LinkedListQueue<T>\n        extends LinkedList<T>\n        implements Queue<T>\n    {\n        private static final long serialVersionUID = 4217659843476891334L;\n\n        @Override public T element()\n        {\n            return getFirst();\n        }\n\n        @Override public boolean offer(T o)\n        {\n            return add(o);\n        }\n\n        @Override public T peek()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return getFirst();\n        }\n\n        @Override public T poll()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return removeFirst();\n        }\n\n        @Override public T remove()\n        {\n            return removeFirst();\n        }\n    }\n}\n\n// End TopologicalOrderIterator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "\"http://mathworld.wolfram.com/Source.html\"", "String" ] ],
  "tokensMethodArguments" : [ [ "dg", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ], [ "queue", "java.util.Queue", "Queue<V>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getSeenData", "org.jgrapht.traverse", "CrossComponentIterator", "protected D getSeenData(V arg0)" ], [ "next", "org.jgrapht.traverse", "CrossComponentIterator", "public V next()" ], [ "isSeenVertex", "org.jgrapht.traverse", "CrossComponentIterator", "protected boolean isSeenVertex(Object arg0)" ], [ "isCrossComponentTraversal", "org.jgrapht.traverse", "AbstractGraphIterator", "public boolean isCrossComponentTraversal()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "isReuseEvents", "org.jgrapht.traverse", "AbstractGraphIterator", "public boolean isReuseEvents()" ], [ "getGraph", "org.jgrapht.traverse", "CrossComponentIterator", "public Graph<V, E> getGraph()" ], [ "putSeenData", "org.jgrapht.traverse", "CrossComponentIterator", "protected D putSeenData(V arg0, D arg1)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "provideNextVertex", "org.jgrapht.traverse", "TopologicalOrderIterator", "protected V provideNextVertex()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "next", "java.util", "Iterator", "public abstract E next()" ], [ "isConnectedComponentExhausted", "org.jgrapht.traverse", "TopologicalOrderIterator", "protected boolean isConnectedComponentExhausted()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hasNext", "org.jgrapht.traverse", "CrossComponentIterator", "public boolean hasNext()" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "element", "java.util", "Queue", "public abstract E element()" ], [ "add", "java.util", "Queue", "public abstract boolean add(E arg0)" ], [ "poll", "java.util", "Queue", "public abstract E poll()" ], [ "remove", "java.util", "Queue", "public abstract E remove()" ], [ "offer", "java.util", "Queue", "public abstract boolean offer(E arg0)" ], [ "peek", "java.util", "Queue", "public abstract E peek()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "nListeners", "org.jgrapht.traverse", "AbstractGraphIterator", "protected int nListeners;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25731,
  "oracle" : "(((targetGraph==null)==false) && (targetGraph.containsEdge(edge))) == false ? methodResultID == true : methodResultID == false;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graphs",
  "javadocTag" : "@return <tt>true</tt> if the target graph did not already contain the\nspecified edge.",
  "methodJavadoc" : "    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */",
  "methodSourceCode" : "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge){\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}",
  "classJavadoc" : "/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "targetGraph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "sourceGraph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "edge", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25732,
  "oracle" : "((vertices==null)==false) && (vertices.contains(null)) || vertices==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graphs",
  "javadocTag" : "@throws NullPointerException if the specified vertices contains one or\nmore null vertices, or if the specified vertex collection is <tt>\nnull</tt>.",
  "methodJavadoc" : "    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */",
  "methodSourceCode" : "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices){\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}",
  "classJavadoc" : "/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "destination", "org.jgrapht.Graph", "Graph<? super V, ? super E>" ], [ "vertices", "java.util.Collection", "Collection<? extends V>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25733,
  "oracle" : "(g instanceof DirectedGraph)==false && (g instanceof UndirectedGraph)==false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graphs",
  "javadocTag" : "@throws IllegalArgumentException if the graph is neither DirectedGraph\nnor UndirectedGraph.",
  "methodJavadoc" : "    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */",
  "methodSourceCode" : "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g){\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}",
  "classJavadoc" : "/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * Graphs.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Mikael Hansen\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\nimport org.jgrapht.graph.*;\n\n\n/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n */\npublic abstract class Graphs\n{\n    /**\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     */\n    public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        // we first create the edge and set the weight to make sure that\n        // listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true</tt> if the target graph did not already contain the\n     * specified edge.\n     */\n    public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }\n\n    /**\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     */\n    public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true</code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false</code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true</code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     */\n    public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.</p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     */\n    public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }\n\n    /**\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     */\n    public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true</tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     */\n    public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }\n\n    /**\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     */\n    public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }\n\n    /**\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     */\n    public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    /**\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     */\n    public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }\n\n    /**\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     */\n    public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }\n\n    /**\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     */\n    public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }\n}\n\n// End Graphs.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "g", "org.jgrapht.Graph", "Graph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "degreeOf", "org.jgrapht", "UndirectedGraph", "public abstract int degreeOf(V arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25734,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "HawickJamesSimpleCycles",
  "javadocTag" : "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public HawickJamesSimpleCycles(DirectedGraph<V, E> graph) throws IllegalArgumentException{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}",
  "classJavadoc" : "/**\n * Find all simple cycles of a directed graph using the algorithm described by\n * Hawick and James.\n *\n * <p>See:<br>\n * K. A. Hawick, H. A. James. Enumerating Circuits and Loops in Graphs with\n * Self-Arcs and Multiple-Arcs. Computational Science Technical Note CSTN-013,\n * 2008\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Luiz Kill\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * HawickAndJamesSimpleCycles.java\n * -------------------------\n * (C) Copyright 2014, by Luiz Kill\n *\n * Original Author: Luiz Kill.\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 18-Jun-2014 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Find all simple cycles of a directed graph using the algorithm described by\n * Hawick and James.\n *\n * <p>See:<br>\n * K. A. Hawick, H. A. James. Enumerating Circuits and Loops in Graphs with\n * Self-Arcs and Multiple-Arcs. Computational Science Technical Note CSTN-013,\n * 2008\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Luiz Kill\n */\npublic class HawickJamesSimpleCycles<V, E>\n    implements DirectedSimpleCycles<V, E>\n{\n    private enum Operation\n    {\n        ENUMERATE, PRINT_ONLY, COUNT_ONLY\n    }\n\n    // The graph\n    private DirectedGraph<V, E> graph = null;\n\n    // Number of vertices\n    private int nVertices = 0;\n\n    // Number of simple cycles\n    private long nCycles = 0;\n\n    // Simple cycles found\n    private List<List<V>> cycles = null;\n\n    // The main state of the algorithm\n    private Integer start = 0;\n    private List<Integer> [] Ak = null;\n    private List<Integer> [] B = null;\n    private boolean [] blocked = null;\n    private ArrayDeque<Integer> stack = null;\n\n    // Giving an index to every V\n    private V [] iToV = null;\n    private Map<V, Integer> vToI = null;\n\n    /**\n     * Create a simple cycle finder with an unspecified graph.\n     */\n    public HawickJamesSimpleCycles()\n    {\n    }\n\n    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */\n    public HawickJamesSimpleCycles(DirectedGraph<V, E> graph)\n        throws IllegalArgumentException\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void initState(Operation o)\n    {\n        nCycles = 0;\n        nVertices = graph.vertexSet().size();\n        if (o == Operation.ENUMERATE) {\n            cycles = new ArrayList<List<V>>();\n        }\n        blocked = new boolean[nVertices];\n        stack = new ArrayDeque<Integer>(nVertices);\n\n        B = new ArrayList[nVertices];\n        for (int i = 0; i < nVertices; i++) {\n            //B[i] = new ArrayList<Integer>(nVertices);\n            B[i] = new ArrayList<Integer>();\n        }\n\n        iToV = (V []) graph.vertexSet().toArray();\n        vToI = new HashMap<V, Integer>();\n        for (int i = 0; i < iToV.length; i++) {\n            vToI.put(iToV[i], i);\n        }\n\n        Ak = buildAdjacencyList();\n\n        stack.clear();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private List<Integer> [] buildAdjacencyList()\n    {\n        @SuppressWarnings(\"rawtypes\")\n        List [] Ak = new ArrayList[nVertices];\n        for (int j = 0; j < nVertices; j++) {\n            V v = iToV[j];\n            List<V> s = Graphs.successorListOf(graph, v);\n            Ak[j] = new ArrayList<Integer>(s.size());\n\n            Iterator<V> iterator = s.iterator();\n            while (iterator.hasNext()) {\n                Ak[j].add(vToI.get(iterator.next()));\n            }\n        }\n\n        return Ak;\n    }\n\n    private void clearState()\n    {\n        Ak = null;\n        nVertices = 0;\n        blocked = null;\n        stack = null;\n        iToV = null;\n        vToI = null;\n\n        for (int i = 0; i < nVertices; i++) {\n            Ak[i] = null;\n            B[i] = null;\n        }\n\n        Ak = null;\n        B = null;\n    }\n\n    private boolean circuit(Integer v, Operation o)\n    {\n        boolean f = false;\n\n        stack.push(v);\n        blocked[v] = true;\n\n        Iterator<Integer> iteratorAk = Ak[v].iterator();\n        while (iteratorAk.hasNext()) {\n            Integer w = iteratorAk.next();\n\n            if (w < start) {\n                continue;\n            }\n\n            if (w == start) {\n                if (o == Operation.ENUMERATE) {\n                    List<V> cycle = new ArrayList<V>(stack.size());\n\n                    Iterator<Integer> iteratorStack = stack.iterator();\n                    while (iteratorStack.hasNext()) {\n                        cycle.add(iToV[iteratorStack.next()]);\n                    }\n\n                    cycles.add(cycle);\n                }\n\n                if (o == Operation.PRINT_ONLY) {\n                    for (Integer i : stack) {\n                        System.out.print(iToV[i].toString() + \" \");\n                    }\n                    System.out.println(\"\");\n                }\n\n                nCycles++;\n\n                f = true;\n            } else if (!blocked[w]) {\n                if (circuit(w, o)) {\n                    f = true;\n                }\n            }\n        }\n\n        if (f) {\n            unblock(v);\n        } else {\n            iteratorAk = Ak[v].iterator();\n            while (iteratorAk.hasNext()) {\n                Integer w = iteratorAk.next();\n\n                if (w < start) {\n                    continue;\n                }\n\n                if (!B[w].contains(v)) {\n                    B[w].add(v);\n                }\n            }\n        }\n\n        stack.pop();\n\n        return f;\n    }\n\n    private void unblock(Integer u)\n    {\n        blocked[u] = false;\n\n        for (int wPos = 0; wPos < B[u].size(); wPos++) {\n            Integer w = B[u].get(wPos);\n\n            wPos -= removeFromList(B[u], w);\n\n            if (blocked[w]) {\n                unblock(w);\n            }\n        }\n    }\n\n    /**\n     * Remove all occurrences of a value from the list.\n     *\n     * @param u the Integer to be removed.\n     * @param list the list from which all the occurrences of u must be removed.\n     */\n    private int removeFromList(List<Integer> list, Integer u)\n    {\n        int nOccurrences = 0;\n\n        Iterator<Integer> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            Integer w = iterator.next();\n            if (w == u) {\n                nOccurrences++;\n                iterator.remove();\n            }\n        }\n\n        return nOccurrences;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void setGraph(DirectedGraph<V, E> graph)\n        throws IllegalArgumentException\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public List<List<V>> findSimpleCycles()\n        throws IllegalArgumentException\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n\n        initState(Operation.ENUMERATE);\n\n        for (int i = 0; i < nVertices; i++) {\n            for (int j = 0; j < nVertices; j++) {\n                blocked[j] = false;\n                B[j].clear();\n            }\n\n            start = vToI.get(iToV[i]);\n            circuit(start, Operation.ENUMERATE);\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }\n\n    /**\n     * Print to the standard output all simple cycles without building a list to\n     * keep them, thus avoiding high memory consumption when investigating large\n     * and much connected graphs.\n     */\n    public void printSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n\n        initState(Operation.PRINT_ONLY);\n\n        for (int i = 0; i < nVertices; i++) {\n            for (int j = 0; j < nVertices; j++) {\n                blocked[j] = false;\n                B[j].clear();\n            }\n\n            start = vToI.get(iToV[i]);\n            circuit(start, Operation.PRINT_ONLY);\n        }\n\n        clearState();\n    }\n\n    /**\n     * Count the number of simple cycles. It can count up to Long.MAX cycles in\n     * a graph.\n     */\n    public long countSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n\n        initState(Operation.COUNT_ONLY);\n\n        for (int i = 0; i < nVertices; i++) {\n            for (int j = 0; j < nVertices; j++) {\n                blocked[j] = false;\n                B[j].clear();\n            }\n\n            start = vToI.get(iToV[i]);\n            circuit(start, Operation.COUNT_ONLY);\n        }\n\n        clearState();\n\n        return nCycles;\n    }\n}\n\n// End HawickAndJamesSimpleCycles.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "countSimpleCycles", "org.jgrapht.alg.cycle", "HawickJamesSimpleCycles", "public long countSimpleCycles()" ], [ "getGraph", "org.jgrapht.alg.cycle", "HawickJamesSimpleCycles", "public DirectedGraph<V, E> getGraph()" ], [ "findSimpleCycles", "org.jgrapht.alg.cycle", "HawickJamesSimpleCycles", "public List<List<V>> findSimpleCycles() throws IllegalArgumentException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25735,
  "oracle" : "g==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "GraphDelegator",
  "javadocTag" : "@throws IllegalArgumentException iff <code>g==null</code>",
  "methodJavadoc" : "    /**\n     * Constructor for GraphDelegator.\n     *\n     * @param g the backing graph (the delegate).\n     *\n     * @throws IllegalArgumentException iff <code>g==null</code>\n     */",
  "methodSourceCode" : "public GraphDelegator(Graph<V, E> g){\n    super();\n    if (g == null) {\n        throw new IllegalArgumentException(\"g must not be null.\");\n    }\n    delegate = g;\n}",
  "classJavadoc" : "/**\n * A graph backed by the the graph specified at the constructor, which delegates\n * all its methods to the backing graph. Operations on this graph \"pass through\"\n * to the to the backing graph. Any modification made to this graph or the\n * backing graph is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * <p>This class is mostly used as a base for extending subclasses.</p>\n *\n * @author Barak Naveh\n * @since Jul 20, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * GraphDelegator.java\n * -------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A graph backed by the the graph specified at the constructor, which delegates\n * all its methods to the backing graph. Operations on this graph \"pass through\"\n * to the to the backing graph. Any modification made to this graph or the\n * backing graph is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * <p>This class is mostly used as a base for extending subclasses.</p>\n *\n * @author Barak Naveh\n * @since Jul 20, 2003\n */\npublic class GraphDelegator<V, E>\n    extends AbstractGraph<V, E>\n    implements Graph<V, E>,\n        Serializable\n{\n    private static final long serialVersionUID = 3257005445226181425L;\n\n    /**\n     * The graph to which operations are delegated.\n     */\n    private Graph<V, E> delegate;\n\n    /**\n     * Constructor for GraphDelegator.\n     *\n     * @param g the backing graph (the delegate).\n     *\n     * @throws IllegalArgumentException iff <code>g==null</code>\n     */\n    public GraphDelegator(Graph<V, E> g)\n    {\n        super();\n\n        if (g == null) {\n            throw new IllegalArgumentException(\"g must not be null.\");\n        }\n\n        delegate = g;\n    }\n\n    /**\n     * @see Graph#getAllEdges(Object, Object)\n     */\n    @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        return delegate.getAllEdges(sourceVertex, targetVertex);\n    }\n\n    /**\n     * @see Graph#getEdge(Object, Object)\n     */\n    @Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        return delegate.getEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * @see Graph#getEdgeFactory()\n     */\n    @Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return delegate.getEdgeFactory();\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        return delegate.addEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        return delegate.addEdge(sourceVertex, targetVertex, e);\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        return delegate.addVertex(v);\n    }\n\n    /**\n     * @see Graph#containsEdge(Object)\n     */\n    @Override public boolean containsEdge(E e)\n    {\n        return delegate.containsEdge(e);\n    }\n\n    /**\n     * @see Graph#containsVertex(Object)\n     */\n    @Override public boolean containsVertex(V v)\n    {\n        return delegate.containsVertex(v);\n    }\n\n    /**\n     * @see UndirectedGraph#degreeOf(Object)\n     */\n    public int degreeOf(V vertex)\n    {\n        return ((UndirectedGraph<V, E>) delegate).degreeOf(vertex);\n    }\n\n    /**\n     * @see Graph#edgeSet()\n     */\n    @Override public Set<E> edgeSet()\n    {\n        return delegate.edgeSet();\n    }\n\n    /**\n     * @see Graph#edgesOf(Object)\n     */\n    @Override public Set<E> edgesOf(V vertex)\n    {\n        return delegate.edgesOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#inDegreeOf(Object)\n     */\n    public int inDegreeOf(V vertex)\n    {\n        return ((DirectedGraph<V, ? extends E>) delegate).inDegreeOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     */\n    public Set<E> incomingEdgesOf(V vertex)\n    {\n        return ((DirectedGraph<V, E>) delegate).incomingEdgesOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#outDegreeOf(Object)\n     */\n    public int outDegreeOf(V vertex)\n    {\n        return ((DirectedGraph<V, ? extends E>) delegate).outDegreeOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     */\n    public Set<E> outgoingEdgesOf(V vertex)\n    {\n        return ((DirectedGraph<V, E>) delegate).outgoingEdgesOf(vertex);\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        return delegate.removeEdge(e);\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        return delegate.removeEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        return delegate.removeVertex(v);\n    }\n\n    /**\n     * @see java.lang.Object#toString()\n     */\n    @Override public String toString()\n    {\n        return delegate.toString();\n    }\n\n    /**\n     * @see Graph#vertexSet()\n     */\n    @Override public Set<V> vertexSet()\n    {\n        return delegate.vertexSet();\n    }\n\n    /**\n     * @see Graph#getEdgeSource(Object)\n     */\n    @Override public V getEdgeSource(E e)\n    {\n        return delegate.getEdgeSource(e);\n    }\n\n    /**\n     * @see Graph#getEdgeTarget(Object)\n     */\n    @Override public V getEdgeTarget(E e)\n    {\n        return delegate.getEdgeTarget(e);\n    }\n\n    /**\n     * @see Graph#getEdgeWeight(Object)\n     */\n    @Override public double getEdgeWeight(E e)\n    {\n        return delegate.getEdgeWeight(e);\n    }\n\n    /**\n     * @see WeightedGraph#setEdgeWeight(Object, double)\n     */\n    public void setEdgeWeight(E e, double weight)\n    {\n        ((WeightedGraph<V, E>) delegate).setEdgeWeight(e, weight);\n    }\n}\n\n// End GraphDelegator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "g", "org.jgrapht.Graph", "Graph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "containsEdge", "org.jgrapht.graph", "GraphDelegator", "public boolean containsEdge(E e)" ], [ "getAllEdges", "org.jgrapht.graph", "GraphDelegator", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "edgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgesOf(V vertex)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "vertexSet", "org.jgrapht.graph", "GraphDelegator", "public Set<V> vertexSet()" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "addEdge", "org.jgrapht.graph", "GraphDelegator", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht.graph", "GraphDelegator", "public boolean addVertex(V v)" ], [ "getEdge", "org.jgrapht.graph", "GraphDelegator", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getEdgeTarget", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeTarget(E e)" ], [ "getEdgeFactory", "org.jgrapht.graph", "GraphDelegator", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht.graph", "GraphDelegator", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> outgoingEdgesOf(V vertex)" ], [ "removeEdge", "org.jgrapht.graph", "GraphDelegator", "public boolean removeEdge(E e)" ], [ "containsVertex", "org.jgrapht.graph", "GraphDelegator", "public boolean containsVertex(V v)" ], [ "inDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int inDegreeOf(V vertex)" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "getEdgeSource", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeSource(E e)" ], [ "edgeSet", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgeSet()" ], [ "toString", "org.jgrapht.graph", "GraphDelegator", "public String toString()" ], [ "removeVertex", "org.jgrapht.graph", "GraphDelegator", "public boolean removeVertex(V v)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "incomingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> incomingEdgesOf(V vertex)" ], [ "degreeOf", "org.jgrapht.graph", "GraphDelegator", "public int degreeOf(V vertex)" ], [ "getEdgeWeight", "org.jgrapht.graph", "GraphDelegator", "public double getEdgeWeight(E e)" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "addEdge", "org.jgrapht.graph", "GraphDelegator", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "outDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int outDegreeOf(V vertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25736,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "DirectedSimpleCycles",
  "javadocTag" : "@throws IllegalArgumentException if the argument is <code>null</code>.",
  "methodJavadoc" : "    /**\n     * Sets the graph on which the simple cycle search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */",
  "methodSourceCode" : "void setGraph(DirectedGraph<V, E> graph);",
  "classJavadoc" : "/**\n * A common interface for classes implementing algorithms for enumeration of the\n * simple cycles of a directed graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * DirectedSimpleCycles.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A common interface for classes implementing algorithms for enumeration of the\n * simple cycles of a directed graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic interface DirectedSimpleCycles<V, E>\n{\n    /**\n     * Returns the graph on which the simple cycle search algorithm is executed\n     * by this object.\n     *\n     * @return The graph.\n     */\n    DirectedGraph<V, E> getGraph();\n\n    /**\n     * Sets the graph on which the simple cycle search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */\n    void setGraph(DirectedGraph<V, E> graph);\n\n    /**\n     * Finds the simple cycles of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return The list of all simple cycles. Possibly empty but never <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     */\n    List<List<V>> findSimpleCycles();\n}\n\n// End DirectedSimpleCycles.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getGraph", "org.jgrapht.alg.cycle", "DirectedSimpleCycles", "DirectedGraph<V, E> getGraph()" ], [ "findSimpleCycles", "org.jgrapht.alg.cycle", "DirectedSimpleCycles", "List<List<V>> findSimpleCycles()" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25737,
  "oracle" : "this.getGraph()==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "DirectedSimpleCycles",
  "javadocTag" : "@throws IllegalArgumentException if the current graph is null.",
  "methodJavadoc" : "    /**\n     * Finds the simple cycles of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return The list of all simple cycles. Possibly empty but never <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     */",
  "methodSourceCode" : "List<List<V>> findSimpleCycles();",
  "classJavadoc" : "/**\n * A common interface for classes implementing algorithms for enumeration of the\n * simple cycles of a directed graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * DirectedSimpleCycles.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A common interface for classes implementing algorithms for enumeration of the\n * simple cycles of a directed graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic interface DirectedSimpleCycles<V, E>\n{\n    /**\n     * Returns the graph on which the simple cycle search algorithm is executed\n     * by this object.\n     *\n     * @return The graph.\n     */\n    DirectedGraph<V, E> getGraph();\n\n    /**\n     * Sets the graph on which the simple cycle search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */\n    void setGraph(DirectedGraph<V, E> graph);\n\n    /**\n     * Finds the simple cycles of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return The list of all simple cycles. Possibly empty but never <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     */\n    List<List<V>> findSimpleCycles();\n}\n\n// End DirectedSimpleCycles.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getGraph", "org.jgrapht.alg.cycle", "DirectedSimpleCycles", "DirectedGraph<V, E> getGraph()" ], [ "findSimpleCycles", "org.jgrapht.alg.cycle", "DirectedSimpleCycles", "List<List<V>> findSimpleCycles()" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ] ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25738,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "SzwarcfiterLauerSimpleCycles",
  "javadocTag" : "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public SzwarcfiterLauerSimpleCycles(DirectedGraph<V, E> graph){\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}",
  "classJavadoc" : "/**\n * Find all simple cycles of a directed graph using the Schwarcfiter and Lauer's\n * algorithm.\n *\n * <p>See:<br>\n * J.L.Szwarcfiter and P.E.Lauer, Finding the elementary cycles of a directed\n * graph in O(n + m) per cycle, Technical Report Series, #60, May 1974, Univ. of\n * Newcastle upon Tyne, Newcastle upon Tyne, England.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * SzwarcfiterLauerSimpleCycles.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.alg.*;\n\n\n/**\n * Find all simple cycles of a directed graph using the Schwarcfiter and Lauer's\n * algorithm.\n *\n * <p>See:<br>\n * J.L.Szwarcfiter and P.E.Lauer, Finding the elementary cycles of a directed\n * graph in O(n + m) per cycle, Technical Report Series, #60, May 1974, Univ. of\n * Newcastle upon Tyne, Newcastle upon Tyne, England.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic class SzwarcfiterLauerSimpleCycles<V, E>\n    implements DirectedSimpleCycles<V, E>\n{\n    // The graph.\n    private DirectedGraph<V, E> graph;\n\n    // The state of the algorithm.\n    private List<List<V>> cycles = null;\n    private V [] iToV = null;\n    private Map<V, Integer> vToI = null;\n    private Map<V, Set<V>> bSets = null;\n    private ArrayDeque<V> stack = null;\n    private Set<V> marked = null;\n    private Map<V, Set<V>> removed = null;\n    private int [] position = null;\n    private boolean [] reach = null;\n    private List<V> startVertices = null;\n\n    /**\n     * Create a simple cycle finder with an unspecified graph.\n     */\n    public SzwarcfiterLauerSimpleCycles()\n    {\n    }\n\n    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */\n    public SzwarcfiterLauerSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public List<List<V>> findSimpleCycles()\n    {\n        // Just a straightforward implementation of\n        // the algorithm.\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        initState();\n        KosarajuStrongConnectivityInspector<V, E> inspector =\n            new KosarajuStrongConnectivityInspector<V, E>(graph);\n        List<Set<V>> sccs = inspector.stronglyConnectedSets();\n        for (Set<V> scc : sccs) {\n            int maxInDegree = -1;\n            V startVertex = null;\n            for (V v : scc) {\n                int inDegree = graph.inDegreeOf(v);\n                if (inDegree > maxInDegree) {\n                    maxInDegree = inDegree;\n                    startVertex = v;\n                }\n            }\n            startVertices.add(startVertex);\n        }\n\n        for (V vertex : startVertices) {\n            cycle(toI(vertex), 0);\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }\n\n    private boolean cycle(int v, int q)\n    {\n        boolean foundCycle = false;\n        V vV = toV(v);\n        marked.add(vV);\n        stack.push(vV);\n        int t = stack.size();\n        position[v] = t;\n        if (!reach[v]) {\n            q = t;\n        }\n        Set<V> avRemoved = getRemoved(vV);\n        Set<E> edgeSet = graph.outgoingEdgesOf(vV);\n        Iterator<E> avIt = edgeSet.iterator();\n        while (avIt.hasNext()) {\n            E e = avIt.next();\n            V wV = graph.getEdgeTarget(e);\n            if (avRemoved.contains(wV)) {\n                continue;\n            }\n            int w = toI(wV);\n            if (!marked.contains(wV)) {\n                boolean gotCycle = cycle(w, q);\n                if (gotCycle) {\n                    foundCycle = gotCycle;\n                } else {\n                    noCycle(v, w);\n                }\n            } else if (position[w] <= q) {\n                foundCycle = true;\n                List<V> cycle = new ArrayList<V>();\n                Iterator<V> it = stack.descendingIterator();\n                V current = null;\n                while (it.hasNext()) {\n                    current = it.next();\n                    if (wV.equals(current)) {\n                        break;\n                    }\n                }\n                cycle.add(wV);\n                while (it.hasNext()) {\n                    current = it.next();\n                    cycle.add(current);\n                    if (current.equals(vV)) {\n                        break;\n                    }\n                }\n                cycles.add(cycle);\n            } else {\n                noCycle(v, w);\n            }\n        }\n        stack.pop();\n        if (foundCycle) {\n            unmark(v);\n        }\n        reach[v] = true;\n        position[v] = graph.vertexSet().size();\n        return foundCycle;\n    }\n\n    private void noCycle(int x, int y)\n    {\n        V xV = toV(x);\n        V yV = toV(y);\n\n        Set<V> by = getBSet(yV);\n        Set<V> axRemoved = getRemoved(xV);\n\n        by.add(xV);\n        axRemoved.add(yV);\n    }\n\n    private void unmark(int x)\n    {\n        V xV = toV(x);\n        marked.remove(xV);\n        Set<V> bx = getBSet(xV);\n        for (V yV : bx) {\n            Set<V> ayRemoved = getRemoved(yV);\n            ayRemoved.remove(xV);\n            if (marked.contains(yV)) {\n                unmark(toI(yV));\n            }\n        }\n        bx.clear();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void initState()\n    {\n        cycles = new ArrayList<List<V>>();\n        iToV = (V []) graph.vertexSet().toArray();\n        vToI = new HashMap<V, Integer>();\n        bSets = new HashMap<V, Set<V>>();\n        stack = new ArrayDeque<V>();\n        marked = new HashSet<V>();\n        removed = new HashMap<V, Set<V>>();\n        int size = graph.vertexSet().size();\n        position = new int[size];\n        reach = new boolean[size];\n        startVertices = new ArrayList<V>();\n\n        for (int i = 0; i < iToV.length; i++) {\n            vToI.put(iToV[i], i);\n        }\n    }\n\n    private void clearState()\n    {\n        cycles = null;\n        iToV = null;\n        vToI = null;\n        bSets = null;\n        stack = null;\n        marked = null;\n        removed = null;\n        position = null;\n        reach = null;\n        startVertices = null;\n    }\n\n    private Integer toI(V v)\n    {\n        return vToI.get(v);\n    }\n\n    private V toV(int i)\n    {\n        return iToV[i];\n    }\n\n    private Set<V> getBSet(V v)\n    {\n        // B sets are typically not all\n        // needed, so instantiate lazily.\n        Set<V> result = bSets.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            bSets.put(v, result);\n        }\n        return result;\n    }\n\n    private Set<V> getRemoved(V v)\n    {\n        // Removed sets typically not all\n        // needed, so instantiate lazily.\n        Set<V> result = removed.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            removed.put(v, result);\n        }\n        return result;\n    }\n}\n\n// End SzwarcfiterLauerSimpleCycles.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getGraph", "org.jgrapht.alg.cycle", "SzwarcfiterLauerSimpleCycles", "public DirectedGraph<V, E> getGraph()" ], [ "findSimpleCycles", "org.jgrapht.alg.cycle", "SzwarcfiterLauerSimpleCycles", "public List<List<V>> findSimpleCycles()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25739,
  "oracle" : "this.addEdge(source,target,edge);",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "DefaultListenableGraph",
  "javadocTag" : "@param edge the edge that was added.",
  "methodJavadoc" : "    /**\n     * Notify listeners that the specified edge was added.\n     *\n     * @param edge the edge that was added.\n     * @param source edge source\n     * @param target edge target\n     */",
  "methodSourceCode" : "protected void fireEdgeAdded(E edge, V source, V target){\n    GraphEdgeChangeEvent<V, E> e = createGraphEdgeChangeEvent(GraphEdgeChangeEvent.EDGE_ADDED, edge, source, target);\n    for (GraphListener<V, E> l : graphListeners) {\n        l.edgeAdded(e);\n    }\n}",
  "classJavadoc" : "/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * DefaultListenableGraph.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 04-Aug-2003 : Strong refs to listeners instead of weak refs (BN);\n * 10-Aug-2003 : Adaptation to new event model (BN);\n * 07-Mar-2004 : Fixed unnecessary clone bug #819075 (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */\npublic class DefaultListenableGraph<V, E>\n    extends GraphDelegator<V, E>\n    implements ListenableGraph<V, E>,\n        Cloneable\n{\n    private static final long serialVersionUID = 3977575900898471984L;\n\n    private List<GraphListener<V, E>> graphListeners =\n        new ArrayList<GraphListener<V, E>>();\n    private List<VertexSetListener<V>> vertexSetListeners =\n        new ArrayList<VertexSetListener<V>>();\n    private FlyweightEdgeEvent<V, E> reuseableEdgeEvent;\n    private FlyweightVertexEvent<V> reuseableVertexEvent;\n    private boolean reuseEvents;\n\n    /**\n     * Creates a new listenable graph.\n     *\n     * @param g the backing graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g)\n    {\n        this(g, false);\n    }\n\n    /**\n     * Creates a new listenable graph. If the <code>reuseEvents</code> flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @param g the backing graph.\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     *\n     * @throws IllegalArgumentException if the backing graph is already a\n     * listenable graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents)\n    {\n        super(g);\n        this.reuseEvents = reuseEvents;\n        reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n        reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n\n        // the following restriction could be probably relaxed in the future.\n        if (g instanceof ListenableGraph<?, ?>) {\n            throw new IllegalArgumentException(\n                \"base graph cannot be listenable\");\n        }\n    }\n\n    /**\n     * If the <code>reuseEvents</code> flag is set to <code>true</code> this\n     * class will reuse previously fired events and will not create a new object\n     * for each event. This option increases performance but should be used with\n     * care, especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     */\n    public void setReuseEvents(boolean reuseEvents)\n    {\n        this.reuseEvents = reuseEvents;\n    }\n\n    /**\n     * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents</code> flag.\n     */\n    public boolean isReuseEvents()\n    {\n        return reuseEvents;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.addEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        boolean added = super.addEdge(sourceVertex, targetVertex, e);\n\n        if (added) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return added;\n    }\n\n    /**\n     * @see ListenableGraph#addGraphListener(GraphListener)\n     */\n    @Override public void addGraphListener(GraphListener<V, E> l)\n    {\n        addToListenerList(graphListeners, l);\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean modified = super.addVertex(v);\n\n        if (modified) {\n            fireVertexAdded(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#addVertexSetListener(VertexSetListener)\n     */\n    @Override public void addVertexSetListener(VertexSetListener<V> l)\n    {\n        addToListenerList(vertexSetListeners, l);\n    }\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override public Object clone()\n    {\n        try {\n            TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n\n            DefaultListenableGraph<V, E> g =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n            g.graphListeners = new ArrayList<GraphListener<V, E>>();\n            g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n\n            return g;\n        } catch (CloneNotSupportedException e) {\n            // should never get here since we're Cloneable\n            e.printStackTrace();\n            throw new RuntimeException(\"internal error\");\n        }\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.removeEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        V sourceVertex = getEdgeSource(e);\n        V targetVertex = getEdgeTarget(e);\n\n        boolean modified = super.removeEdge(e);\n\n        if (modified) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#removeGraphListener(GraphListener)\n     */\n    @Override public void removeGraphListener(GraphListener<V, E> l)\n    {\n        graphListeners.remove(l);\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            // copy set to avoid ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            super.removeVertex(v); // remove the vertex itself\n\n            fireVertexRemoved(v);\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see ListenableGraph#removeVertexSetListener(VertexSetListener)\n     */\n    @Override public void removeVertexSetListener(VertexSetListener<V> l)\n    {\n        vertexSetListeners.remove(l);\n    }\n\n    /**\n     * Notify listeners that the specified edge was added.\n     *\n     * @param edge the edge that was added.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeAdded(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_ADDED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified edge was removed.\n     *\n     * @param edge the edge that was removed.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeRemoved(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_REMOVED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeRemoved(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was added.\n     *\n     * @param vertex the vertex that was added.\n     */\n    protected void fireVertexAdded(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_ADDED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexAdded(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was removed.\n     *\n     * @param vertex the vertex that was removed.\n     */\n    protected void fireVertexRemoved(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_REMOVED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexRemoved(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexRemoved(e);\n        }\n    }\n\n    private static <L extends EventListener> void addToListenerList(\n        List<L> list,\n        L l)\n    {\n        if (!list.contains(l)) {\n            list.add(l);\n        }\n    }\n\n    private GraphEdgeChangeEvent<V, E> createGraphEdgeChangeEvent(\n        int eventType,\n        E edge,\n        V source,\n        V target)\n    {\n        if (reuseEvents) {\n            reuseableEdgeEvent.setType(eventType);\n            reuseableEdgeEvent.setEdge(edge);\n            reuseableEdgeEvent.setEdgeSource(source);\n            reuseableEdgeEvent.setEdgeTarget(target);\n\n            return reuseableEdgeEvent;\n        } else {\n            return new GraphEdgeChangeEvent<V, E>(\n                this,\n                eventType,\n                edge,\n                source,\n                target);\n        }\n    }\n\n    private GraphVertexChangeEvent<V> createGraphVertexChangeEvent(\n        int eventType,\n        V vertex)\n    {\n        if (reuseEvents) {\n            reuseableVertexEvent.setType(eventType);\n            reuseableVertexEvent.setVertex(vertex);\n\n            return reuseableVertexEvent;\n        } else {\n            return new GraphVertexChangeEvent<V>(this, eventType, vertex);\n        }\n    }\n\n    /**\n     * A reuseable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightEdgeEvent<VV, EE>\n        extends GraphEdgeChangeEvent<VV, EE>\n    {\n        private static final long serialVersionUID = 3907207152526636089L;\n\n        /**\n         * @see GraphEdgeChangeEvent#GraphEdgeChangeEvent(Object, int, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, int type, EE e)\n        {\n            super(eventSource, type, e);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param e the edge to be set.\n         */\n        protected void setEdge(EE e)\n        {\n            this.edge = e;\n        }\n\n        protected void setEdgeSource(VV v)\n        {\n            this.edgeSource = v;\n        }\n\n        protected void setEdgeTarget(VV v)\n        {\n            this.edgeTarget = v;\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type the type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n    }\n\n    /**\n     * A reuseable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightVertexEvent<VV>\n        extends GraphVertexChangeEvent<VV>\n    {\n        private static final long serialVersionUID = 3257848787857585716L;\n\n        /**\n         * @see GraphVertexChangeEvent#GraphVertexChangeEvent(Object, int,\n         * Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, int type, VV vertex)\n        {\n            super(eventSource, type, vertex);\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n}\n\n// End DefaultListenableGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "edge", "", "E" ], [ "source", "", "V" ], [ "target", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "isReuseEvents", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean isReuseEvents()" ], [ "edgeSet", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgeSet()" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "removeVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeVertex(V v)" ], [ "getAllEdges", "org.jgrapht.graph", "GraphDelegator", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeTarget(E arg0)" ], [ "inDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int inDegreeOf(V arg0)" ], [ "getEdgeWeight", "org.jgrapht.graph", "GraphDelegator", "public double getEdgeWeight(E arg0)" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "outDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int outDegreeOf(V arg0)" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "clone", "org.jgrapht.graph", "DefaultListenableGraph", "public Object clone()" ], [ "getEdge", "org.jgrapht.graph", "GraphDelegator", "public E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht.graph", "GraphDelegator", "public boolean containsEdge(E arg0)" ], [ "toString", "org.jgrapht.graph", "GraphDelegator", "public String toString()" ], [ "vertexSet", "org.jgrapht.graph", "GraphDelegator", "public Set<V> vertexSet()" ], [ "degreeOf", "org.jgrapht.graph", "GraphDelegator", "public int degreeOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getEdgeFactory", "org.jgrapht.graph", "GraphDelegator", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "incomingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> incomingEdgesOf(V arg0)" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeEdge(E e)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "addVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addVertex(V v)" ], [ "getEdgeSource", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeSource(E arg0)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "containsVertex", "org.jgrapht.graph", "GraphDelegator", "public boolean containsVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "edgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgesOf(V arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25740,
  "oracle" : "this.removeEdge(edge);",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "DefaultListenableGraph",
  "javadocTag" : "@param edge the edge that was removed.",
  "methodJavadoc" : "    /**\n     * Notify listeners that the specified edge was removed.\n     *\n     * @param edge the edge that was removed.\n     * @param source edge source\n     * @param target edge target\n     */",
  "methodSourceCode" : "protected void fireEdgeRemoved(E edge, V source, V target){\n    GraphEdgeChangeEvent<V, E> e = createGraphEdgeChangeEvent(GraphEdgeChangeEvent.EDGE_REMOVED, edge, source, target);\n    for (GraphListener<V, E> l : graphListeners) {\n        l.edgeRemoved(e);\n    }\n}",
  "classJavadoc" : "/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * DefaultListenableGraph.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 04-Aug-2003 : Strong refs to listeners instead of weak refs (BN);\n * 10-Aug-2003 : Adaptation to new event model (BN);\n * 07-Mar-2004 : Fixed unnecessary clone bug #819075 (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */\npublic class DefaultListenableGraph<V, E>\n    extends GraphDelegator<V, E>\n    implements ListenableGraph<V, E>,\n        Cloneable\n{\n    private static final long serialVersionUID = 3977575900898471984L;\n\n    private List<GraphListener<V, E>> graphListeners =\n        new ArrayList<GraphListener<V, E>>();\n    private List<VertexSetListener<V>> vertexSetListeners =\n        new ArrayList<VertexSetListener<V>>();\n    private FlyweightEdgeEvent<V, E> reuseableEdgeEvent;\n    private FlyweightVertexEvent<V> reuseableVertexEvent;\n    private boolean reuseEvents;\n\n    /**\n     * Creates a new listenable graph.\n     *\n     * @param g the backing graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g)\n    {\n        this(g, false);\n    }\n\n    /**\n     * Creates a new listenable graph. If the <code>reuseEvents</code> flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @param g the backing graph.\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     *\n     * @throws IllegalArgumentException if the backing graph is already a\n     * listenable graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents)\n    {\n        super(g);\n        this.reuseEvents = reuseEvents;\n        reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n        reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n\n        // the following restriction could be probably relaxed in the future.\n        if (g instanceof ListenableGraph<?, ?>) {\n            throw new IllegalArgumentException(\n                \"base graph cannot be listenable\");\n        }\n    }\n\n    /**\n     * If the <code>reuseEvents</code> flag is set to <code>true</code> this\n     * class will reuse previously fired events and will not create a new object\n     * for each event. This option increases performance but should be used with\n     * care, especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     */\n    public void setReuseEvents(boolean reuseEvents)\n    {\n        this.reuseEvents = reuseEvents;\n    }\n\n    /**\n     * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents</code> flag.\n     */\n    public boolean isReuseEvents()\n    {\n        return reuseEvents;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.addEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        boolean added = super.addEdge(sourceVertex, targetVertex, e);\n\n        if (added) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return added;\n    }\n\n    /**\n     * @see ListenableGraph#addGraphListener(GraphListener)\n     */\n    @Override public void addGraphListener(GraphListener<V, E> l)\n    {\n        addToListenerList(graphListeners, l);\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean modified = super.addVertex(v);\n\n        if (modified) {\n            fireVertexAdded(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#addVertexSetListener(VertexSetListener)\n     */\n    @Override public void addVertexSetListener(VertexSetListener<V> l)\n    {\n        addToListenerList(vertexSetListeners, l);\n    }\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override public Object clone()\n    {\n        try {\n            TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n\n            DefaultListenableGraph<V, E> g =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n            g.graphListeners = new ArrayList<GraphListener<V, E>>();\n            g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n\n            return g;\n        } catch (CloneNotSupportedException e) {\n            // should never get here since we're Cloneable\n            e.printStackTrace();\n            throw new RuntimeException(\"internal error\");\n        }\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.removeEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        V sourceVertex = getEdgeSource(e);\n        V targetVertex = getEdgeTarget(e);\n\n        boolean modified = super.removeEdge(e);\n\n        if (modified) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#removeGraphListener(GraphListener)\n     */\n    @Override public void removeGraphListener(GraphListener<V, E> l)\n    {\n        graphListeners.remove(l);\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            // copy set to avoid ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            super.removeVertex(v); // remove the vertex itself\n\n            fireVertexRemoved(v);\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see ListenableGraph#removeVertexSetListener(VertexSetListener)\n     */\n    @Override public void removeVertexSetListener(VertexSetListener<V> l)\n    {\n        vertexSetListeners.remove(l);\n    }\n\n    /**\n     * Notify listeners that the specified edge was added.\n     *\n     * @param edge the edge that was added.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeAdded(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_ADDED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified edge was removed.\n     *\n     * @param edge the edge that was removed.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeRemoved(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_REMOVED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeRemoved(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was added.\n     *\n     * @param vertex the vertex that was added.\n     */\n    protected void fireVertexAdded(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_ADDED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexAdded(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was removed.\n     *\n     * @param vertex the vertex that was removed.\n     */\n    protected void fireVertexRemoved(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_REMOVED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexRemoved(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexRemoved(e);\n        }\n    }\n\n    private static <L extends EventListener> void addToListenerList(\n        List<L> list,\n        L l)\n    {\n        if (!list.contains(l)) {\n            list.add(l);\n        }\n    }\n\n    private GraphEdgeChangeEvent<V, E> createGraphEdgeChangeEvent(\n        int eventType,\n        E edge,\n        V source,\n        V target)\n    {\n        if (reuseEvents) {\n            reuseableEdgeEvent.setType(eventType);\n            reuseableEdgeEvent.setEdge(edge);\n            reuseableEdgeEvent.setEdgeSource(source);\n            reuseableEdgeEvent.setEdgeTarget(target);\n\n            return reuseableEdgeEvent;\n        } else {\n            return new GraphEdgeChangeEvent<V, E>(\n                this,\n                eventType,\n                edge,\n                source,\n                target);\n        }\n    }\n\n    private GraphVertexChangeEvent<V> createGraphVertexChangeEvent(\n        int eventType,\n        V vertex)\n    {\n        if (reuseEvents) {\n            reuseableVertexEvent.setType(eventType);\n            reuseableVertexEvent.setVertex(vertex);\n\n            return reuseableVertexEvent;\n        } else {\n            return new GraphVertexChangeEvent<V>(this, eventType, vertex);\n        }\n    }\n\n    /**\n     * A reuseable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightEdgeEvent<VV, EE>\n        extends GraphEdgeChangeEvent<VV, EE>\n    {\n        private static final long serialVersionUID = 3907207152526636089L;\n\n        /**\n         * @see GraphEdgeChangeEvent#GraphEdgeChangeEvent(Object, int, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, int type, EE e)\n        {\n            super(eventSource, type, e);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param e the edge to be set.\n         */\n        protected void setEdge(EE e)\n        {\n            this.edge = e;\n        }\n\n        protected void setEdgeSource(VV v)\n        {\n            this.edgeSource = v;\n        }\n\n        protected void setEdgeTarget(VV v)\n        {\n            this.edgeTarget = v;\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type the type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n    }\n\n    /**\n     * A reuseable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightVertexEvent<VV>\n        extends GraphVertexChangeEvent<VV>\n    {\n        private static final long serialVersionUID = 3257848787857585716L;\n\n        /**\n         * @see GraphVertexChangeEvent#GraphVertexChangeEvent(Object, int,\n         * Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, int type, VV vertex)\n        {\n            super(eventSource, type, vertex);\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n}\n\n// End DefaultListenableGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "edge", "", "E" ], [ "source", "", "V" ], [ "target", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdgeFactory", "org.jgrapht.graph", "GraphDelegator", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "getEdgeTarget", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeTarget(E arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "edgeSet", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgeSet()" ], [ "containsVertex", "org.jgrapht.graph", "GraphDelegator", "public boolean containsVertex(V arg0)" ], [ "isReuseEvents", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean isReuseEvents()" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "outDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int outDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> incomingEdgesOf(V arg0)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "getEdge", "org.jgrapht.graph", "GraphDelegator", "public E getEdge(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht.graph", "GraphDelegator", "public Set<V> vertexSet()" ], [ "toString", "org.jgrapht.graph", "GraphDelegator", "public String toString()" ], [ "removeVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeVertex(V v)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht.graph", "GraphDelegator", "public boolean containsEdge(E arg0)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeEdge(E e)" ], [ "degreeOf", "org.jgrapht.graph", "GraphDelegator", "public int degreeOf(V arg0)" ], [ "getAllEdges", "org.jgrapht.graph", "GraphDelegator", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "inDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int inDegreeOf(V arg0)" ], [ "getEdgeWeight", "org.jgrapht.graph", "GraphDelegator", "public double getEdgeWeight(E arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "edgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgesOf(V arg0)" ], [ "getEdgeSource", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeSource(E arg0)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "clone", "org.jgrapht.graph", "DefaultListenableGraph", "public Object clone()" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "addVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addVertex(V v)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25741,
  "oracle" : "this.addVertex(vertex);",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "DefaultListenableGraph",
  "javadocTag" : "@param vertex the vertex that was added.",
  "methodJavadoc" : "    /**\n     * Notify listeners that the specified vertex was added.\n     *\n     * @param vertex the vertex that was added.\n     */",
  "methodSourceCode" : "protected void fireVertexAdded(V vertex){\n    GraphVertexChangeEvent<V> e = createGraphVertexChangeEvent(GraphVertexChangeEvent.VERTEX_ADDED, vertex);\n    for (VertexSetListener<V> l : vertexSetListeners) {\n        l.vertexAdded(e);\n    }\n    for (GraphListener<V, E> l : graphListeners) {\n        l.vertexAdded(e);\n    }\n}",
  "classJavadoc" : "/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * DefaultListenableGraph.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 04-Aug-2003 : Strong refs to listeners instead of weak refs (BN);\n * 10-Aug-2003 : Adaptation to new event model (BN);\n * 07-Mar-2004 : Fixed unnecessary clone bug #819075 (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */\npublic class DefaultListenableGraph<V, E>\n    extends GraphDelegator<V, E>\n    implements ListenableGraph<V, E>,\n        Cloneable\n{\n    private static final long serialVersionUID = 3977575900898471984L;\n\n    private List<GraphListener<V, E>> graphListeners =\n        new ArrayList<GraphListener<V, E>>();\n    private List<VertexSetListener<V>> vertexSetListeners =\n        new ArrayList<VertexSetListener<V>>();\n    private FlyweightEdgeEvent<V, E> reuseableEdgeEvent;\n    private FlyweightVertexEvent<V> reuseableVertexEvent;\n    private boolean reuseEvents;\n\n    /**\n     * Creates a new listenable graph.\n     *\n     * @param g the backing graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g)\n    {\n        this(g, false);\n    }\n\n    /**\n     * Creates a new listenable graph. If the <code>reuseEvents</code> flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @param g the backing graph.\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     *\n     * @throws IllegalArgumentException if the backing graph is already a\n     * listenable graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents)\n    {\n        super(g);\n        this.reuseEvents = reuseEvents;\n        reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n        reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n\n        // the following restriction could be probably relaxed in the future.\n        if (g instanceof ListenableGraph<?, ?>) {\n            throw new IllegalArgumentException(\n                \"base graph cannot be listenable\");\n        }\n    }\n\n    /**\n     * If the <code>reuseEvents</code> flag is set to <code>true</code> this\n     * class will reuse previously fired events and will not create a new object\n     * for each event. This option increases performance but should be used with\n     * care, especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     */\n    public void setReuseEvents(boolean reuseEvents)\n    {\n        this.reuseEvents = reuseEvents;\n    }\n\n    /**\n     * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents</code> flag.\n     */\n    public boolean isReuseEvents()\n    {\n        return reuseEvents;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.addEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        boolean added = super.addEdge(sourceVertex, targetVertex, e);\n\n        if (added) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return added;\n    }\n\n    /**\n     * @see ListenableGraph#addGraphListener(GraphListener)\n     */\n    @Override public void addGraphListener(GraphListener<V, E> l)\n    {\n        addToListenerList(graphListeners, l);\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean modified = super.addVertex(v);\n\n        if (modified) {\n            fireVertexAdded(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#addVertexSetListener(VertexSetListener)\n     */\n    @Override public void addVertexSetListener(VertexSetListener<V> l)\n    {\n        addToListenerList(vertexSetListeners, l);\n    }\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override public Object clone()\n    {\n        try {\n            TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n\n            DefaultListenableGraph<V, E> g =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n            g.graphListeners = new ArrayList<GraphListener<V, E>>();\n            g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n\n            return g;\n        } catch (CloneNotSupportedException e) {\n            // should never get here since we're Cloneable\n            e.printStackTrace();\n            throw new RuntimeException(\"internal error\");\n        }\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.removeEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        V sourceVertex = getEdgeSource(e);\n        V targetVertex = getEdgeTarget(e);\n\n        boolean modified = super.removeEdge(e);\n\n        if (modified) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#removeGraphListener(GraphListener)\n     */\n    @Override public void removeGraphListener(GraphListener<V, E> l)\n    {\n        graphListeners.remove(l);\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            // copy set to avoid ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            super.removeVertex(v); // remove the vertex itself\n\n            fireVertexRemoved(v);\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see ListenableGraph#removeVertexSetListener(VertexSetListener)\n     */\n    @Override public void removeVertexSetListener(VertexSetListener<V> l)\n    {\n        vertexSetListeners.remove(l);\n    }\n\n    /**\n     * Notify listeners that the specified edge was added.\n     *\n     * @param edge the edge that was added.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeAdded(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_ADDED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified edge was removed.\n     *\n     * @param edge the edge that was removed.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeRemoved(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_REMOVED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeRemoved(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was added.\n     *\n     * @param vertex the vertex that was added.\n     */\n    protected void fireVertexAdded(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_ADDED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexAdded(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was removed.\n     *\n     * @param vertex the vertex that was removed.\n     */\n    protected void fireVertexRemoved(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_REMOVED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexRemoved(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexRemoved(e);\n        }\n    }\n\n    private static <L extends EventListener> void addToListenerList(\n        List<L> list,\n        L l)\n    {\n        if (!list.contains(l)) {\n            list.add(l);\n        }\n    }\n\n    private GraphEdgeChangeEvent<V, E> createGraphEdgeChangeEvent(\n        int eventType,\n        E edge,\n        V source,\n        V target)\n    {\n        if (reuseEvents) {\n            reuseableEdgeEvent.setType(eventType);\n            reuseableEdgeEvent.setEdge(edge);\n            reuseableEdgeEvent.setEdgeSource(source);\n            reuseableEdgeEvent.setEdgeTarget(target);\n\n            return reuseableEdgeEvent;\n        } else {\n            return new GraphEdgeChangeEvent<V, E>(\n                this,\n                eventType,\n                edge,\n                source,\n                target);\n        }\n    }\n\n    private GraphVertexChangeEvent<V> createGraphVertexChangeEvent(\n        int eventType,\n        V vertex)\n    {\n        if (reuseEvents) {\n            reuseableVertexEvent.setType(eventType);\n            reuseableVertexEvent.setVertex(vertex);\n\n            return reuseableVertexEvent;\n        } else {\n            return new GraphVertexChangeEvent<V>(this, eventType, vertex);\n        }\n    }\n\n    /**\n     * A reuseable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightEdgeEvent<VV, EE>\n        extends GraphEdgeChangeEvent<VV, EE>\n    {\n        private static final long serialVersionUID = 3907207152526636089L;\n\n        /**\n         * @see GraphEdgeChangeEvent#GraphEdgeChangeEvent(Object, int, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, int type, EE e)\n        {\n            super(eventSource, type, e);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param e the edge to be set.\n         */\n        protected void setEdge(EE e)\n        {\n            this.edge = e;\n        }\n\n        protected void setEdgeSource(VV v)\n        {\n            this.edgeSource = v;\n        }\n\n        protected void setEdgeTarget(VV v)\n        {\n            this.edgeTarget = v;\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type the type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n    }\n\n    /**\n     * A reuseable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightVertexEvent<VV>\n        extends GraphVertexChangeEvent<VV>\n    {\n        private static final long serialVersionUID = 3257848787857585716L;\n\n        /**\n         * @see GraphVertexChangeEvent#GraphVertexChangeEvent(Object, int,\n         * Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, int type, VV vertex)\n        {\n            super(eventSource, type, vertex);\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n}\n\n// End DefaultListenableGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdgeWeight", "org.jgrapht.graph", "GraphDelegator", "public double getEdgeWeight(E arg0)" ], [ "getEdgeTarget", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeTarget(E arg0)" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "degreeOf", "org.jgrapht.graph", "GraphDelegator", "public int degreeOf(V arg0)" ], [ "vertexSet", "org.jgrapht.graph", "GraphDelegator", "public Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "containsVertex", "org.jgrapht.graph", "GraphDelegator", "public boolean containsVertex(V arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "org.jgrapht.graph", "DefaultListenableGraph", "public Object clone()" ], [ "getEdgeFactory", "org.jgrapht.graph", "GraphDelegator", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "outDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int outDegreeOf(V arg0)" ], [ "containsEdge", "org.jgrapht.graph", "GraphDelegator", "public boolean containsEdge(E arg0)" ], [ "getEdge", "org.jgrapht.graph", "GraphDelegator", "public E getEdge(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeVertex(V v)" ], [ "inDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int inDegreeOf(V arg0)" ], [ "isReuseEvents", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean isReuseEvents()" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "getEdgeSource", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeSource(E arg0)" ], [ "toString", "org.jgrapht.graph", "GraphDelegator", "public String toString()" ], [ "incomingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> incomingEdgesOf(V arg0)" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeEdge(E e)" ], [ "edgeSet", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgeSet()" ], [ "getAllEdges", "org.jgrapht.graph", "GraphDelegator", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgesOf(V arg0)" ], [ "addVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addVertex(V v)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25742,
  "oracle" : "this.removeVertex(vertex);",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "DefaultListenableGraph",
  "javadocTag" : "@param vertex the vertex that was removed.",
  "methodJavadoc" : "    /**\n     * Notify listeners that the specified vertex was removed.\n     *\n     * @param vertex the vertex that was removed.\n     */",
  "methodSourceCode" : "protected void fireVertexRemoved(V vertex){\n    GraphVertexChangeEvent<V> e = createGraphVertexChangeEvent(GraphVertexChangeEvent.VERTEX_REMOVED, vertex);\n    for (VertexSetListener<V> l : vertexSetListeners) {\n        l.vertexRemoved(e);\n    }\n    for (GraphListener<V, E> l : graphListeners) {\n        l.vertexRemoved(e);\n    }\n}",
  "classJavadoc" : "/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------------\n * DefaultListenableGraph.java\n * ---------------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 04-Aug-2003 : Strong refs to listeners instead of weak refs (BN);\n * 10-Aug-2003 : Adaptation to new event model (BN);\n * 07-Mar-2004 : Fixed unnecessary clone bug #819075 (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.event.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener</code> s and by <code>\n * VertexSetListener</code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not</i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object</tt>'s <tt>equals</tt> and\n * <tt>hashCode</tt> methods.</p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n */\npublic class DefaultListenableGraph<V, E>\n    extends GraphDelegator<V, E>\n    implements ListenableGraph<V, E>,\n        Cloneable\n{\n    private static final long serialVersionUID = 3977575900898471984L;\n\n    private List<GraphListener<V, E>> graphListeners =\n        new ArrayList<GraphListener<V, E>>();\n    private List<VertexSetListener<V>> vertexSetListeners =\n        new ArrayList<VertexSetListener<V>>();\n    private FlyweightEdgeEvent<V, E> reuseableEdgeEvent;\n    private FlyweightVertexEvent<V> reuseableVertexEvent;\n    private boolean reuseEvents;\n\n    /**\n     * Creates a new listenable graph.\n     *\n     * @param g the backing graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g)\n    {\n        this(g, false);\n    }\n\n    /**\n     * Creates a new listenable graph. If the <code>reuseEvents</code> flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @param g the backing graph.\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     *\n     * @throws IllegalArgumentException if the backing graph is already a\n     * listenable graph.\n     */\n    public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents)\n    {\n        super(g);\n        this.reuseEvents = reuseEvents;\n        reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n        reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n\n        // the following restriction could be probably relaxed in the future.\n        if (g instanceof ListenableGraph<?, ?>) {\n            throw new IllegalArgumentException(\n                \"base graph cannot be listenable\");\n        }\n    }\n\n    /**\n     * If the <code>reuseEvents</code> flag is set to <code>true</code> this\n     * class will reuse previously fired events and will not create a new object\n     * for each event. This option increases performance but should be used with\n     * care, especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     */\n    public void setReuseEvents(boolean reuseEvents)\n    {\n        this.reuseEvents = reuseEvents;\n    }\n\n    /**\n     * Tests whether the <code>reuseEvents</code> flag is set. If the flag is\n     * set to <code>true</code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents</code> flag.\n     */\n    public boolean isReuseEvents()\n    {\n        return reuseEvents;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.addEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        boolean added = super.addEdge(sourceVertex, targetVertex, e);\n\n        if (added) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return added;\n    }\n\n    /**\n     * @see ListenableGraph#addGraphListener(GraphListener)\n     */\n    @Override public void addGraphListener(GraphListener<V, E> l)\n    {\n        addToListenerList(graphListeners, l);\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean modified = super.addVertex(v);\n\n        if (modified) {\n            fireVertexAdded(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#addVertexSetListener(VertexSetListener)\n     */\n    @Override public void addVertexSetListener(VertexSetListener<V> l)\n    {\n        addToListenerList(vertexSetListeners, l);\n    }\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override public Object clone()\n    {\n        try {\n            TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n\n            DefaultListenableGraph<V, E> g =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n            g.graphListeners = new ArrayList<GraphListener<V, E>>();\n            g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n\n            return g;\n        } catch (CloneNotSupportedException e) {\n            // should never get here since we're Cloneable\n            e.printStackTrace();\n            throw new RuntimeException(\"internal error\");\n        }\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.removeEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        V sourceVertex = getEdgeSource(e);\n        V targetVertex = getEdgeTarget(e);\n\n        boolean modified = super.removeEdge(e);\n\n        if (modified) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see ListenableGraph#removeGraphListener(GraphListener)\n     */\n    @Override public void removeGraphListener(GraphListener<V, E> l)\n    {\n        graphListeners.remove(l);\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            // copy set to avoid ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            super.removeVertex(v); // remove the vertex itself\n\n            fireVertexRemoved(v);\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see ListenableGraph#removeVertexSetListener(VertexSetListener)\n     */\n    @Override public void removeVertexSetListener(VertexSetListener<V> l)\n    {\n        vertexSetListeners.remove(l);\n    }\n\n    /**\n     * Notify listeners that the specified edge was added.\n     *\n     * @param edge the edge that was added.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeAdded(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_ADDED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified edge was removed.\n     *\n     * @param edge the edge that was removed.\n     * @param source edge source\n     * @param target edge target\n     */\n    protected void fireEdgeRemoved(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_REMOVED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeRemoved(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was added.\n     *\n     * @param vertex the vertex that was added.\n     */\n    protected void fireVertexAdded(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_ADDED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexAdded(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexAdded(e);\n        }\n    }\n\n    /**\n     * Notify listeners that the specified vertex was removed.\n     *\n     * @param vertex the vertex that was removed.\n     */\n    protected void fireVertexRemoved(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_REMOVED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexRemoved(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexRemoved(e);\n        }\n    }\n\n    private static <L extends EventListener> void addToListenerList(\n        List<L> list,\n        L l)\n    {\n        if (!list.contains(l)) {\n            list.add(l);\n        }\n    }\n\n    private GraphEdgeChangeEvent<V, E> createGraphEdgeChangeEvent(\n        int eventType,\n        E edge,\n        V source,\n        V target)\n    {\n        if (reuseEvents) {\n            reuseableEdgeEvent.setType(eventType);\n            reuseableEdgeEvent.setEdge(edge);\n            reuseableEdgeEvent.setEdgeSource(source);\n            reuseableEdgeEvent.setEdgeTarget(target);\n\n            return reuseableEdgeEvent;\n        } else {\n            return new GraphEdgeChangeEvent<V, E>(\n                this,\n                eventType,\n                edge,\n                source,\n                target);\n        }\n    }\n\n    private GraphVertexChangeEvent<V> createGraphVertexChangeEvent(\n        int eventType,\n        V vertex)\n    {\n        if (reuseEvents) {\n            reuseableVertexEvent.setType(eventType);\n            reuseableVertexEvent.setVertex(vertex);\n\n            return reuseableVertexEvent;\n        } else {\n            return new GraphVertexChangeEvent<V>(this, eventType, vertex);\n        }\n    }\n\n    /**\n     * A reuseable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightEdgeEvent<VV, EE>\n        extends GraphEdgeChangeEvent<VV, EE>\n    {\n        private static final long serialVersionUID = 3907207152526636089L;\n\n        /**\n         * @see GraphEdgeChangeEvent#GraphEdgeChangeEvent(Object, int, Edge)\n         */\n        public FlyweightEdgeEvent(Object eventSource, int type, EE e)\n        {\n            super(eventSource, type, e);\n        }\n\n        /**\n         * Sets the edge of this event.\n         *\n         * @param e the edge to be set.\n         */\n        protected void setEdge(EE e)\n        {\n            this.edge = e;\n        }\n\n        protected void setEdgeSource(VV v)\n        {\n            this.edgeSource = v;\n        }\n\n        protected void setEdgeTarget(VV v)\n        {\n            this.edgeTarget = v;\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type the type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n    }\n\n    /**\n     * A reuseable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     */\n    private static class FlyweightVertexEvent<VV>\n        extends GraphVertexChangeEvent<VV>\n    {\n        private static final long serialVersionUID = 3257848787857585716L;\n\n        /**\n         * @see GraphVertexChangeEvent#GraphVertexChangeEvent(Object, int,\n         * Object)\n         */\n        public FlyweightVertexEvent(Object eventSource, int type, VV vertex)\n        {\n            super(eventSource, type, vertex);\n        }\n\n        /**\n         * Set the event type of this event.\n         *\n         * @param type type to be set.\n         */\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n\n        /**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         */\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }\n}\n\n// End DefaultListenableGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "inDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int inDegreeOf(V arg0)" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "clone", "org.jgrapht.graph", "DefaultListenableGraph", "public Object clone()" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "toString", "org.jgrapht.graph", "GraphDelegator", "public String toString()" ], [ "incomingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> incomingEdgesOf(V arg0)" ], [ "containsEdge", "org.jgrapht.graph", "GraphDelegator", "public boolean containsEdge(E arg0)" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "containsVertex", "org.jgrapht.graph", "GraphDelegator", "public boolean containsVertex(V arg0)" ], [ "getAllEdges", "org.jgrapht.graph", "GraphDelegator", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht.graph", "GraphDelegator", "public E getEdge(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeSource(E arg0)" ], [ "degreeOf", "org.jgrapht.graph", "GraphDelegator", "public int degreeOf(V arg0)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "getEdgeWeight", "org.jgrapht.graph", "GraphDelegator", "public double getEdgeWeight(E arg0)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "edgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgesOf(V arg0)" ], [ "isReuseEvents", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean isReuseEvents()" ], [ "outDegreeOf", "org.jgrapht.graph", "GraphDelegator", "public int outDegreeOf(V arg0)" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeVertex(V v)" ], [ "getEdgeTarget", "org.jgrapht.graph", "GraphDelegator", "public V getEdgeTarget(E arg0)" ], [ "vertexSet", "org.jgrapht.graph", "GraphDelegator", "public Set<V> vertexSet()" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean removeEdge(E e)" ], [ "addVertex", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addVertex(V v)" ], [ "edgeSet", "org.jgrapht.graph", "GraphDelegator", "public Set<E> edgeSet()" ], [ "removeEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeFactory", "org.jgrapht.graph", "GraphDelegator", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "addEdge", "org.jgrapht.graph", "DefaultListenableGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "GraphDelegator", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25743,
  "oracle" : "size<0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.generate",
  "className" : "CompleteGraphGenerator",
  "javadocTag" : "@throws IllegalArgumentException if the specified size is negative.",
  "methodJavadoc" : "    /**\n     * Construct a new CompleteGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */",
  "methodSourceCode" : "public CompleteGraphGenerator(int size){\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}",
  "classJavadoc" : "/**\n * Generates a complete graph of any size. A complete graph is a graph where\n * every vertex shares an edge with every other vertex. If it is a directed\n * graph, then edges must always exist in both directions. On a side note, a\n * complete graph is the least efficient possible graph in terms of memory and\n * cpu usage. Note: This contructor was designed for a simple undirected or\n * directed graph. It will act strangely when used with certain graph types,\n * such as undirected multigraphs. Note, though, that a complete undirected\n * multigraph is rather senseless -- you can keep adding edges and the graph is\n * never truly complete.\n *\n * @author Tim Shearouse\n * @since Nov 02, 2008\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * CompleteGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by Tim Shearouse and Contributors.\n *\n * Original Author:  Tim Shearouse\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 10-Feb-2008 : Initial revision (TS);\n *\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Generates a complete graph of any size. A complete graph is a graph where\n * every vertex shares an edge with every other vertex. If it is a directed\n * graph, then edges must always exist in both directions. On a side note, a\n * complete graph is the least efficient possible graph in terms of memory and\n * cpu usage. Note: This contructor was designed for a simple undirected or\n * directed graph. It will act strangely when used with certain graph types,\n * such as undirected multigraphs. Note, though, that a complete undirected\n * multigraph is rather senseless -- you can keep adding edges and the graph is\n * never truly complete.\n *\n * @author Tim Shearouse\n * @since Nov 02, 2008\n */\npublic class CompleteGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    private int size;\n\n    /**\n     * Construct a new CompleteGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */\n    public CompleteGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (size < 1) {\n            return;\n        }\n\n        //Add all the vertices to the set\n        for (int i = 0; i < size; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n        }\n\n        /*\n         * We want two iterators over the vertex set, one fast and one slow.\n         * The slow one will move through the set once. For each vertex,\n         * the fast iterator moves through the set, adding an edge to all\n         * vertices we haven't connected to yet.\n         *\n         * If we have an undirected graph, the second addEdge call will return\n         * nothing; it will not add a second edge.\n         */\n        Iterator<V> slowI = target.vertexSet().iterator();\n        Iterator<V> fastI;\n\n        while (slowI.hasNext()) { //While there are more vertices in the set\n\n            V latestVertex = slowI.next();\n            fastI = target.vertexSet().iterator();\n\n            //Jump to the first vertex *past* latestVertex\n            while (fastI.next() != latestVertex) {\n                ;\n            }\n\n            //And, add edges to all remaining vertices\n            V temp;\n            while (fastI.hasNext()) {\n                temp = fastI.next();\n                target.addEdge(latestVertex, temp);\n                target.addEdge(temp, latestVertex);\n            }\n        }\n    }\n}\n\n// End CompleteGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "size", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25744,
  "oracle" : "size<0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.generate",
  "className" : "EmptyGraphGenerator",
  "javadocTag" : "@throws IllegalArgumentException if the specified size is negative.",
  "methodJavadoc" : "    /**\n     * Construct a new EmptyGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */",
  "methodSourceCode" : "public EmptyGraphGenerator(int size){\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}",
  "classJavadoc" : "/**\n * Generates an <a href=\"http://mathworld.wolfram.com/EmptyGraph.html\">empty\n * graph</a> of any size. An empty graph is a graph that has no edges.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * EmptyGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 16-Sep-2003 : Initial revision (JVS);\n *\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Generates an <a href=\"http://mathworld.wolfram.com/EmptyGraph.html\">empty\n * graph</a> of any size. An empty graph is a graph that has no edges.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */\npublic class EmptyGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    private int size;\n\n    /**\n     * Construct a new EmptyGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */\n    public EmptyGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        for (int i = 0; i < size; ++i) {\n            target.addVertex(vertexFactory.createVertex());\n        }\n    }\n}\n\n// End EmptyGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "size", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25745,
  "oracle" : "this.containsVertex(sourceVertex)==false || this.containsVertex(targetVertex)==false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws IllegalArgumentException if source or target vertices are not\nfound in the graph.",
  "methodJavadoc" : "    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */",
  "methodSourceCode" : "public E addEdge(V sourceVertex, V targetVertex);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "2", "int" ], [ "2", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "sourceVertex", "", "V" ], [ "targetVertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25746,
  "oracle" : "sourceVertex==null || targetVertex==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws NullPointerException if any of the specified vertices is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */",
  "methodSourceCode" : "public E addEdge(V sourceVertex, V targetVertex);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "2", "int" ], [ "2", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "sourceVertex", "", "V" ], [ "targetVertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25747,
  "oracle" : "this.containsVertex(sourceVertex)==false || this.containsVertex(targetVertex)==false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws IllegalArgumentException if source or target vertices are not\nfound in the graph.",
  "methodJavadoc" : "    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */",
  "methodSourceCode" : "public boolean addEdge(V sourceVertex, V targetVertex, E e);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "2", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "sourceVertex", "", "V" ], [ "targetVertex", "", "V" ], [ "e", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25748,
  "oracle" : "sourceVertex==null || targetVertex==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws NullPointerException if any of the specified vertices is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */",
  "methodSourceCode" : "public boolean addEdge(V sourceVertex, V targetVertex, E e);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "2", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "sourceVertex", "", "V" ], [ "targetVertex", "", "V" ], [ "e", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25749,
  "oracle" : "(this.containsEdge(sourceVertex,targetVertex)) == false ? methodResultID == true : methodResultID == false;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@return <tt>true</tt> if this graph did not already contain the specified\nedge.",
  "methodJavadoc" : "    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */",
  "methodSourceCode" : "public boolean addEdge(V sourceVertex, V targetVertex, E e);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "2", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "sourceVertex", "", "V" ], [ "targetVertex", "", "V" ], [ "e", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25750,
  "oracle" : "v==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws NullPointerException if the specified vertex is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public boolean addVertex(V v);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "v", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25751,
  "oracle" : "(this.containsVertex(v)) == false ? methodResultID == true : methodResultID == false;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@return <tt>true</tt> if this graph did not already contain the specified\nvertex.",
  "methodJavadoc" : "    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public boolean addVertex(V v);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "v", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25752,
  "oracle" : "(this.containsVertex(vertex)) == false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws IllegalArgumentException if vertex is not found in the graph.",
  "methodJavadoc" : "    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */",
  "methodSourceCode" : "public Set<E> edgesOf(V vertex);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeAll", "java.util", "Set", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "Set", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Set", "public abstract <T> T[] toArray(T[] arg0)" ], [ "isEmpty", "java.util", "Set", "public abstract boolean isEmpty()" ], [ "size", "java.util", "Set", "public abstract int size()" ], [ "equals", "java.util", "Set", "public abstract boolean equals(Object arg0)" ], [ "spliterator", "java.util", "Set", "public default Spliterator<E> spliterator()" ], [ "addAll", "java.util", "Set", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "hashCode", "java.util", "Set", "public abstract int hashCode()" ], [ "toArray", "java.util", "Set", "public abstract Object[] toArray()" ], [ "remove", "java.util", "Set", "public abstract boolean remove(Object arg0)" ], [ "iterator", "java.util", "Set", "public abstract Iterator<E> iterator()" ], [ "retainAll", "java.util", "Set", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "contains", "java.util", "Set", "public abstract boolean contains(Object arg0)" ], [ "add", "java.util", "Set", "public abstract boolean add(E arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25753,
  "oracle" : "vertex==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws NullPointerException if vertex is <code>null</code>.",
  "methodJavadoc" : "    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */",
  "methodSourceCode" : "public Set<E> edgesOf(V vertex);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.util", "Set", "public abstract int hashCode()" ], [ "size", "java.util", "Set", "public abstract int size()" ], [ "remove", "java.util", "Set", "public abstract boolean remove(Object arg0)" ], [ "addAll", "java.util", "Set", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "retainAll", "java.util", "Set", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "removeAll", "java.util", "Set", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "isEmpty", "java.util", "Set", "public abstract boolean isEmpty()" ], [ "spliterator", "java.util", "Set", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "Set", "public abstract Object[] toArray()" ], [ "contains", "java.util", "Set", "public abstract boolean contains(Object arg0)" ], [ "toArray", "java.util", "Set", "public abstract <T> T[] toArray(T[] arg0)" ], [ "containsAll", "java.util", "Set", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "equals", "java.util", "Set", "public abstract boolean equals(Object arg0)" ], [ "add", "java.util", "Set", "public abstract boolean add(E arg0)" ], [ "iterator", "java.util", "Set", "public abstract Iterator<E> iterator()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25754,
  "oracle" : "edges==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws NullPointerException if the specified edge collection is <tt>\nnull</tt>.",
  "methodJavadoc" : "    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */",
  "methodSourceCode" : "public boolean removeAllEdges(Collection<? extends E> edges);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "edges", "java.util.Collection", "Collection<? extends E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25755,
  "oracle" : "vertices==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@throws NullPointerException if the specified vertex collection is <tt>\nnull</tt>.",
  "methodJavadoc" : "    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */",
  "methodSourceCode" : "public boolean removeAllVertices(Collection<? extends V> vertices);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertices", "java.util.Collection", "Collection<? extends V>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25756,
  "oracle" : "this.containsEdge(e) ? methodResultID == true : methodResultID == false;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@return <code>true</code> if and only if the graph contained the\nspecified edge.",
  "methodJavadoc" : "    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */",
  "methodSourceCode" : "public boolean removeEdge(E e);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "2", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "e", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25757,
  "oracle" : "this.containsVertex(v) ? methodResultID == true : methodResultID == false;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht",
  "className" : "Graph",
  "javadocTag" : "@return <code>true</code> if the graph contained the specified vertex;\n<code>false</code> otherwise.",
  "methodJavadoc" : "    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */",
  "methodSourceCode" : "public boolean removeVertex(V v);",
  "classJavadoc" : "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "v", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addEdge", "org.jgrapht", "Graph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "edgesOf", "org.jgrapht", "Graph", "public Set<E> edgesOf(V vertex)" ], [ "addEdge", "org.jgrapht", "Graph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public V getEdgeSource(E e)" ], [ "containsVertex", "org.jgrapht", "Graph", "public boolean containsVertex(V v)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeVertex", "org.jgrapht", "Graph", "public boolean removeVertex(V v)" ], [ "addVertex", "org.jgrapht", "Graph", "public boolean addVertex(V v)" ], [ "removeEdge", "org.jgrapht", "Graph", "public boolean removeEdge(E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "vertexSet", "org.jgrapht", "Graph", "public Set<V> vertexSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public V getEdgeTarget(E e)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public double getEdgeWeight(E e)" ], [ "containsEdge", "org.jgrapht", "Graph", "public boolean containsEdge(E e)" ], [ "edgeSet", "org.jgrapht", "Graph", "public Set<E> edgeSet()" ], [ "getEdge", "org.jgrapht", "Graph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "removeEdge", "org.jgrapht", "Graph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25758,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "TiernanSimpleCycles",
  "javadocTag" : "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public TiernanSimpleCycles(DirectedGraph<V, E> graph){\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}",
  "classJavadoc" : "/**\n * Find all simple cycles of a directed graph using the Tiernan's algorithm.\n *\n * <p>See:<br>\n * J.C.Tiernan An Efficient Search Algorithm Find the Elementary Circuits of a\n * Graph., Communications of the ACM, vol.13, 12, (1970), pp. 722 - 726.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * TiernanSimpleCycles.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Find all simple cycles of a directed graph using the Tiernan's algorithm.\n *\n * <p>See:<br>\n * J.C.Tiernan An Efficient Search Algorithm Find the Elementary Circuits of a\n * Graph., Communications of the ACM, vol.13, 12, (1970), pp. 722 - 726.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic class TiernanSimpleCycles<V, E>\n    implements DirectedSimpleCycles<V, E>\n{\n    private DirectedGraph<V, E> graph;\n\n    /**\n     * Create a simple cycle finder with an unspecified graph.\n     */\n    public TiernanSimpleCycles()\n    {\n    }\n\n    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */\n    public TiernanSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public List<List<V>> findSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        Map<V, Integer> indices = new HashMap<V, Integer>();\n        List<V> path = new ArrayList<V>();\n        Set<V> pathSet = new HashSet<V>();\n        Map<V, Set<V>> blocked = new HashMap<V, Set<V>>();\n        List<List<V>> cycles = new LinkedList<List<V>>();\n\n        int index = 0;\n        for (V v : graph.vertexSet()) {\n            blocked.put(v, new HashSet<V>());\n            indices.put(v, index++);\n        }\n\n        Iterator<V> vertexIterator = graph.vertexSet().iterator();\n        if (!vertexIterator.hasNext()) {\n            return cycles;\n        }\n\n        V startOfPath = null;\n        V endOfPath = null;\n        V temp = null;\n        int endIndex = 0;\n        boolean extensionFound = false;\n\n        endOfPath = vertexIterator.next();\n        path.add(endOfPath);\n        pathSet.add(endOfPath);\n\n        // A mostly straightforward implementation\n        // of the algorithm. Except that there is\n        // no real need for the state machine from\n        // the original paper.\n        while (true) {\n            // path extension\n            do {\n                extensionFound = false;\n                for (E e : graph.outgoingEdgesOf(endOfPath)) {\n                    V n = graph.getEdgeTarget(e);\n                    int cmp =\n                        indices.get(n).compareTo(indices.get(path.get(0)));\n                    if ((cmp > 0)\n                        && !pathSet.contains(n)\n                        && !blocked.get(endOfPath).contains(n))\n                    {\n                        path.add(n);\n                        pathSet.add(n);\n                        endOfPath = n;\n                        extensionFound = true;\n                        break;\n                    }\n                }\n            } while (extensionFound);\n\n            // circuit confirmation\n            startOfPath = path.get(0);\n            if (graph.containsEdge(endOfPath, startOfPath)) {\n                List<V> cycle = new ArrayList<V>();\n                cycle.addAll(path);\n                cycles.add(cycle);\n            }\n\n            // vertex closure\n            if (path.size() > 1) {\n                blocked.get(endOfPath).clear();\n                endIndex = path.size() - 1;\n                path.remove(endIndex);\n                pathSet.remove(endOfPath);\n                --endIndex;\n                temp = endOfPath;\n                endOfPath = path.get(endIndex);\n                blocked.get(endOfPath).add(temp);\n                continue;\n            }\n\n            // advance initial index\n            if (vertexIterator.hasNext()) {\n                path.clear();\n                pathSet.clear();\n                endOfPath = vertexIterator.next();\n                path.add(endOfPath);\n                pathSet.add(endOfPath);\n                for (V vt : blocked.keySet()) {\n                    blocked.get(vt).clear();\n                }\n                continue;\n            }\n\n            // terminate\n            break;\n        }\n\n        return cycles;\n    }\n}\n\n// End TiernanSimpleCycles.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "findSimpleCycles", "org.jgrapht.alg.cycle", "TiernanSimpleCycles", "public List<List<V>> findSimpleCycles()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getGraph", "org.jgrapht.alg.cycle", "TiernanSimpleCycles", "public DirectedGraph<V, E> getGraph()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25759,
  "oracle" : "v==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "AbstractGraph",
  "javadocTag" : "@throws NullPointerException if specified vertex is <code>null</code>.",
  "methodJavadoc" : "    /**\n     * Ensures that the specified vertex exists in this graph, or else throws\n     * exception.\n     *\n     * @param v vertex\n     *\n     * @return <code>true</code> if this assertion holds.\n     *\n     * @throws NullPointerException if specified vertex is <code>null</code>.\n     * @throws IllegalArgumentException if specified vertex does not exist in\n     * this graph.\n     */",
  "methodSourceCode" : "protected boolean assertVertexExist(V v){\n    if (containsVertex(v)) {\n        return true;\n    } else if (v == null) {\n        throw new NullPointerException();\n    } else {\n        throw new IllegalArgumentException(\"no such vertex in graph: \" + v.toString());\n    }\n}",
  "classJavadoc" : "/**\n * A skeletal implementation of the <tt>Graph</tt> interface, to minimize the\n * effort required to implement graph interfaces. This implementation is\n * applicable to both: directed graphs and undirected graphs.\n *\n * @author Barak Naveh\n * @see Graph\n * @see DirectedGraph\n * @see UndirectedGraph\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * AbstractGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Vladimir Kostyukov\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n * 14-Jun-2012 : Added hashCode() and equals() methods implementation (VK);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A skeletal implementation of the <tt>Graph</tt> interface, to minimize the\n * effort required to implement graph interfaces. This implementation is\n * applicable to both: directed graphs and undirected graphs.\n *\n * @author Barak Naveh\n * @see Graph\n * @see DirectedGraph\n * @see UndirectedGraph\n */\npublic abstract class AbstractGraph<V, E>\n    implements Graph<V, E>\n{\n    /**\n     * Construct a new empty graph object.\n     */\n    protected AbstractGraph()\n    {\n    }\n\n    /**\n     * @see Graph#containsEdge(Object, Object)\n     */\n    @Override public boolean containsEdge(V sourceVertex, V targetVertex)\n    {\n        return getEdge(sourceVertex, targetVertex) != null;\n    }\n\n    /**\n     * @see Graph#removeAllEdges(Collection)\n     */\n    @Override public boolean removeAllEdges(Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            modified |= removeEdge(e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see Graph#removeAllEdges(Object, Object)\n     */\n    @Override public Set<E> removeAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> removed = getAllEdges(sourceVertex, targetVertex);\n        if (removed == null) {\n            return null;\n        }\n        removeAllEdges(removed);\n\n        return removed;\n    }\n\n    /**\n     * @see Graph#removeAllVertices(Collection)\n     */\n    @Override public boolean removeAllVertices(Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= removeVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a string of the parenthesized pair (V, E) representing this\n     * G=(V,E) graph. 'V' is the string representation of the vertex set, and\n     * 'E' is the string representation of the edge set.\n     *\n     * @return a string representation of this graph.\n     */\n    @Override public String toString()\n    {\n        return toStringFromSets(\n            vertexSet(),\n            edgeSet(),\n            (this instanceof DirectedGraph<?, ?>));\n    }\n\n    /**\n     * Ensures that the specified vertex exists in this graph, or else throws\n     * exception.\n     *\n     * @param v vertex\n     *\n     * @return <code>true</code> if this assertion holds.\n     *\n     * @throws NullPointerException if specified vertex is <code>null</code>.\n     * @throws IllegalArgumentException if specified vertex does not exist in\n     * this graph.\n     */\n    protected boolean assertVertexExist(V v)\n    {\n        if (containsVertex(v)) {\n            return true;\n        } else if (v == null) {\n            throw new NullPointerException();\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex in graph: \" + v.toString());\n        }\n    }\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge array. After this call returns, this graph will contain no\n     * edges in common with the specified edges. This method will invoke the\n     * {@link Graph#removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call.\n     *\n     * @see Graph#removeEdge(Object)\n     * @see Graph#containsEdge(Object)\n     */\n    protected boolean removeAllEdges(E [] edges)\n    {\n        boolean modified = false;\n\n        for (int i = 0; i < edges.length; i++) {\n            modified |= removeEdge(edges[i]);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Helper for subclass implementations of toString( ).\n     *\n     * @param vertexSet the vertex set V to be printed\n     * @param edgeSet the edge set E to be printed\n     * @param directed true to use parens for each edge (representing directed);\n     * false to use curly braces (representing undirected)\n     *\n     * @return a string representation of (V,E)\n     */\n    protected String toStringFromSets(\n        Collection<? extends V> vertexSet,\n        Collection<? extends E> edgeSet,\n        boolean directed)\n    {\n        List<String> renderedEdges = new ArrayList<String>();\n\n        StringBuffer sb = new StringBuffer();\n        for (E e : edgeSet) {\n            if ((e.getClass() != DefaultEdge.class)\n                && (e.getClass() != DefaultWeightedEdge.class))\n            {\n                sb.append(e.toString());\n                sb.append(\"=\");\n            }\n            if (directed) {\n                sb.append(\"(\");\n            } else {\n                sb.append(\"{\");\n            }\n            sb.append(getEdgeSource(e));\n            sb.append(\",\");\n            sb.append(getEdgeTarget(e));\n            if (directed) {\n                sb.append(\")\");\n            } else {\n                sb.append(\"}\");\n            }\n\n            // REVIEW jvs 29-May-2006:  dump weight somewhere?\n            renderedEdges.add(sb.toString());\n            sb.setLength(0);\n        }\n\n        return \"(\" + vertexSet + \", \" + renderedEdges + \")\";\n    }\n\n    /**\n     * Returns a hash code value for this graph. The hash code of a graph is\n     * defined to be the sum of the hash codes of vertices and edges in the\n     * graph. It is also based on graph topology and edges weights.\n     *\n     * @return the hash code value this graph\n     *\n     * @see Object#hashCode()\n     */\n    @Override public int hashCode()\n    {\n        int hash = vertexSet().hashCode();\n\n        for (E e : edgeSet()) {\n            int part = e.hashCode();\n\n            int source = getEdgeSource(e).hashCode();\n            int target = getEdgeTarget(e).hashCode();\n\n            // see http://en.wikipedia.org/wiki/Pairing_function (VK);\n            int pairing =\n                ((source + target)\n                    * (source + target + 1) / 2) + target;\n            part = (27 * part) + pairing;\n\n            long weight = (long) getEdgeWeight(e);\n            part = (27 * part) + (int) (weight ^ (weight >>> 32));\n\n            hash += part;\n        }\n\n        return hash;\n    }\n\n    /**\n     * Indicates whether some other object is \"equal to\" this graph. Returns\n     * <code>true</code> if the given object is also a graph, the two graphs are\n     * instances of the same graph class, have identical vertices and edges sets\n     * with the same weights.\n     *\n     * @param obj object to be compared for equality with this graph\n     *\n     * @return <code>true</code> if the specified object is equal to this graph\n     *\n     * @see Object#equals(Object)\n     */\n    @Override public boolean equals(Object obj)\n    {\n        if (this == obj) {\n            return true;\n        }\n        if ((obj == null) || (getClass() != obj.getClass())) {\n            return false;\n        }\n\n        TypeUtil<Graph<V, E>> typeDecl = null;\n        Graph<V, E> g = TypeUtil.uncheckedCast(obj, typeDecl);\n\n        if (!vertexSet().equals(g.vertexSet())) {\n            return false;\n        }\n        if (edgeSet().size() != g.edgeSet().size()) {\n            return false;\n        }\n\n        for (E e : edgeSet()) {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            if (!g.containsEdge(e)) {\n                return false;\n            }\n\n            if (!g.getEdgeSource(e).equals(source)\n                || !g.getEdgeTarget(e).equals(target))\n            {\n                return false;\n            }\n\n            if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// End AbstractGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "v", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V v)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object obj)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] edges)" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> vertexSet, Collection<? extends E> edgeSet, boolean directed)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25760,
  "oracle" : "this.containsVertex(v)==false;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "AbstractGraph",
  "javadocTag" : "@throws IllegalArgumentException if specified vertex does not exist in\nthis graph.",
  "methodJavadoc" : "    /**\n     * Ensures that the specified vertex exists in this graph, or else throws\n     * exception.\n     *\n     * @param v vertex\n     *\n     * @return <code>true</code> if this assertion holds.\n     *\n     * @throws NullPointerException if specified vertex is <code>null</code>.\n     * @throws IllegalArgumentException if specified vertex does not exist in\n     * this graph.\n     */",
  "methodSourceCode" : "protected boolean assertVertexExist(V v){\n    if (containsVertex(v)) {\n        return true;\n    } else if (v == null) {\n        throw new NullPointerException();\n    } else {\n        throw new IllegalArgumentException(\"no such vertex in graph: \" + v.toString());\n    }\n}",
  "classJavadoc" : "/**\n * A skeletal implementation of the <tt>Graph</tt> interface, to minimize the\n * effort required to implement graph interfaces. This implementation is\n * applicable to both: directed graphs and undirected graphs.\n *\n * @author Barak Naveh\n * @see Graph\n * @see DirectedGraph\n * @see UndirectedGraph\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ------------------\n * AbstractGraph.java\n * ------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   Christian Hammer\n *                   Vladimir Kostyukov\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n * 14-Jun-2012 : Added hashCode() and equals() methods implementation (VK);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * A skeletal implementation of the <tt>Graph</tt> interface, to minimize the\n * effort required to implement graph interfaces. This implementation is\n * applicable to both: directed graphs and undirected graphs.\n *\n * @author Barak Naveh\n * @see Graph\n * @see DirectedGraph\n * @see UndirectedGraph\n */\npublic abstract class AbstractGraph<V, E>\n    implements Graph<V, E>\n{\n    /**\n     * Construct a new empty graph object.\n     */\n    protected AbstractGraph()\n    {\n    }\n\n    /**\n     * @see Graph#containsEdge(Object, Object)\n     */\n    @Override public boolean containsEdge(V sourceVertex, V targetVertex)\n    {\n        return getEdge(sourceVertex, targetVertex) != null;\n    }\n\n    /**\n     * @see Graph#removeAllEdges(Collection)\n     */\n    @Override public boolean removeAllEdges(Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            modified |= removeEdge(e);\n        }\n\n        return modified;\n    }\n\n    /**\n     * @see Graph#removeAllEdges(Object, Object)\n     */\n    @Override public Set<E> removeAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> removed = getAllEdges(sourceVertex, targetVertex);\n        if (removed == null) {\n            return null;\n        }\n        removeAllEdges(removed);\n\n        return removed;\n    }\n\n    /**\n     * @see Graph#removeAllVertices(Collection)\n     */\n    @Override public boolean removeAllVertices(Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= removeVertex(v);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Returns a string of the parenthesized pair (V, E) representing this\n     * G=(V,E) graph. 'V' is the string representation of the vertex set, and\n     * 'E' is the string representation of the edge set.\n     *\n     * @return a string representation of this graph.\n     */\n    @Override public String toString()\n    {\n        return toStringFromSets(\n            vertexSet(),\n            edgeSet(),\n            (this instanceof DirectedGraph<?, ?>));\n    }\n\n    /**\n     * Ensures that the specified vertex exists in this graph, or else throws\n     * exception.\n     *\n     * @param v vertex\n     *\n     * @return <code>true</code> if this assertion holds.\n     *\n     * @throws NullPointerException if specified vertex is <code>null</code>.\n     * @throws IllegalArgumentException if specified vertex does not exist in\n     * this graph.\n     */\n    protected boolean assertVertexExist(V v)\n    {\n        if (containsVertex(v)) {\n            return true;\n        } else if (v == null) {\n            throw new NullPointerException();\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex in graph: \" + v.toString());\n        }\n    }\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge array. After this call returns, this graph will contain no\n     * edges in common with the specified edges. This method will invoke the\n     * {@link Graph#removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call.\n     *\n     * @see Graph#removeEdge(Object)\n     * @see Graph#containsEdge(Object)\n     */\n    protected boolean removeAllEdges(E [] edges)\n    {\n        boolean modified = false;\n\n        for (int i = 0; i < edges.length; i++) {\n            modified |= removeEdge(edges[i]);\n        }\n\n        return modified;\n    }\n\n    /**\n     * Helper for subclass implementations of toString( ).\n     *\n     * @param vertexSet the vertex set V to be printed\n     * @param edgeSet the edge set E to be printed\n     * @param directed true to use parens for each edge (representing directed);\n     * false to use curly braces (representing undirected)\n     *\n     * @return a string representation of (V,E)\n     */\n    protected String toStringFromSets(\n        Collection<? extends V> vertexSet,\n        Collection<? extends E> edgeSet,\n        boolean directed)\n    {\n        List<String> renderedEdges = new ArrayList<String>();\n\n        StringBuffer sb = new StringBuffer();\n        for (E e : edgeSet) {\n            if ((e.getClass() != DefaultEdge.class)\n                && (e.getClass() != DefaultWeightedEdge.class))\n            {\n                sb.append(e.toString());\n                sb.append(\"=\");\n            }\n            if (directed) {\n                sb.append(\"(\");\n            } else {\n                sb.append(\"{\");\n            }\n            sb.append(getEdgeSource(e));\n            sb.append(\",\");\n            sb.append(getEdgeTarget(e));\n            if (directed) {\n                sb.append(\")\");\n            } else {\n                sb.append(\"}\");\n            }\n\n            // REVIEW jvs 29-May-2006:  dump weight somewhere?\n            renderedEdges.add(sb.toString());\n            sb.setLength(0);\n        }\n\n        return \"(\" + vertexSet + \", \" + renderedEdges + \")\";\n    }\n\n    /**\n     * Returns a hash code value for this graph. The hash code of a graph is\n     * defined to be the sum of the hash codes of vertices and edges in the\n     * graph. It is also based on graph topology and edges weights.\n     *\n     * @return the hash code value this graph\n     *\n     * @see Object#hashCode()\n     */\n    @Override public int hashCode()\n    {\n        int hash = vertexSet().hashCode();\n\n        for (E e : edgeSet()) {\n            int part = e.hashCode();\n\n            int source = getEdgeSource(e).hashCode();\n            int target = getEdgeTarget(e).hashCode();\n\n            // see http://en.wikipedia.org/wiki/Pairing_function (VK);\n            int pairing =\n                ((source + target)\n                    * (source + target + 1) / 2) + target;\n            part = (27 * part) + pairing;\n\n            long weight = (long) getEdgeWeight(e);\n            part = (27 * part) + (int) (weight ^ (weight >>> 32));\n\n            hash += part;\n        }\n\n        return hash;\n    }\n\n    /**\n     * Indicates whether some other object is \"equal to\" this graph. Returns\n     * <code>true</code> if the given object is also a graph, the two graphs are\n     * instances of the same graph class, have identical vertices and edges sets\n     * with the same weights.\n     *\n     * @param obj object to be compared for equality with this graph\n     *\n     * @return <code>true</code> if the specified object is equal to this graph\n     *\n     * @see Object#equals(Object)\n     */\n    @Override public boolean equals(Object obj)\n    {\n        if (this == obj) {\n            return true;\n        }\n        if ((obj == null) || (getClass() != obj.getClass())) {\n            return false;\n        }\n\n        TypeUtil<Graph<V, E>> typeDecl = null;\n        Graph<V, E> g = TypeUtil.uncheckedCast(obj, typeDecl);\n\n        if (!vertexSet().equals(g.vertexSet())) {\n            return false;\n        }\n        if (edgeSet().size() != g.edgeSet().size()) {\n            return false;\n        }\n\n        for (E e : edgeSet()) {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            if (!g.containsEdge(e)) {\n                return false;\n            }\n\n            if (!g.getEdgeSource(e).equals(source)\n                || !g.getEdgeTarget(e).equals(target))\n            {\n                return false;\n            }\n\n            if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// End AbstractGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "v", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> edges)" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V sourceVertex, V targetVertex)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object obj)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V v)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V sourceVertex, V targetVertex)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] edges)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> vertexSet, Collection<? extends E> edgeSet, boolean directed)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> vertices)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25761,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "TarjanSimpleCycles",
  "javadocTag" : "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public TarjanSimpleCycles(DirectedGraph<V, E> graph){\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}",
  "classJavadoc" : "/**\n * Find all simple cycles of a directed graph using the Tarjan's algorithm.\n *\n * <p>See:<br>\n * R. Tarjan, Enumeration of the elementary circuits of a directed graph, SIAM\n * J. Comput., 2 (1973), pp. 211-216.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * TarjanSimpleCycles.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Find all simple cycles of a directed graph using the Tarjan's algorithm.\n *\n * <p>See:<br>\n * R. Tarjan, Enumeration of the elementary circuits of a directed graph, SIAM\n * J. Comput., 2 (1973), pp. 211-216.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic class TarjanSimpleCycles<V, E>\n    implements DirectedSimpleCycles<V, E>\n{\n    private DirectedGraph<V, E> graph;\n\n    private List<List<V>> cycles;\n    private Set<V> marked;\n    private ArrayDeque<V> markedStack;\n    private ArrayDeque<V> pointStack;\n    private Map<V, Integer> vToI;\n    private Map<V, Set<V>> removed;\n\n    /**\n     * Create a simple cycle finder with an unspecified graph.\n     */\n    public TarjanSimpleCycles()\n    {\n    }\n\n    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */\n    public TarjanSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public List<List<V>> findSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        initState();\n\n        for (V start : graph.vertexSet()) {\n            backtrack(start, start);\n            while (!markedStack.isEmpty()) {\n                marked.remove(markedStack.pop());\n            }\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }\n\n    private boolean backtrack(V start, V vertex)\n    {\n        boolean foundCycle = false;\n        pointStack.push(vertex);\n        marked.add(vertex);\n        markedStack.push(vertex);\n\n        for (E currentEdge : graph.outgoingEdgesOf(vertex)) {\n            V currentVertex = graph.getEdgeTarget(currentEdge);\n            if (getRemoved(vertex).contains(currentVertex)) {\n                continue;\n            }\n            int comparison = toI(currentVertex).compareTo(toI(start));\n            if (comparison < 0) {\n                getRemoved(vertex).add(currentVertex);\n            } else if (comparison == 0) {\n                foundCycle = true;\n                List<V> cycle = new ArrayList<V>();\n                Iterator<V> it = pointStack.descendingIterator();\n                V v = null;\n                while (it.hasNext()) {\n                    v = it.next();\n                    if (start.equals(v)) {\n                        break;\n                    }\n                }\n                cycle.add(start);\n                while (it.hasNext()) {\n                    cycle.add(it.next());\n                }\n                cycles.add(cycle);\n            } else if (!marked.contains(currentVertex)) {\n                boolean gotCycle = backtrack(start, currentVertex);\n                foundCycle = foundCycle || gotCycle;\n            }\n        }\n\n        if (foundCycle) {\n            while (!markedStack.peek().equals(vertex)) {\n                marked.remove(markedStack.pop());\n            }\n            marked.remove(markedStack.pop());\n        }\n\n        pointStack.pop();\n        return foundCycle;\n    }\n\n    private void initState()\n    {\n        cycles = new ArrayList<List<V>>();\n        marked = new HashSet<V>();\n        markedStack = new ArrayDeque<V>();\n        pointStack = new ArrayDeque<V>();\n        vToI = new HashMap<V, Integer>();\n        removed = new HashMap<V, Set<V>>();\n        int index = 0;\n        for (V v : graph.vertexSet()) {\n            vToI.put(v, index++);\n        }\n    }\n\n    private void clearState()\n    {\n        cycles = null;\n        marked = null;\n        markedStack = null;\n        pointStack = null;\n        vToI = null;\n    }\n\n    private Integer toI(V v)\n    {\n        return vToI.get(v);\n    }\n\n    private Set<V> getRemoved(V v)\n    {\n        // Removed sets typically not all\n        // needed, so instantiate lazily.\n        Set<V> result = removed.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            removed.put(v, result);\n        }\n        return result;\n    }\n}\n\n// End TarjanSimpleCycles.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getGraph", "org.jgrapht.alg.cycle", "TarjanSimpleCycles", "public DirectedGraph<V, E> getGraph()" ], [ "findSimpleCycles", "org.jgrapht.alg.cycle", "TarjanSimpleCycles", "public List<List<V>> findSimpleCycles()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25762,
  "oracle" : "size<0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.generate",
  "className" : "RingGraphGenerator",
  "javadocTag" : "@throws IllegalArgumentException if the specified size is negative.",
  "methodJavadoc" : "    /**\n     * Construct a new RingGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */",
  "methodSourceCode" : "public RingGraphGenerator(int size){\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}",
  "classJavadoc" : "/**\n * Generates a ring graph of any size. A ring graph is a graph that contains a\n * single cycle that passes through all its vertices exactly once. For a\n * directed graph, the generated edges are oriented consistently around the\n * ring.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * RingGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 16-Sep-2003 : Initial revision (JVS);\n *\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Generates a ring graph of any size. A ring graph is a graph that contains a\n * single cycle that passes through all its vertices exactly once. For a\n * directed graph, the generated edges are oriented consistently around the\n * ring.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */\npublic class RingGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    private int size;\n\n    /**\n     * Construct a new RingGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */\n    public RingGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (size < 1) {\n            return;\n        }\n\n        LinearGraphGenerator<V, E> linearGenerator =\n            new LinearGraphGenerator<V, E>(size);\n        Map<String, V> privateMap = new HashMap<String, V>();\n        linearGenerator.generateGraph(target, vertexFactory, privateMap);\n\n        V startVertex = privateMap.get(LinearGraphGenerator.START_VERTEX);\n        V endVertex = privateMap.get(LinearGraphGenerator.END_VERTEX);\n        target.addEdge(endVertex, startVertex);\n    }\n}\n\n// End RingGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "size", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25763,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "JohnsonSimpleCycles",
  "javadocTag" : "@throws IllegalArgumentException if the graph argument is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "public JohnsonSimpleCycles(DirectedGraph<V, E> graph){\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}",
  "classJavadoc" : "/**\n * Find all simple cycles of a directed graph using the Johnson's algorithm.\n *\n * <p>See:<br>\n * D.B.Johnson, Finding all the elementary circuits of a directed graph, SIAM J.\n * Comput., 4 (1975), pp. 77-84.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * JohnsonSimpleCycles.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov.\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Find all simple cycles of a directed graph using the Johnson's algorithm.\n *\n * <p>See:<br>\n * D.B.Johnson, Finding all the elementary circuits of a directed graph, SIAM J.\n * Comput., 4 (1975), pp. 77-84.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic class JohnsonSimpleCycles<V, E>\n    implements DirectedSimpleCycles<V, E>\n{\n    // The graph.\n    private DirectedGraph<V, E> graph;\n\n    // The main state of the algorithm.\n    private List<List<V>> cycles = null;\n    private V [] iToV = null;\n    private Map<V, Integer> vToI = null;\n    private Set<V> blocked = null;\n    private Map<V, Set<V>> bSets = null;\n    private ArrayDeque<V> stack = null;\n\n    // The state of the embedded Tarjan SCC algorithm.\n    private List<Set<V>> SCCs = null;\n    private int index = 0;\n    private Map<V, Integer> vIndex = null;\n    private Map<V, Integer> vLowlink = null;\n    private ArrayDeque<V> path = null;\n    private Set<V> pathSet = null;\n\n    /**\n     * Create a simple cycle finder with an unspecified graph.\n     */\n    public JohnsonSimpleCycles()\n    {\n    }\n\n    /**\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null</code>.\n     */\n    public JohnsonSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public List<List<V>> findSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        initState();\n\n        int startIndex = 0;\n        int size = graph.vertexSet().size();\n        while (startIndex < size) {\n            Object [] minSCCGResult = findMinSCSG(startIndex);\n            if (minSCCGResult[0] != null) {\n                startIndex = (Integer) minSCCGResult[1];\n                @SuppressWarnings(\"unchecked\")\n                DirectedGraph<V, E> scg =\n                    (DirectedGraph<V, E>) minSCCGResult[0];\n                V startV = toV(startIndex);\n                for (E e : scg.outgoingEdgesOf(startV)) {\n                    V v = graph.getEdgeTarget(e);\n                    blocked.remove(v);\n                    getBSet(v).clear();\n                }\n                findCyclesInSCG(startIndex, startIndex, scg);\n                startIndex++;\n            } else {\n                break;\n            }\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }\n\n    private Object [] findMinSCSG(int startIndex)\n    {\n        // Per Johnson : \"adjacency structure of strong\n        // component K with least vertex in subgraph of\n        // G induced by {s, s+ 1, n}\".\n        // Or in contemporary terms: the strongly connected\n        // component of the subgraph induced by {v1,...,vn}\n        // which contains the minimum (among those SCCs)\n        // vertex index. We return that index together with\n        // the graph.\n        initMinSCGState();\n        Object [] result = new Object[2];\n\n        List<Set<V>> SCCs = findSCCS(startIndex);\n\n        // find the SCC with the minimum index\n        int minIndexFound = Integer.MAX_VALUE;\n        Set<V> minSCC = null;\n        for (Set<V> scc : SCCs) {\n            for (V v : scc) {\n                int t = toI(v);\n                if (t < minIndexFound) {\n                    minIndexFound = t;\n                    minSCC = scc;\n                }\n            }\n        }\n        if (minSCC == null) {\n            return result;\n        }\n\n        // build a graph for the SCC found\n        @SuppressWarnings(\"unchecked\")\n        DirectedGraph<V, E> resultGraph =\n            new DefaultDirectedGraph<V, E>(\n                new ClassBasedEdgeFactory<V, E>(\n                    (Class<? extends E>) DefaultEdge.class));\n        for (V v : minSCC) {\n            resultGraph.addVertex(v);\n        }\n        for (V v : minSCC) {\n            for (V w : minSCC) {\n                if (graph.containsEdge(v, w)) {\n                    resultGraph.addEdge(v, w);\n                }\n            }\n        }\n\n        // It is ugly to return results in an array\n        // of Object but the idea is to restrict\n        // dependencies to JgraphT only and there is\n        // no utility pair container in JgraphT.\n        result[0] = resultGraph;\n        result[1] = minIndexFound;\n\n        clearMinSCCState();\n        return result;\n    }\n\n    private List<Set<V>> findSCCS(int startIndex)\n    {\n        // Find SCCs in the subgraph induced\n        // by vertices startIndex and beyond.\n        // A call to StrongConnectivityAlgorithm\n        // would be too expensive because of the\n        // need to materialize the subgraph.\n        // So - do a local search by the Tarjan's\n        // algorithm and pretend that vertices\n        // with an index smaller than startIndex\n        // do not exist.\n        for (V v : graph.vertexSet()) {\n            int vI = toI(v);\n            if (vI < startIndex) {\n                continue;\n            }\n            if (!vIndex.containsKey(v)) {\n                getSCCs(startIndex, vI);\n            }\n        }\n        List<Set<V>> result = SCCs;\n        SCCs = null;\n        return result;\n    }\n\n    private void getSCCs(int startIndex, int vertexIndex)\n    {\n        V vertex = toV(vertexIndex);\n        vIndex.put(vertex, index);\n        vLowlink.put(vertex, index);\n        index++;\n        path.push(vertex);\n        pathSet.add(vertex);\n\n        Set<E> edges = graph.outgoingEdgesOf(vertex);\n        for (E e : edges) {\n            V successor = graph.getEdgeTarget(e);\n            int successorIndex = toI(successor);\n            if (successorIndex < startIndex) {\n                continue;\n            }\n            if (!vIndex.containsKey(successor)) {\n                getSCCs(startIndex, successorIndex);\n                vLowlink.put(\n                    vertex,\n                    Math.min(vLowlink.get(vertex),\n                        vLowlink.get(successor)));\n            } else if (pathSet.contains(successor)) {\n                vLowlink.put(\n                    vertex,\n                    Math.min(vLowlink.get(vertex),\n                        vIndex.get(successor)));\n            }\n        }\n        if (vLowlink.get(vertex).equals(vIndex.get(vertex))) {\n            Set<V> result = new HashSet<V>();\n            V temp = null;\n            do {\n                temp = path.pop();\n                pathSet.remove(temp);\n                result.add(temp);\n            } while (!vertex.equals(temp));\n            if (result.size() == 1) {\n                V v = result.iterator().next();\n                if (graph.containsEdge(vertex, v)) {\n                    SCCs.add(result);\n                }\n            } else {\n                SCCs.add(result);\n            }\n        }\n    }\n\n    private boolean findCyclesInSCG(\n        int startIndex,\n        int vertexIndex,\n        DirectedGraph<V, E> scg)\n    {\n        // Find cycles in a strongly connected graph\n        // per Johnson.\n        boolean foundCycle = false;\n        V vertex = toV(vertexIndex);\n        stack.push(vertex);\n        blocked.add(vertex);\n\n        for (E e : scg.outgoingEdgesOf(vertex)) {\n            V successor = scg.getEdgeTarget(e);\n            int successorIndex = toI(successor);\n            if (successorIndex == startIndex) {\n                List<V> cycle = new ArrayList<V>();\n                cycle.addAll(stack);\n                cycles.add(cycle);\n                foundCycle = true;\n            } else if (!blocked.contains(successor)) {\n                boolean gotCycle =\n                    findCyclesInSCG(startIndex, successorIndex, scg);\n                foundCycle = foundCycle || gotCycle;\n            }\n        }\n        if (foundCycle) {\n            unblock(vertex);\n        } else {\n            for (E ew : scg.outgoingEdgesOf(vertex)) {\n                V w = scg.getEdgeTarget(ew);\n                Set<V> bSet = getBSet(w);\n                bSet.add(vertex);\n            }\n        }\n        stack.pop();\n        return foundCycle;\n    }\n\n    private void unblock(V vertex)\n    {\n        blocked.remove(vertex);\n        Set<V> bSet = getBSet(vertex);\n        while (bSet.size() > 0) {\n            V w = bSet.iterator().next();\n            bSet.remove(w);\n            if (blocked.contains(w)) {\n                unblock(w);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void initState()\n    {\n        cycles = new LinkedList<List<V>>();\n        iToV = (V []) graph.vertexSet().toArray();\n        vToI = new HashMap<V, Integer>();\n        blocked = new HashSet<V>();\n        bSets = new HashMap<V, Set<V>>();\n        stack = new ArrayDeque<V>();\n\n        for (int i = 0; i < iToV.length; i++) {\n            vToI.put(iToV[i], i);\n        }\n    }\n\n    private void clearState()\n    {\n        cycles = null;\n        iToV = null;\n        vToI = null;\n        blocked = null;\n        bSets = null;\n        stack = null;\n    }\n\n    private void initMinSCGState()\n    {\n        index = 0;\n        SCCs = new ArrayList<Set<V>>();\n        vIndex = new HashMap<V, Integer>();\n        vLowlink = new HashMap<V, Integer>();\n        path = new ArrayDeque<V>();\n        pathSet = new HashSet<V>();\n    }\n\n    private void clearMinSCCState()\n    {\n        index = 0;\n        SCCs = null;\n        vIndex = null;\n        vLowlink = null;\n        path = null;\n        pathSet = null;\n    }\n\n    private Integer toI(V vertex)\n    {\n        return vToI.get(vertex);\n    }\n\n    private V toV(Integer i)\n    {\n        return iToV[i];\n    }\n\n    private Set<V> getBSet(V v)\n    {\n        // B sets typically not all needed,\n        // so instantiate lazily.\n        Set<V> result = bSets.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            bSets.put(v, result);\n        }\n        return result;\n    }\n}\n\n// End JohnsonSimpleCycles.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.DirectedGraph", "DirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "findSimpleCycles", "org.jgrapht.alg.cycle", "JohnsonSimpleCycles", "public List<List<V>> findSimpleCycles()" ], [ "getGraph", "org.jgrapht.alg.cycle", "JohnsonSimpleCycles", "public DirectedGraph<V, E> getGraph()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "outgoingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> outgoingEdgesOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int outDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht", "DirectedGraph", "public abstract Set<E> incomingEdgesOf(V arg0)" ], [ "inDegreeOf", "org.jgrapht", "DirectedGraph", "public abstract int inDegreeOf(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25764,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */",
  "methodSourceCode" : "public B addVertex(V vertex){\n    this.graph.addVertex(vertex);\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25765,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */",
  "methodSourceCode" : "public B addVertices(V... vertices){\n    for (V vertex : vertices) {\n        this.addVertex(vertex);\n    }\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertices", "", "V[][]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ], [ "length", "", "V[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25766,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */",
  "methodSourceCode" : "public B addEdge(V source, V target){\n    Graphs.addEdgeWithVertices(this.graph, source, target);\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "source", "", "V" ], [ "target", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ], [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25767,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */",
  "methodSourceCode" : "public B addEdgeChain(V first, V second, V... rest){\n    this.addEdge(first, second);\n    V last = second;\n    for (V vertex : rest) {\n        this.addEdge(last, vertex);\n        last = vertex;\n    }\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "first", "", "V" ], [ "second", "", "V" ], [ "rest", "", "V[][]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ], [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ], [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ], [ "length", "", "V[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25768,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */",
  "methodSourceCode" : "public B addGraph(Graph<? extends V, ? extends E> sourceGraph){\n    Graphs.addGraph(this.graph, sourceGraph);\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "sourceGraph", "org.jgrapht.Graph", "Graph<? extends V, ? extends E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ], [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ], [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25769,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */",
  "methodSourceCode" : "public B removeVertex(V vertex){\n    this.graph.removeVertex(vertex);\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ], [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25770,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */",
  "methodSourceCode" : "public B removeVertices(V... vertices){\n    for (V vertex : vertices) {\n        this.removeVertex(vertex);\n    }\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertices", "", "V[][]" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ], [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ], [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ], [ "length", "", "V[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25771,
  "oracle" : "true ? methodResultID.equals(this) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph.builder",
  "className" : "AbstractGraphBuilder",
  "javadocTag" : "@return this builder object",
  "methodJavadoc" : "    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */",
  "methodSourceCode" : "public B removeEdge(V source, V target){\n    this.graph.removeEdge(source, target);\n    return this.self();\n}",
  "classJavadoc" : "/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ---------------------\n * GraphBuilderBase.java\n * ---------------------\n * (C) Copyright 2015, by Andrew Chen and Contributors.\n *\n * Original Author:  Andrew Chen <llkiwi2006@gmail.com>\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 12-Jan-2015 : Initial revision (AC);\n *\n */\npackage org.jgrapht.graph.builder;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n */\npublic abstract class AbstractGraphBuilder<V,\n    E, G extends Graph<V, E>, B extends AbstractGraphBuilder<V, E, G, B>>\n{\n    protected final G graph;\n\n    /**\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     */\n    public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }\n\n    /**\n     * @return the {@code this} object.\n     */\n    protected abstract B self();\n\n    /**\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     */\n    public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     */\n    public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     */\n    public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }\n\n    /**\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     */\n    public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }\n\n    /**\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     */\n    public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }\n\n    /**\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }\n\n    /**\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     */\n    public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }\n\n    /**\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     */\n    public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }\n\n    /**\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     */\n    public G build()\n    {\n        return this.graph;\n    }\n\n    /**\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     */\n    public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }\n}\n\n// End GraphBuilderBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "source", "", "V" ], [ "target", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertex(V vertex)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeEdge(V source, V target)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "addVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertices(V... vertices)" ], [ "addEdge", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdge(V source, V target)" ], [ "removeVertices", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B removeVertices(V... vertices)" ], [ "addGraph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addGraph(Graph<? extends V, ? extends E> sourceGraph)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "self", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected abstract B self()" ], [ "build", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public G build()" ], [ "addEdgeChain", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addEdgeChain(V first, V second, V... rest)" ], [ "addVertex", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public B addVertex(V vertex)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "buildUnmodifiable", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "public UnmodifiableGraph<V, E> buildUnmodifiable()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.graph.builder", "AbstractGraphBuilder", "protected final G graph;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25772,
  "oracle" : "true ? methodResultID == this.value : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.util",
  "className" : "ModifiableInteger",
  "javadocTag" : "@return the value.",
  "methodJavadoc" : "    /**\n     * Returns the value of this object, similarly to {@link #intValue()}. This\n     * getter is NOT redundant. It is used for serialization by\n     * java.beans.XMLEncoder.\n     *\n     * @return the value.\n     */",
  "methodSourceCode" : "public int getValue(){\n    return this.value;\n}",
  "classJavadoc" : "/**\n * The <code>ModifiableInteger</code> class wraps a value of the primitive type\n * <code>int</code> in an object, similarly to {@link java.lang.Integer}. An\n * object of type <code>ModifiableInteger</code> contains a single field whose\n * type is <code>int</code>.\n *\n * <p>Unlike <code>java.lang.Integer</code>, the int value which the\n * ModifiableInteger represents can be modified. It becomes useful when used\n * together with the collection framework. For example, if you want to have a\n * {@link java.util.List} of counters. You could use <code>Integer</code> but\n * that would have became wasteful and inefficient if you frequently had to\n * update the counters.</p>\n *\n * <p>WARNING: Because instances of this class are mutable, great care must be\n * exercised if used as keys of a {@link java.util.Map} or as values in a {@link\n * java.util.Set} in a manner that affects equals comparisons while the\n * instances are keys in the map (or values in the set). For more see\n * documentation of <code>Map</code> and <code>Set</code>.</p>\n *\n * @author Barak Naveh\n * @since May 27, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------------\n * ModifiableInteger.java\n * ----------------------\n *\n * (C) Copyright 2002-2004, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 2004-05-27 : Initial version (BN);\n *\n */\npackage org.jgrapht.util;\n\n/**\n * The <code>ModifiableInteger</code> class wraps a value of the primitive type\n * <code>int</code> in an object, similarly to {@link java.lang.Integer}. An\n * object of type <code>ModifiableInteger</code> contains a single field whose\n * type is <code>int</code>.\n *\n * <p>Unlike <code>java.lang.Integer</code>, the int value which the\n * ModifiableInteger represents can be modified. It becomes useful when used\n * together with the collection framework. For example, if you want to have a\n * {@link java.util.List} of counters. You could use <code>Integer</code> but\n * that would have became wasteful and inefficient if you frequently had to\n * update the counters.</p>\n *\n * <p>WARNING: Because instances of this class are mutable, great care must be\n * exercised if used as keys of a {@link java.util.Map} or as values in a {@link\n * java.util.Set} in a manner that affects equals comparisons while the\n * instances are keys in the map (or values in the set). For more see\n * documentation of <code>Map</code> and <code>Set</code>.</p>\n *\n * @author Barak Naveh\n * @since May 27, 2004\n */\npublic class ModifiableInteger\n    extends Number\n    implements Comparable<ModifiableInteger>\n{\n    private static final long serialVersionUID = 3618698612851422261L;\n\n    /**\n     * The int value represented by this <code>ModifiableInteger</code>.\n     */\n    public int value;\n\n    /**\n     * <b>!!! DON'T USE - Use the {@link #ModifiableInteger(int)} constructor\n     * instead !!!</b>\n     *\n     * <p>This constructor is for the use of java.beans.XMLDecoder\n     * deserialization. The constructor is marked as 'deprecated' to indicate to\n     * the programmer against using it by mistake.</p>\n     *\n     * @deprecated not really deprecated, just marked so to avoid mistaken use.\n     */\n    @Deprecated public ModifiableInteger()\n    {\n    }\n\n    /**\n     * Constructs a newly allocated <code>ModifiableInteger</code> object that\n     * represents the specified <code>int</code> value.\n     *\n     * @param value the value to be represented by the <code>\n     * ModifiableInteger</code> object.\n     */\n    public ModifiableInteger(int value)\n    {\n        this.value = value;\n    }\n\n    /**\n     * Sets a new value for this modifiable integer.\n     *\n     * @param value the new value to set.\n     */\n    public void setValue(int value)\n    {\n        this.value = value;\n    }\n\n    /**\n     * Returns the value of this object, similarly to {@link #intValue()}. This\n     * getter is NOT redundant. It is used for serialization by\n     * java.beans.XMLEncoder.\n     *\n     * @return the value.\n     */\n    public int getValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Adds one to the value of this modifiable integer.\n     */\n    public void increment()\n    {\n        this.value++;\n    }\n\n    /**\n     * Subtracts one from the value of this modifiable integer.\n     */\n    public void decrement()\n    {\n        this.value--;\n    }\n\n    /**\n     * Compares two <code>ModifiableInteger</code> objects numerically.\n     *\n     * @param anotherInteger the <code>ModifiableInteger</code> to be compared.\n     *\n     * @return the value <code>0</code> if this <code>ModifiableInteger</code>\n     * is equal to the argument <code>ModifiableInteger</code>; a value less\n     * than <code>0</code> if this <code>ModifiableInteger</code> is numerically\n     * less than the argument <code>ModifiableInteger</code>; and a value\n     * greater than <code>0</code> if this <code>ModifiableInteger</code> is\n     * numerically greater than the argument <code>ModifiableInteger</code>\n     * (signed comparison).\n     */\n    @Override public int compareTo(ModifiableInteger anotherInteger)\n    {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n\n        return (thisVal < anotherVal) ? -1 : ((thisVal == anotherVal) ? 0 : 1);\n    }\n\n    /**\n     * @see Number#doubleValue()\n     */\n    @Override public double doubleValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Compares this object to the specified object. The result is <code>\n     * true</code> if and only if the argument is not <code>null</code> and is\n     * an <code>ModifiableInteger</code> object that contains the same <code>\n     * int</code> value as this object.\n     *\n     * @param o the object to compare with.\n     *\n     * @return <code>true</code> if the objects are the same; <code>false</code>\n     * otherwise.\n     */\n    @Override public boolean equals(Object o)\n    {\n        if (o instanceof ModifiableInteger) {\n            return this.value == ((ModifiableInteger) o).value;\n        }\n\n        return false;\n    }\n\n    /**\n     * @see Number#floatValue()\n     */\n    @Override public float floatValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Returns a hash code for this <code>ModifiableInteger</code>.\n     *\n     * @return a hash code value for this object, equal to the primitive <code>\n     * int</code> value represented by this <code>ModifiableInteger</code>\n     * object.\n     */\n    @Override public int hashCode()\n    {\n        return this.value;\n    }\n\n    /**\n     * @see Number#intValue()\n     */\n    @Override public int intValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * @see Number#longValue()\n     */\n    @Override public long longValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Returns an <code>Integer</code> object representing this <code>\n     * ModifiableInteger</code>'s value.\n     *\n     * @return an <code>Integer</code> representation of the value of this\n     * object.\n     */\n    public Integer toInteger()\n    {\n        return Integer.valueOf(this.value);\n    }\n\n    /**\n     * Returns a <code>String</code> object representing this <code>\n     * ModifiableInteger</code>'s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if the\n     * integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return a string representation of the value of this object in\n     * base&nbsp;10.\n     */\n    @Override public String toString()\n    {\n        return String.valueOf(this.value);\n    }\n}\n\n// End ModifiableInteger.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "org.jgrapht.util", "ModifiableInteger", "public boolean equals(Object o)" ], [ "hashCode", "org.jgrapht.util", "ModifiableInteger", "public int hashCode()" ], [ "compareTo", "org.jgrapht.util", "ModifiableInteger", "public int compareTo(ModifiableInteger anotherInteger)" ], [ "doubleValue", "org.jgrapht.util", "ModifiableInteger", "public double doubleValue()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "floatValue", "org.jgrapht.util", "ModifiableInteger", "public float floatValue()" ], [ "toInteger", "org.jgrapht.util", "ModifiableInteger", "public Integer toInteger()" ], [ "shortValue", "java.lang", "Number", "public short shortValue()" ], [ "byteValue", "java.lang", "Number", "public byte byteValue()" ], [ "toString", "org.jgrapht.util", "ModifiableInteger", "public String toString()" ], [ "longValue", "org.jgrapht.util", "ModifiableInteger", "public long longValue()" ], [ "getValue", "org.jgrapht.util", "ModifiableInteger", "public int getValue()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "intValue", "org.jgrapht.util", "ModifiableInteger", "public int intValue()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "value", "org.jgrapht.util", "ModifiableInteger", "public int value;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25773,
  "oracle" : "ef==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "AbstractBaseGraph",
  "javadocTag" : "@throws NullPointerException if the specified edge factory is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Construct a new graph. The graph can either be directed or undirected,\n     * depending on the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     * @param allowMultipleEdges whether to allow multiple edges or not.\n     * @param allowLoops whether to allow edges that are self-loops or not.\n     *\n     * @throws NullPointerException if the specified edge factory is <code>\n     * null</code>.\n     */",
  "methodSourceCode" : "protected AbstractBaseGraph(EdgeFactory<V, E> ef, boolean allowMultipleEdges, boolean allowLoops){\n    if (ef == null) {\n        throw new NullPointerException();\n    }\n    edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n    edgeFactory = ef;\n    allowingLoops = allowLoops;\n    allowingMultipleEdges = allowMultipleEdges;\n    specifics = createSpecifics();\n    this.edgeSetFactory = new ArrayListFactory<V, E>();\n}",
  "classJavadoc" : "/**\n * The most general implementation of the {@link org.jgrapht.Graph} interface.\n * Its subclasses add various restrictions to get more specific graphs. The\n * decision whether it is directed or undirected is decided at construction time\n * and cannot be later modified (see constructor for details).\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashMap} and {@link LinkedHashSet}).</p>\n *\n * @author Barak Naveh\n * @since Jul 24, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------------\n * AbstractBaseGraph.java\n * ----------------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 10-Aug-2003 : General edge refactoring (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 07-Feb-2004 : Enabled serialization (BN);\n * 11-Mar-2004 : Made generic (CH);\n * 01-Jun-2005 : Added EdgeListFactory (JVS);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * The most general implementation of the {@link org.jgrapht.Graph} interface.\n * Its subclasses add various restrictions to get more specific graphs. The\n * decision whether it is directed or undirected is decided at construction time\n * and cannot be later modified (see constructor for details).\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashMap} and {@link LinkedHashSet}).</p>\n *\n * @author Barak Naveh\n * @since Jul 24, 2003\n */\npublic abstract class AbstractBaseGraph<V, E>\n    extends AbstractGraph<V, E>\n    implements Graph<V, E>,\n        Cloneable,\n        Serializable\n{\n    private static final long serialVersionUID = -1263088497616142427L;\n\n    private static final String LOOPS_NOT_ALLOWED = \"loops not allowed\";\n\n    boolean allowingLoops;\n\n    private EdgeFactory<V, E> edgeFactory;\n    private EdgeSetFactory<V, E> edgeSetFactory;\n    private Map<E, IntrusiveEdge> edgeMap;\n    private transient Set<E> unmodifiableEdgeSet = null;\n    private transient Set<V> unmodifiableVertexSet = null;\n    private Specifics specifics;\n    private boolean allowingMultipleEdges;\n\n    private transient TypeUtil<V> vertexTypeDecl = null;\n\n    /**\n     * Construct a new graph. The graph can either be directed or undirected,\n     * depending on the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     * @param allowMultipleEdges whether to allow multiple edges or not.\n     * @param allowLoops whether to allow edges that are self-loops or not.\n     *\n     * @throws NullPointerException if the specified edge factory is <code>\n     * null</code>.\n     */\n    protected AbstractBaseGraph(\n        EdgeFactory<V, E> ef,\n        boolean allowMultipleEdges,\n        boolean allowLoops)\n    {\n        if (ef == null) {\n            throw new NullPointerException();\n        }\n\n        edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n        edgeFactory = ef;\n        allowingLoops = allowLoops;\n        allowingMultipleEdges = allowMultipleEdges;\n\n        specifics = createSpecifics();\n\n        this.edgeSetFactory = new ArrayListFactory<V, E>();\n    }\n\n    /**\n     * @see Graph#getAllEdges(Object, Object)\n     */\n    @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        return specifics.getAllEdges(sourceVertex, targetVertex);\n    }\n\n    /**\n     * Returns <code>true</code> if and only if self-loops are allowed in this\n     * graph. A self loop is an edge that its source and target vertices are the\n     * same.\n     *\n     * @return <code>true</code> if and only if graph loops are allowed.\n     */\n    public boolean isAllowingLoops()\n    {\n        return allowingLoops;\n    }\n\n    /**\n     * Returns <code>true</code> if and only if multiple edges are allowed in\n     * this graph. The meaning of multiple edges is that there can be many edges\n     * going from vertex v1 to vertex v2.\n     *\n     * @return <code>true</code> if and only if multiple edges are allowed.\n     */\n    public boolean isAllowingMultipleEdges()\n    {\n        return allowingMultipleEdges;\n    }\n\n    /**\n     * @see Graph#getEdge(Object, Object)\n     */\n    @Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        return specifics.getEdge(sourceVertex, targetVertex);\n    }\n\n    /**\n     * @see Graph#getEdgeFactory()\n     */\n    @Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return edgeFactory;\n    }\n\n    /**\n     * Set the {@link EdgeSetFactory} to use for this graph. Initially, a graph\n     * is created with a default implementation which always supplies an {@link\n     * java.util.ArrayList} with capacity 1.\n     *\n     * @param edgeSetFactory factory to use for subsequently created edge sets\n     * (this call has no effect on existing edge sets)\n     */\n    public void setEdgeSetFactory(EdgeSetFactory<V, E> edgeSetFactory)\n    {\n        this.edgeSetFactory = edgeSetFactory;\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object)\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!allowingMultipleEdges\n            && containsEdge(sourceVertex, targetVertex))\n        {\n            return null;\n        }\n\n        if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n        }\n\n        E e = edgeFactory.createEdge(sourceVertex, targetVertex);\n\n        if (containsEdge(e)) { // this restriction should stay!\n\n            return null;\n        } else {\n            IntrusiveEdge intrusiveEdge =\n                createIntrusiveEdge(e, sourceVertex, targetVertex);\n\n            edgeMap.put(e, intrusiveEdge);\n            specifics.addEdgeToTouchingVertices(e);\n\n            return e;\n        }\n    }\n\n    /**\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!allowingMultipleEdges\n            && containsEdge(sourceVertex, targetVertex))\n        {\n            return false;\n        }\n\n        if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n        }\n\n        IntrusiveEdge intrusiveEdge =\n            createIntrusiveEdge(e, sourceVertex, targetVertex);\n\n        edgeMap.put(e, intrusiveEdge);\n        specifics.addEdgeToTouchingVertices(e);\n\n        return true;\n    }\n\n    private IntrusiveEdge createIntrusiveEdge(\n        E e,\n        V sourceVertex,\n        V targetVertex)\n    {\n        IntrusiveEdge intrusiveEdge;\n        if (e instanceof IntrusiveEdge) {\n            intrusiveEdge = (IntrusiveEdge) e;\n        } else {\n            intrusiveEdge = new IntrusiveEdge();\n        }\n        intrusiveEdge.source = sourceVertex;\n        intrusiveEdge.target = targetVertex;\n        return intrusiveEdge;\n    }\n\n    /**\n     * @see Graph#addVertex(Object)\n     */\n    @Override public boolean addVertex(V v)\n    {\n        if (v == null) {\n            throw new NullPointerException();\n        } else if (containsVertex(v)) {\n            return false;\n        } else {\n            specifics.addVertex(v);\n\n            return true;\n        }\n    }\n\n    /**\n     * @see Graph#getEdgeSource(Object)\n     */\n    @Override public V getEdgeSource(E e)\n    {\n        return TypeUtil.uncheckedCast(\n            getIntrusiveEdge(e).source,\n            vertexTypeDecl);\n    }\n\n    /**\n     * @see Graph#getEdgeTarget(Object)\n     */\n    @Override public V getEdgeTarget(E e)\n    {\n        return TypeUtil.uncheckedCast(\n            getIntrusiveEdge(e).target,\n            vertexTypeDecl);\n    }\n\n    private IntrusiveEdge getIntrusiveEdge(E e)\n    {\n        if (e instanceof IntrusiveEdge) {\n            return (IntrusiveEdge) e;\n        }\n\n        return edgeMap.get(e);\n    }\n\n    /**\n     * Returns a shallow copy of this graph instance. Neither edges nor vertices\n     * are cloned.\n     *\n     * @return a shallow copy of this set.\n     *\n     * @throws RuntimeException\n     *\n     * @see java.lang.Object#clone()\n     */\n    @Override public Object clone()\n    {\n        try {\n            TypeUtil<AbstractBaseGraph<V, E>> typeDecl = null;\n\n            AbstractBaseGraph<V, E> newGraph =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n\n            newGraph.edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n\n            newGraph.edgeFactory = this.edgeFactory;\n            newGraph.unmodifiableEdgeSet = null;\n            newGraph.unmodifiableVertexSet = null;\n\n            // NOTE:  it's important for this to happen in an object\n            // method so that the new inner class instance gets associated with\n            // the right outer class instance\n            newGraph.specifics = newGraph.createSpecifics();\n\n            Graphs.addGraph(newGraph, this);\n\n            return newGraph;\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n            throw new RuntimeException();\n        }\n    }\n\n    /**\n     * @see Graph#containsEdge(Object)\n     */\n    @Override public boolean containsEdge(E e)\n    {\n        return edgeMap.containsKey(e);\n    }\n\n    /**\n     * @see Graph#containsVertex(Object)\n     */\n    @Override public boolean containsVertex(V v)\n    {\n        return specifics.getVertexSet().contains(v);\n    }\n\n    /**\n     * @see UndirectedGraph#degreeOf(Object)\n     */\n    public int degreeOf(V vertex)\n    {\n        return specifics.degreeOf(vertex);\n    }\n\n    /**\n     * @see Graph#edgeSet()\n     */\n    @Override public Set<E> edgeSet()\n    {\n        if (unmodifiableEdgeSet == null) {\n            unmodifiableEdgeSet = Collections.unmodifiableSet(edgeMap.keySet());\n        }\n\n        return unmodifiableEdgeSet;\n    }\n\n    /**\n     * @see Graph#edgesOf(Object)\n     */\n    @Override public Set<E> edgesOf(V vertex)\n    {\n        return specifics.edgesOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#inDegreeOf(Object)\n     */\n    public int inDegreeOf(V vertex)\n    {\n        return specifics.inDegreeOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     */\n    public Set<E> incomingEdgesOf(V vertex)\n    {\n        return specifics.incomingEdgesOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#outDegreeOf(Object)\n     */\n    public int outDegreeOf(V vertex)\n    {\n        return specifics.outDegreeOf(vertex);\n    }\n\n    /**\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     */\n    public Set<E> outgoingEdgesOf(V vertex)\n    {\n        return specifics.outgoingEdgesOf(vertex);\n    }\n\n    /**\n     * @see Graph#removeEdge(Object, Object)\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = getEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            specifics.removeEdgeFromTouchingVertices(e);\n            edgeMap.remove(e);\n        }\n\n        return e;\n    }\n\n    /**\n     * @see Graph#removeEdge(Object)\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        if (containsEdge(e)) {\n            specifics.removeEdgeFromTouchingVertices(e);\n            edgeMap.remove(e);\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see Graph#removeVertex(Object)\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            // cannot iterate over list - will cause\n            // ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            specifics.getVertexSet().remove(v); // remove the vertex itself\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @see Graph#vertexSet()\n     */\n    @Override public Set<V> vertexSet()\n    {\n        if (unmodifiableVertexSet == null) {\n            unmodifiableVertexSet =\n                Collections.unmodifiableSet(specifics.getVertexSet());\n        }\n\n        return unmodifiableVertexSet;\n    }\n\n    /**\n     * @see Graph#getEdgeWeight(Object)\n     */\n    @Override public double getEdgeWeight(E e)\n    {\n        if (e instanceof DefaultWeightedEdge) {\n            return ((DefaultWeightedEdge) e).getWeight();\n        } else if (e == null) {\n            throw new NullPointerException();\n        } else {\n            return WeightedGraph.DEFAULT_EDGE_WEIGHT;\n        }\n    }\n\n    /**\n     * @see WeightedGraph#setEdgeWeight(Object, double)\n     */\n    public void setEdgeWeight(E e, double weight)\n    {\n        assert (e instanceof DefaultWeightedEdge) : e.getClass();\n        ((DefaultWeightedEdge) e).weight = weight;\n    }\n\n    private Specifics createSpecifics()\n    {\n        if (this instanceof DirectedGraph<?, ?>) {\n            return createDirectedSpecifics();\n        } else if (this instanceof UndirectedGraph<?, ?>) {\n            return createUndirectedSpecifics();\n        } else {\n            throw new IllegalArgumentException(\n                \"must be instance of either DirectedGraph or UndirectedGraph\");\n        }\n    }\n\n    protected UndirectedSpecifics createUndirectedSpecifics()\n    {\n        return new UndirectedSpecifics();\n    }\n\n    protected DirectedSpecifics createDirectedSpecifics()\n    {\n        return new DirectedSpecifics();\n    }\n\n    /**\n     * .\n     *\n     * @author Barak Naveh\n     */\n    private abstract class Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 785196247314761183L;\n\n        public abstract void addVertex(V vertex);\n\n        public abstract Set<V> getVertexSet();\n\n        /**\n         * .\n         *\n         * @param sourceVertex\n         * @param targetVertex\n         *\n         * @return\n         */\n        public abstract Set<E> getAllEdges(V sourceVertex,\n            V targetVertex);\n\n        /**\n         * .\n         *\n         * @param sourceVertex\n         * @param targetVertex\n         *\n         * @return\n         */\n        public abstract E getEdge(V sourceVertex, V targetVertex);\n\n        /**\n         * Adds the specified edge to the edge containers of its source and\n         * target vertices.\n         *\n         * @param e\n         */\n        public abstract void addEdgeToTouchingVertices(E e);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract int degreeOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract Set<E> edgesOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract int inDegreeOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract Set<E> incomingEdgesOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract int outDegreeOf(V vertex);\n\n        /**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         */\n        public abstract Set<E> outgoingEdgesOf(V vertex);\n\n        /**\n         * Removes the specified edge from the edge containers of its source and\n         * target vertices.\n         *\n         * @param e\n         */\n        public abstract void removeEdgeFromTouchingVertices(E e);\n    }\n\n    private static class ArrayListFactory<VV, EE>\n        implements EdgeSetFactory<VV, EE>,\n            Serializable\n    {\n        private static final long serialVersionUID = 5936902837403445985L;\n\n        /**\n         * @see EdgeSetFactory.createEdgeSet\n         */\n        @Override public Set<EE> createEdgeSet(VV vertex)\n        {\n            // NOTE:  use size 1 to keep memory usage under control\n            // for the common case of vertices with low degree\n            return new ArrayUnenforcedSet<EE>(1);\n        }\n    }\n\n    /**\n     * A container for vertex edges.\n     *\n     * <p>In this edge container we use array lists to minimize memory toll.\n     * However, for high-degree vertices we replace the entire edge container\n     * with a direct access subclass (to be implemented).</p>\n     *\n     * @author Barak Naveh\n     */\n    protected static class DirectedEdgeContainer<VV, EE>\n        implements Serializable\n    {\n        private static final long serialVersionUID = 7494242245729767106L;\n        Set<EE> incoming;\n        Set<EE> outgoing;\n        private transient Set<EE> unmodifiableIncoming = null;\n        private transient Set<EE> unmodifiableOutgoing = null;\n\n        DirectedEdgeContainer(EdgeSetFactory<VV, EE> edgeSetFactory,\n            VV vertex)\n        {\n            incoming = edgeSetFactory.createEdgeSet(vertex);\n            outgoing = edgeSetFactory.createEdgeSet(vertex);\n        }\n\n        /**\n         * A lazy build of unmodifiable incoming edge set.\n         *\n         * @return\n         */\n        public Set<EE> getUnmodifiableIncomingEdges()\n        {\n            if (unmodifiableIncoming == null) {\n                unmodifiableIncoming = Collections.unmodifiableSet(incoming);\n            }\n\n            return unmodifiableIncoming;\n        }\n\n        /**\n         * A lazy build of unmodifiable outgoing edge set.\n         *\n         * @return\n         */\n        public Set<EE> getUnmodifiableOutgoingEdges()\n        {\n            if (unmodifiableOutgoing == null) {\n                unmodifiableOutgoing = Collections.unmodifiableSet(outgoing);\n            }\n\n            return unmodifiableOutgoing;\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void addIncomingEdge(EE e)\n        {\n            incoming.add(e);\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void addOutgoingEdge(EE e)\n        {\n            outgoing.add(e);\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void removeIncomingEdge(EE e)\n        {\n            incoming.remove(e);\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void removeOutgoingEdge(EE e)\n        {\n            outgoing.remove(e);\n        }\n    }\n\n    /**\n     * .\n     *\n     * @author Barak Naveh\n     */\n    protected class DirectedSpecifics\n        extends Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 8971725103718958232L;\n        private static final String NOT_IN_DIRECTED_GRAPH =\n            \"no such operation in a directed graph\";\n\n        protected Map<V, DirectedEdgeContainer<V, E>> vertexMapDirected;\n\n        public DirectedSpecifics()\n        {\n            this(new LinkedHashMap<V, DirectedEdgeContainer<V, E>>());\n        }\n\n        public DirectedSpecifics(Map<V, DirectedEdgeContainer<V, E>> vertexMap)\n        {\n            this.vertexMapDirected = vertexMap;\n        }\n\n        @Override public void addVertex(V v)\n        {\n            // add with a lazy edge container entry\n            vertexMapDirected.put(v, null);\n        }\n\n        @Override public Set<V> getVertexSet()\n        {\n            return vertexMapDirected.keySet();\n        }\n\n        /**\n         * @see Graph#getAllEdges(Object, Object)\n         */\n        @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n        {\n            Set<E> edges = null;\n\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                edges = new ArrayUnenforcedSet<E>();\n\n                DirectedEdgeContainer<V, E> ec = getEdgeContainer(sourceVertex);\n\n                Iterator<E> iter = ec.outgoing.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    if (getEdgeTarget(e).equals(targetVertex)) {\n                        edges.add(e);\n                    }\n                }\n            }\n\n            return edges;\n        }\n\n        /**\n         * @see Graph#getEdge(Object, Object)\n         */\n        @Override public E getEdge(V sourceVertex, V targetVertex)\n        {\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                DirectedEdgeContainer<V, E> ec = getEdgeContainer(sourceVertex);\n\n                Iterator<E> iter = ec.outgoing.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    if (getEdgeTarget(e).equals(targetVertex)) {\n                        return e;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        @Override public void addEdgeToTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).addOutgoingEdge(e);\n            getEdgeContainer(target).addIncomingEdge(e);\n        }\n\n        /**\n         * @see UndirectedGraph#degreeOf(Object)\n         */\n        @Override public int degreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_DIRECTED_GRAPH);\n        }\n\n        /**\n         * @see Graph#edgesOf(Object)\n         */\n        @Override public Set<E> edgesOf(V vertex)\n        {\n            ArrayUnenforcedSet<E> inAndOut =\n                new ArrayUnenforcedSet<E>(getEdgeContainer(vertex).incoming);\n            inAndOut.addAll(getEdgeContainer(vertex).outgoing);\n\n            // we have two copies for each self-loop - remove one of them.\n            if (allowingLoops) {\n                Set<E> loops = getAllEdges(vertex, vertex);\n\n                for (int i = 0; i < inAndOut.size();) {\n                    Object e = inAndOut.get(i);\n\n                    if (loops.contains(e)) {\n                        inAndOut.remove(i);\n                        loops.remove(e); // so we remove it only once\n                    } else {\n                        i++;\n                    }\n                }\n            }\n\n            return Collections.unmodifiableSet(inAndOut);\n        }\n\n        /**\n         * @see DirectedGraph#inDegreeOf(Object)\n         */\n        @Override public int inDegreeOf(V vertex)\n        {\n            return getEdgeContainer(vertex).incoming.size();\n        }\n\n        /**\n         * @see DirectedGraph#incomingEdgesOf(Object)\n         */\n        @Override public Set<E> incomingEdgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableIncomingEdges();\n        }\n\n        /**\n         * @see DirectedGraph#outDegreeOf(Object)\n         */\n        @Override public int outDegreeOf(V vertex)\n        {\n            return getEdgeContainer(vertex).outgoing.size();\n        }\n\n        /**\n         * @see DirectedGraph#outgoingEdgesOf(Object)\n         */\n        @Override public Set<E> outgoingEdgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableOutgoingEdges();\n        }\n\n        @Override public void removeEdgeFromTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).removeOutgoingEdge(e);\n            getEdgeContainer(target).removeIncomingEdge(e);\n        }\n\n        /**\n         * A lazy build of edge container for specified vertex.\n         *\n         * @param vertex a vertex in this graph.\n         *\n         * @return EdgeContainer\n         */\n        private DirectedEdgeContainer<V, E> getEdgeContainer(V vertex)\n        {\n            assertVertexExist(vertex);\n\n            DirectedEdgeContainer<V, E> ec = vertexMapDirected.get(vertex);\n\n            if (ec == null) {\n                ec = new DirectedEdgeContainer<V, E>(edgeSetFactory, vertex);\n                vertexMapDirected.put(vertex, ec);\n            }\n\n            return ec;\n        }\n    }\n\n    /**\n     * A container of for vertex edges.\n     *\n     * <p>In this edge container we use array lists to minimize memory toll.\n     * However, for high-degree vertices we replace the entire edge container\n     * with a direct access subclass (to be implemented).</p>\n     *\n     * @author Barak Naveh\n     */\n    private static class UndirectedEdgeContainer<VV, EE>\n        implements Serializable\n    {\n        private static final long serialVersionUID = -6623207588411170010L;\n        Set<EE> vertexEdges;\n        private transient Set<EE> unmodifiableVertexEdges = null;\n\n        UndirectedEdgeContainer(\n            EdgeSetFactory<VV, EE> edgeSetFactory,\n            VV vertex)\n        {\n            vertexEdges = edgeSetFactory.createEdgeSet(vertex);\n        }\n\n        /**\n         * A lazy build of unmodifiable list of vertex edges\n         *\n         * @return\n         */\n        public Set<EE> getUnmodifiableVertexEdges()\n        {\n            if (unmodifiableVertexEdges == null) {\n                unmodifiableVertexEdges =\n                    Collections.unmodifiableSet(vertexEdges);\n            }\n\n            return unmodifiableVertexEdges;\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void addEdge(EE e)\n        {\n            vertexEdges.add(e);\n        }\n\n        /**\n         * .\n         *\n         * @return\n         */\n        public int edgeCount()\n        {\n            return vertexEdges.size();\n        }\n\n        /**\n         * .\n         *\n         * @param e\n         */\n        public void removeEdge(EE e)\n        {\n            vertexEdges.remove(e);\n        }\n    }\n\n    /**\n     * .\n     *\n     * @author Barak Naveh\n     */\n    protected class UndirectedSpecifics\n        extends Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 6494588405178655873L;\n        private static final String NOT_IN_UNDIRECTED_GRAPH =\n            \"no such operation in an undirected graph\";\n\n        private Map<V, UndirectedEdgeContainer<V, E>> vertexMapUndirected;\n\n        public UndirectedSpecifics()\n        {\n            this(new LinkedHashMap<V, UndirectedEdgeContainer<V, E>>());\n        }\n\n        public UndirectedSpecifics(\n            Map<V, UndirectedEdgeContainer<V, E>> vertexMap)\n        {\n            this.vertexMapUndirected = vertexMap;\n        }\n\n        @Override public void addVertex(V v)\n        {\n            // add with a lazy edge container entry\n            vertexMapUndirected.put(v, null);\n        }\n\n        @Override public Set<V> getVertexSet()\n        {\n            return vertexMapUndirected.keySet();\n        }\n\n        /**\n         * @see Graph#getAllEdges(Object, Object)\n         */\n        @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n        {\n            Set<E> edges = null;\n\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                edges = new ArrayUnenforcedSet<E>();\n\n                Iterator<E> iter =\n                    getEdgeContainer(sourceVertex).vertexEdges.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    boolean equal =\n                        isEqualsStraightOrInverted(\n                            sourceVertex,\n                            targetVertex,\n                            e);\n\n                    if (equal) {\n                        edges.add(e);\n                    }\n                }\n            }\n\n            return edges;\n        }\n\n        /**\n         * @see Graph#getEdge(Object, Object)\n         */\n        @Override public E getEdge(V sourceVertex, V targetVertex)\n        {\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                Iterator<E> iter =\n                    getEdgeContainer(sourceVertex).vertexEdges.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    boolean equal =\n                        isEqualsStraightOrInverted(\n                            sourceVertex,\n                            targetVertex,\n                            e);\n\n                    if (equal) {\n                        return e;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        private boolean isEqualsStraightOrInverted(\n            Object sourceVertex,\n            Object targetVertex,\n            E e)\n        {\n            boolean equalStraight =\n                sourceVertex.equals(getEdgeSource(e))\n                && targetVertex.equals(getEdgeTarget(e));\n\n            boolean equalInverted =\n                sourceVertex.equals(getEdgeTarget(e))\n                && targetVertex.equals(getEdgeSource(e));\n            return equalStraight || equalInverted;\n        }\n\n        @Override public void addEdgeToTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).addEdge(e);\n\n            if (!source.equals(target)) {\n                getEdgeContainer(target).addEdge(e);\n            }\n        }\n\n        @Override public int degreeOf(V vertex)\n        {\n            if (allowingLoops) { // then we must count, and add loops twice\n\n                int degree = 0;\n                Set<E> edges = getEdgeContainer(vertex).vertexEdges;\n\n                for (E e : edges) {\n                    if (getEdgeSource(e).equals(getEdgeTarget(e))) {\n                        degree += 2;\n                    } else {\n                        degree += 1;\n                    }\n                }\n\n                return degree;\n            } else {\n                return getEdgeContainer(vertex).edgeCount();\n            }\n        }\n\n        /**\n         * @see Graph#edgesOf(Object)\n         */\n        @Override public Set<E> edgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableVertexEdges();\n        }\n\n        /**\n         * @see DirectedGraph#inDegreeOf(Object)\n         */\n        @Override public int inDegreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        /**\n         * @see DirectedGraph#incomingEdgesOf(Object)\n         */\n        @Override public Set<E> incomingEdgesOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        /**\n         * @see DirectedGraph#outDegreeOf(Object)\n         */\n        @Override public int outDegreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        /**\n         * @see DirectedGraph#outgoingEdgesOf(Object)\n         */\n        @Override public Set<E> outgoingEdgesOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        @Override public void removeEdgeFromTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).removeEdge(e);\n\n            if (!source.equals(target)) {\n                getEdgeContainer(target).removeEdge(e);\n            }\n        }\n\n        /**\n         * A lazy build of edge container for specified vertex.\n         *\n         * @param vertex a vertex in this graph.\n         *\n         * @return EdgeContainer\n         */\n        private UndirectedEdgeContainer<V, E> getEdgeContainer(V vertex)\n        {\n            assertVertexExist(vertex);\n\n            UndirectedEdgeContainer<V, E> ec = vertexMapUndirected.get(vertex);\n\n            if (ec == null) {\n                ec = new UndirectedEdgeContainer<V, E>(\n                    edgeSetFactory,\n                    vertex);\n                vertexMapUndirected.put(vertex, ec);\n            }\n\n            return ec;\n        }\n    }\n}\n\n// End AbstractBaseGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "ef", "org.jgrapht.EdgeFactory", "EdgeFactory<V, E>" ], [ "allowMultipleEdges", "", "boolean" ], [ "allowLoops", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addVertex", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean addVertex(V v)" ], [ "createDirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected DirectedSpecifics createDirectedSpecifics()" ], [ "isAllowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingLoops()" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsEdge(E e)" ], [ "getEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "getAllEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "getEdgeSource", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeSource(E e)" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "addEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "getEdgeTarget", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeTarget(E e)" ], [ "edgeSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgeSet()" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "isAllowingMultipleEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingMultipleEdges()" ], [ "getEdgeWeight", "org.jgrapht.graph", "AbstractBaseGraph", "public double getEdgeWeight(E e)" ], [ "containsVertex", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsVertex(V v)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeVertex", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean removeVertex(V v)" ], [ "addEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> outgoingEdgesOf(V vertex)" ], [ "degreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int degreeOf(V vertex)" ], [ "outDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int outDegreeOf(V vertex)" ], [ "clone", "org.jgrapht.graph", "AbstractBaseGraph", "public Object clone()" ], [ "edgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgesOf(V vertex)" ], [ "incomingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> incomingEdgesOf(V vertex)" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht.graph", "AbstractBaseGraph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean removeEdge(E e)" ], [ "vertexSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<V> vertexSet()" ], [ "createUndirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected UndirectedSpecifics createUndirectedSpecifics()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "inDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int inDegreeOf(V vertex)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "createEdge", "org.jgrapht", "EdgeFactory", "public abstract E createEdge(V arg0, V arg1)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "allowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "boolean allowingLoops;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25774,
  "oracle" : "graph==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "UndirectedCycleBase",
  "javadocTag" : "@throws IllegalArgumentException if the argument is <code>null</code>.",
  "methodJavadoc" : "    /**\n     * Sets the graph on which the cycle base search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */",
  "methodSourceCode" : "void setGraph(UndirectedGraph<V, E> graph);",
  "classJavadoc" : "/**\n * A common interface for classes implementing algorithms for finding a cycle\n * base of an undirected graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * UndirectedCycleBase.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A common interface for classes implementing algorithms for finding a cycle\n * base of an undirected graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic interface UndirectedCycleBase<V, E>\n{\n    /**\n     * Returns the graph on which the cycle base search algorithm is executed by\n     * this object.\n     *\n     * @return The graph.\n     */\n    UndirectedGraph<V, E> getGraph();\n\n    /**\n     * Sets the graph on which the cycle base search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */\n    void setGraph(UndirectedGraph<V, E> graph);\n\n    /**\n     * Finds a cycle base of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return A list of cycles constituting a cycle base for the graph.\n     * Possibly empty but never <code>null</code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     */\n    List<List<V>> findCycleBase();\n}\n\n// End UndirectedCycleBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.UndirectedGraph", "UndirectedGraph<V, E>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getGraph", "org.jgrapht.alg.cycle", "UndirectedCycleBase", "UndirectedGraph<V, E> getGraph()" ], [ "findCycleBase", "org.jgrapht.alg.cycle", "UndirectedCycleBase", "List<List<V>> findCycleBase()" ], [ "degreeOf", "org.jgrapht", "UndirectedGraph", "public abstract int degreeOf(V arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25775,
  "oracle" : "this.getGraph()==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg.cycle",
  "className" : "UndirectedCycleBase",
  "javadocTag" : "@throws IllegalArgumentException if the current graph is null.",
  "methodJavadoc" : "    /**\n     * Finds a cycle base of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return A list of cycles constituting a cycle base for the graph.\n     * Possibly empty but never <code>null</code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     */",
  "methodSourceCode" : "List<List<V>> findCycleBase();",
  "classJavadoc" : "/**\n * A common interface for classes implementing algorithms for finding a cycle\n * base of an undirected graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * UndirectedCycleBase.java\n * -------------------------\n * (C) Copyright 2013, by Nikolay Ognyanov\n *\n * Original Author: Nikolay Ognyanov\n * Contributor(s) :\n *\n * $Id$\n *\n * Changes\n * -------\n * 06-Sep-2013 : Initial revision (NO);\n */\npackage org.jgrapht.alg.cycle;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * A common interface for classes implementing algorithms for finding a cycle\n * base of an undirected graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n */\npublic interface UndirectedCycleBase<V, E>\n{\n    /**\n     * Returns the graph on which the cycle base search algorithm is executed by\n     * this object.\n     *\n     * @return The graph.\n     */\n    UndirectedGraph<V, E> getGraph();\n\n    /**\n     * Sets the graph on which the cycle base search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null</code>.\n     */\n    void setGraph(UndirectedGraph<V, E> graph);\n\n    /**\n     * Finds a cycle base of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return A list of cycles constituting a cycle base for the graph.\n     * Possibly empty but never <code>null</code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     */\n    List<List<V>> findCycleBase();\n}\n\n// End UndirectedCycleBase.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getGraph", "org.jgrapht.alg.cycle", "UndirectedCycleBase", "UndirectedGraph<V, E> getGraph()" ], [ "findCycleBase", "org.jgrapht.alg.cycle", "UndirectedCycleBase", "List<List<V>> findCycleBase()" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "degreeOf", "org.jgrapht", "UndirectedGraph", "public abstract int degreeOf(V arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ] ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25776,
  "oracle" : "elementList==null || edge==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "AbstractPathElementList",
  "javadocTag" : "@throws IllegalArgumentException if <code>maxSize</code> is negative or\n0.",
  "methodJavadoc" : "    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */",
  "methodSourceCode" : "protected AbstractPathElementList(Graph<V, E> graph, int maxSize, AbstractPathElementList<V, E, T> elementList, E edge){\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    if (elementList == null) {\n        throw new NullPointerException(\"elementList is null\");\n    }\n    if (edge == null) {\n        throw new NullPointerException(\"edge is null\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n}",
  "classJavadoc" : "/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * AbstractPathElementList.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\nabstract class AbstractPathElementList<V,\n    E, T extends AbstractPathElement<V, E>>\n    extends AbstractList<T>\n{\n    protected Graph<V, E> graph;\n\n    /**\n     * Max number of stored paths.\n     */\n    protected int maxSize;\n\n    /**\n     * Stored paths, list of <code>AbstractPathElement</code>.\n     */\n    protected ArrayList<T> pathElements = new ArrayList<T>();\n\n    /**\n     * Target vertex of the paths.\n     */\n    protected V vertex;\n\n    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        AbstractPathElementList<V, E, T> elementList,\n        E edge)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (elementList == null) {\n            throw new NullPointerException(\"elementList is null\");\n        }\n        if (edge == null) {\n            throw new NullPointerException(\"edge is null\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex =\n            Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n    }\n\n    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement</code> is not\n     * empty.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        T pathElement)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (pathElement == null) {\n            throw new NullPointerException(\"pathElement is null\");\n        }\n        if (pathElement.getPrevEdge() != null) {\n            throw new IllegalArgumentException(\"path must be empty\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = pathElement.getVertex();\n\n        this.pathElements.add(pathElement);\n    }\n\n    /**\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = vertex;\n    }\n\n    /**\n     * Returns path <code>AbstractPathElement</code> stored at the specified\n     * index.\n     */\n    @Override public T get(int index)\n    {\n        return this.pathElements.get(index);\n    }\n\n    /**\n     * Returns target vertex.\n     */\n    public V getVertex()\n    {\n        return this.vertex;\n    }\n\n    /**\n     * Returns the number of paths stored in the list.\n     */\n    @Override public int size()\n    {\n        return this.pathElements.size();\n    }\n}\n\n// End AbstractPathElementList.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "maxSize", "", "int" ], [ "elementList", "org.jgrapht.alg.AbstractPathElementList", "AbstractPathElementList<V, E, T>" ], [ "edge", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toArray", "java.util", "AbstractCollection", "public Object[] toArray()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "indexOf", "java.util", "AbstractList", "public int indexOf(Object arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "set", "java.util", "AbstractList", "public E set(int arg0, E arg1)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "subList", "java.util", "AbstractList", "public List<E> subList(int arg0, int arg1)" ], [ "toString", "java.util", "AbstractCollection", "public String toString()" ], [ "hashCode", "java.util", "AbstractList", "public int hashCode()" ], [ "equals", "java.util", "AbstractList", "public boolean equals(Object arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "AbstractCollection", "public <T> T[] toArray(T[] arg0)" ], [ "contains", "java.util", "AbstractCollection", "public boolean contains(Object arg0)" ], [ "size", "org.jgrapht.alg", "AbstractPathElementList", "public int size()" ], [ "addAll", "java.util", "AbstractCollection", "public boolean addAll(Collection<? extends E> arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator(int arg0)" ], [ "get", "java.util", "AbstractList", "public abstract E get(int arg0)" ], [ "addAll", "java.util", "AbstractList", "public boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "containsAll", "java.util", "AbstractCollection", "public boolean containsAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "add", "java.util", "AbstractList", "public boolean add(E arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "iterator", "java.util", "AbstractList", "public Iterator<E> iterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator()" ], [ "getVertex", "org.jgrapht.alg", "AbstractPathElementList", "public V getVertex()" ], [ "get", "org.jgrapht.alg", "AbstractPathElementList", "public T get(int index)" ], [ "retainAll", "java.util", "AbstractCollection", "public boolean retainAll(Collection<? extends Object> arg0)" ], [ "lastIndexOf", "java.util", "AbstractList", "public int lastIndexOf(Object arg0)" ], [ "remove", "java.util", "AbstractCollection", "public boolean remove(Object arg0)" ], [ "isEmpty", "java.util", "AbstractCollection", "public boolean isEmpty()" ], [ "remove", "java.util", "AbstractList", "public E remove(int arg0)" ], [ "removeAll", "java.util", "AbstractCollection", "public boolean removeAll(Collection<? extends Object> arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "iterator", "java.util", "AbstractCollection", "public abstract Iterator<E> iterator()" ], [ "add", "java.util", "AbstractCollection", "public boolean add(E arg0)" ], [ "size", "java.util", "AbstractCollection", "public abstract int size()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "AbstractPathElementList", "protected Graph<V,E> graph;" ], [ "maxSize", "org.jgrapht.alg", "AbstractPathElementList", "protected int maxSize;" ], [ "pathElements", "org.jgrapht.alg", "AbstractPathElementList", "protected ArrayList<T> pathElements = new ArrayList<T>();" ], [ "vertex", "org.jgrapht.alg", "AbstractPathElementList", "protected V vertex;" ], [ "modCount", "java.util", "AbstractList", "protected int modCount;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25777,
  "oracle" : "maxSize<0 || maxSize==0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "AbstractPathElementList",
  "javadocTag" : "@throws NullPointerException if the specified prevPathElementList or edge\nis <code>null</code>.",
  "methodJavadoc" : "    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */",
  "methodSourceCode" : "protected AbstractPathElementList(Graph<V, E> graph, int maxSize, AbstractPathElementList<V, E, T> elementList, E edge){\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    if (elementList == null) {\n        throw new NullPointerException(\"elementList is null\");\n    }\n    if (edge == null) {\n        throw new NullPointerException(\"edge is null\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n}",
  "classJavadoc" : "/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * AbstractPathElementList.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\nabstract class AbstractPathElementList<V,\n    E, T extends AbstractPathElement<V, E>>\n    extends AbstractList<T>\n{\n    protected Graph<V, E> graph;\n\n    /**\n     * Max number of stored paths.\n     */\n    protected int maxSize;\n\n    /**\n     * Stored paths, list of <code>AbstractPathElement</code>.\n     */\n    protected ArrayList<T> pathElements = new ArrayList<T>();\n\n    /**\n     * Target vertex of the paths.\n     */\n    protected V vertex;\n\n    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        AbstractPathElementList<V, E, T> elementList,\n        E edge)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (elementList == null) {\n            throw new NullPointerException(\"elementList is null\");\n        }\n        if (edge == null) {\n            throw new NullPointerException(\"edge is null\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex =\n            Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n    }\n\n    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement</code> is not\n     * empty.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        T pathElement)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (pathElement == null) {\n            throw new NullPointerException(\"pathElement is null\");\n        }\n        if (pathElement.getPrevEdge() != null) {\n            throw new IllegalArgumentException(\"path must be empty\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = pathElement.getVertex();\n\n        this.pathElements.add(pathElement);\n    }\n\n    /**\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = vertex;\n    }\n\n    /**\n     * Returns path <code>AbstractPathElement</code> stored at the specified\n     * index.\n     */\n    @Override public T get(int index)\n    {\n        return this.pathElements.get(index);\n    }\n\n    /**\n     * Returns target vertex.\n     */\n    public V getVertex()\n    {\n        return this.vertex;\n    }\n\n    /**\n     * Returns the number of paths stored in the list.\n     */\n    @Override public int size()\n    {\n        return this.pathElements.size();\n    }\n}\n\n// End AbstractPathElementList.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "maxSize", "", "int" ], [ "elementList", "org.jgrapht.alg.AbstractPathElementList", "AbstractPathElementList<V, E, T>" ], [ "edge", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "subList", "java.util", "AbstractList", "public List<E> subList(int arg0, int arg1)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getVertex", "org.jgrapht.alg", "AbstractPathElementList", "public V getVertex()" ], [ "get", "java.util", "AbstractList", "public abstract E get(int arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "remove", "java.util", "AbstractList", "public E remove(int arg0)" ], [ "isEmpty", "java.util", "AbstractCollection", "public boolean isEmpty()" ], [ "indexOf", "java.util", "AbstractList", "public int indexOf(Object arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator()" ], [ "remove", "java.util", "AbstractCollection", "public boolean remove(Object arg0)" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "add", "java.util", "AbstractList", "public boolean add(E arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "lastIndexOf", "java.util", "AbstractList", "public int lastIndexOf(Object arg0)" ], [ "equals", "java.util", "AbstractList", "public boolean equals(Object arg0)" ], [ "iterator", "java.util", "AbstractList", "public Iterator<E> iterator()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public Object[] toArray()" ], [ "size", "org.jgrapht.alg", "AbstractPathElementList", "public int size()" ], [ "toString", "java.util", "AbstractCollection", "public String toString()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "set", "java.util", "AbstractList", "public E set(int arg0, E arg1)" ], [ "contains", "java.util", "AbstractCollection", "public boolean contains(Object arg0)" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator(int arg0)" ], [ "addAll", "java.util", "AbstractList", "public boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "get", "org.jgrapht.alg", "AbstractPathElementList", "public T get(int index)" ], [ "retainAll", "java.util", "AbstractCollection", "public boolean retainAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public <T> T[] toArray(T[] arg0)" ], [ "removeAll", "java.util", "AbstractCollection", "public boolean removeAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "AbstractCollection", "public boolean addAll(Collection<? extends E> arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "containsAll", "java.util", "AbstractCollection", "public boolean containsAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "AbstractList", "public int hashCode()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "size", "java.util", "AbstractCollection", "public abstract int size()" ], [ "iterator", "java.util", "AbstractCollection", "public abstract Iterator<E> iterator()" ], [ "add", "java.util", "AbstractCollection", "public boolean add(E arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "AbstractPathElementList", "protected Graph<V,E> graph;" ], [ "maxSize", "org.jgrapht.alg", "AbstractPathElementList", "protected int maxSize;" ], [ "pathElements", "org.jgrapht.alg", "AbstractPathElementList", "protected ArrayList<T> pathElements = new ArrayList<T>();" ], [ "vertex", "org.jgrapht.alg", "AbstractPathElementList", "protected V vertex;" ], [ "modCount", "java.util", "AbstractList", "protected int modCount;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25778,
  "oracle" : "pathElement==null;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "AbstractPathElementList",
  "javadocTag" : "@throws NullPointerException if the specified path-element is <code>\nnull</code>.",
  "methodJavadoc" : "    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement</code> is not\n     * empty.\n     */",
  "methodSourceCode" : "protected AbstractPathElementList(Graph<V, E> graph, int maxSize, T pathElement){\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    if (pathElement == null) {\n        throw new NullPointerException(\"pathElement is null\");\n    }\n    if (pathElement.getPrevEdge() != null) {\n        throw new IllegalArgumentException(\"path must be empty\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = pathElement.getVertex();\n    this.pathElements.add(pathElement);\n}",
  "classJavadoc" : "/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * AbstractPathElementList.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\nabstract class AbstractPathElementList<V,\n    E, T extends AbstractPathElement<V, E>>\n    extends AbstractList<T>\n{\n    protected Graph<V, E> graph;\n\n    /**\n     * Max number of stored paths.\n     */\n    protected int maxSize;\n\n    /**\n     * Stored paths, list of <code>AbstractPathElement</code>.\n     */\n    protected ArrayList<T> pathElements = new ArrayList<T>();\n\n    /**\n     * Target vertex of the paths.\n     */\n    protected V vertex;\n\n    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        AbstractPathElementList<V, E, T> elementList,\n        E edge)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (elementList == null) {\n            throw new NullPointerException(\"elementList is null\");\n        }\n        if (edge == null) {\n            throw new NullPointerException(\"edge is null\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex =\n            Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n    }\n\n    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement</code> is not\n     * empty.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        T pathElement)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (pathElement == null) {\n            throw new NullPointerException(\"pathElement is null\");\n        }\n        if (pathElement.getPrevEdge() != null) {\n            throw new IllegalArgumentException(\"path must be empty\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = pathElement.getVertex();\n\n        this.pathElements.add(pathElement);\n    }\n\n    /**\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = vertex;\n    }\n\n    /**\n     * Returns path <code>AbstractPathElement</code> stored at the specified\n     * index.\n     */\n    @Override public T get(int index)\n    {\n        return this.pathElements.get(index);\n    }\n\n    /**\n     * Returns target vertex.\n     */\n    public V getVertex()\n    {\n        return this.vertex;\n    }\n\n    /**\n     * Returns the number of paths stored in the list.\n     */\n    @Override public int size()\n    {\n        return this.pathElements.size();\n    }\n}\n\n// End AbstractPathElementList.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "maxSize", "", "int" ], [ "pathElement", "", "AbstractPathElement" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "add", "java.util", "AbstractList", "public boolean add(E arg0)" ], [ "lastIndexOf", "java.util", "AbstractList", "public int lastIndexOf(Object arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "indexOf", "java.util", "AbstractList", "public int indexOf(Object arg0)" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator()" ], [ "get", "java.util", "AbstractList", "public abstract E get(int arg0)" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator(int arg0)" ], [ "size", "org.jgrapht.alg", "AbstractPathElementList", "public int size()" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "get", "org.jgrapht.alg", "AbstractPathElementList", "public T get(int index)" ], [ "subList", "java.util", "AbstractList", "public List<E> subList(int arg0, int arg1)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "getVertex", "org.jgrapht.alg", "AbstractPathElementList", "public V getVertex()" ], [ "iterator", "java.util", "AbstractList", "public Iterator<E> iterator()" ], [ "retainAll", "java.util", "AbstractCollection", "public boolean retainAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "AbstractCollection", "public boolean addAll(Collection<? extends E> arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "addAll", "java.util", "AbstractList", "public boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "equals", "java.util", "AbstractList", "public boolean equals(Object arg0)" ], [ "isEmpty", "java.util", "AbstractCollection", "public boolean isEmpty()" ], [ "removeAll", "java.util", "AbstractCollection", "public boolean removeAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "AbstractCollection", "public boolean containsAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "contains", "java.util", "AbstractCollection", "public boolean contains(Object arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public <T> T[] toArray(T[] arg0)" ], [ "remove", "java.util", "AbstractList", "public E remove(int arg0)" ], [ "set", "java.util", "AbstractList", "public E set(int arg0, E arg1)" ], [ "remove", "java.util", "AbstractCollection", "public boolean remove(Object arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public Object[] toArray()" ], [ "toString", "java.util", "AbstractCollection", "public String toString()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "hashCode", "java.util", "AbstractList", "public int hashCode()" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "AbstractPathElementList", "protected Graph<V,E> graph;" ], [ "maxSize", "org.jgrapht.alg", "AbstractPathElementList", "protected int maxSize;" ], [ "pathElements", "org.jgrapht.alg", "AbstractPathElementList", "protected ArrayList<T> pathElements = new ArrayList<T>();" ], [ "vertex", "org.jgrapht.alg", "AbstractPathElementList", "protected V vertex;" ], [ "modCount", "java.util", "AbstractList", "protected int modCount;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25779,
  "oracle" : "maxSize<0 || maxSize==0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "AbstractPathElementList",
  "javadocTag" : "@throws IllegalArgumentException if <code>maxSize</code> is negative or\n0.",
  "methodJavadoc" : "    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement</code> is not\n     * empty.\n     */",
  "methodSourceCode" : "protected AbstractPathElementList(Graph<V, E> graph, int maxSize, T pathElement){\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    if (pathElement == null) {\n        throw new NullPointerException(\"pathElement is null\");\n    }\n    if (pathElement.getPrevEdge() != null) {\n        throw new IllegalArgumentException(\"path must be empty\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = pathElement.getVertex();\n    this.pathElements.add(pathElement);\n}",
  "classJavadoc" : "/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * AbstractPathElementList.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\nabstract class AbstractPathElementList<V,\n    E, T extends AbstractPathElement<V, E>>\n    extends AbstractList<T>\n{\n    protected Graph<V, E> graph;\n\n    /**\n     * Max number of stored paths.\n     */\n    protected int maxSize;\n\n    /**\n     * Stored paths, list of <code>AbstractPathElement</code>.\n     */\n    protected ArrayList<T> pathElements = new ArrayList<T>();\n\n    /**\n     * Target vertex of the paths.\n     */\n    protected V vertex;\n\n    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        AbstractPathElementList<V, E, T> elementList,\n        E edge)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (elementList == null) {\n            throw new NullPointerException(\"elementList is null\");\n        }\n        if (edge == null) {\n            throw new NullPointerException(\"edge is null\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex =\n            Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n    }\n\n    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement</code> is not\n     * empty.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        T pathElement)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (pathElement == null) {\n            throw new NullPointerException(\"pathElement is null\");\n        }\n        if (pathElement.getPrevEdge() != null) {\n            throw new IllegalArgumentException(\"path must be empty\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = pathElement.getVertex();\n\n        this.pathElements.add(pathElement);\n    }\n\n    /**\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = vertex;\n    }\n\n    /**\n     * Returns path <code>AbstractPathElement</code> stored at the specified\n     * index.\n     */\n    @Override public T get(int index)\n    {\n        return this.pathElements.get(index);\n    }\n\n    /**\n     * Returns target vertex.\n     */\n    public V getVertex()\n    {\n        return this.vertex;\n    }\n\n    /**\n     * Returns the number of paths stored in the list.\n     */\n    @Override public int size()\n    {\n        return this.pathElements.size();\n    }\n}\n\n// End AbstractPathElementList.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "maxSize", "", "int" ], [ "pathElement", "", "AbstractPathElement" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "set", "java.util", "AbstractList", "public E set(int arg0, E arg1)" ], [ "equals", "java.util", "AbstractList", "public boolean equals(Object arg0)" ], [ "getVertex", "org.jgrapht.alg", "AbstractPathElementList", "public V getVertex()" ], [ "toArray", "java.util", "AbstractCollection", "public Object[] toArray()" ], [ "iterator", "java.util", "AbstractList", "public Iterator<E> iterator()" ], [ "addAll", "java.util", "AbstractList", "public boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "indexOf", "java.util", "AbstractList", "public int indexOf(Object arg0)" ], [ "remove", "java.util", "AbstractList", "public E remove(int arg0)" ], [ "contains", "java.util", "AbstractCollection", "public boolean contains(Object arg0)" ], [ "addAll", "java.util", "AbstractCollection", "public boolean addAll(Collection<? extends E> arg0)" ], [ "size", "org.jgrapht.alg", "AbstractPathElementList", "public int size()" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "get", "org.jgrapht.alg", "AbstractPathElementList", "public T get(int index)" ], [ "containsAll", "java.util", "AbstractCollection", "public boolean containsAll(Collection<? extends Object> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "toString", "java.util", "AbstractCollection", "public String toString()" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator(int arg0)" ], [ "lastIndexOf", "java.util", "AbstractList", "public int lastIndexOf(Object arg0)" ], [ "hashCode", "java.util", "AbstractList", "public int hashCode()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "get", "java.util", "AbstractList", "public abstract E get(int arg0)" ], [ "isEmpty", "java.util", "AbstractCollection", "public boolean isEmpty()" ], [ "add", "java.util", "AbstractList", "public boolean add(E arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "toArray", "java.util", "AbstractCollection", "public <T> T[] toArray(T[] arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "subList", "java.util", "AbstractList", "public List<E> subList(int arg0, int arg1)" ], [ "remove", "java.util", "AbstractCollection", "public boolean remove(Object arg0)" ], [ "retainAll", "java.util", "AbstractCollection", "public boolean retainAll(Collection<? extends Object> arg0)" ], [ "removeAll", "java.util", "AbstractCollection", "public boolean removeAll(Collection<? extends Object> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "AbstractPathElementList", "protected Graph<V,E> graph;" ], [ "maxSize", "org.jgrapht.alg", "AbstractPathElementList", "protected int maxSize;" ], [ "pathElements", "org.jgrapht.alg", "AbstractPathElementList", "protected ArrayList<T> pathElements = new ArrayList<T>();" ], [ "vertex", "org.jgrapht.alg", "AbstractPathElementList", "protected V vertex;" ], [ "modCount", "java.util", "AbstractList", "protected int modCount;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25780,
  "oracle" : "maxSize<0 || maxSize==0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.alg",
  "className" : "AbstractPathElementList",
  "javadocTag" : "@throws IllegalArgumentException if <code>maxSize</code> is negative or\n0.",
  "methodJavadoc" : "    /**\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */",
  "methodSourceCode" : "protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex){\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = vertex;\n}",
  "classJavadoc" : "/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2010, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * AbstractPathElementList.java\n * -------------------------\n * (C) Copyright 2007-2010, by France Telecom\n *\n * Original Author:  Guillaume Boulmier and Contributors.\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Jun-2007 : Initial revision (GB);\n * 05-Jul-2007 : Added support for generics (JVS);\n * 06-Dec-2010 : Bugfixes (GB);\n *\n */\npackage org.jgrapht.alg;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * List of paths <code>AbstractPathElement</code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n */\nabstract class AbstractPathElementList<V,\n    E, T extends AbstractPathElement<V, E>>\n    extends AbstractList<T>\n{\n    protected Graph<V, E> graph;\n\n    /**\n     * Max number of stored paths.\n     */\n    protected int maxSize;\n\n    /**\n     * Stored paths, list of <code>AbstractPathElement</code>.\n     */\n    protected ArrayList<T> pathElements = new ArrayList<T>();\n\n    /**\n     * Target vertex of the paths.\n     */\n    protected V vertex;\n\n    /**\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement</code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        AbstractPathElementList<V, E, T> elementList,\n        E edge)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (elementList == null) {\n            throw new NullPointerException(\"elementList is null\");\n        }\n        if (edge == null) {\n            throw new NullPointerException(\"edge is null\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex =\n            Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n    }\n\n    /**\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null</code>.\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement</code> is not\n     * empty.\n     */\n    protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        T pathElement)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (pathElement == null) {\n            throw new NullPointerException(\"pathElement is null\");\n        }\n        if (pathElement.getPrevEdge() != null) {\n            throw new IllegalArgumentException(\"path must be empty\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = pathElement.getVertex();\n\n        this.pathElements.add(pathElement);\n    }\n\n    /**\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws IllegalArgumentException if <code>maxSize</code> is negative or\n     * 0.\n     */\n    protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = vertex;\n    }\n\n    /**\n     * Returns path <code>AbstractPathElement</code> stored at the specified\n     * index.\n     */\n    @Override public T get(int index)\n    {\n        return this.pathElements.get(index);\n    }\n\n    /**\n     * Returns target vertex.\n     */\n    public V getVertex()\n    {\n        return this.vertex;\n    }\n\n    /**\n     * Returns the number of paths stored in the list.\n     */\n    @Override public int size()\n    {\n        return this.pathElements.size();\n    }\n}\n\n// End AbstractPathElementList.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "0", "int" ], [ "0", "int" ] ],
  "tokensMethodArguments" : [ [ "graph", "org.jgrapht.Graph", "Graph<V, E>" ], [ "maxSize", "", "int" ], [ "vertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addAll", "java.util", "AbstractCollection", "public boolean addAll(Collection<? extends E> arg0)" ], [ "hashCode", "java.util", "AbstractList", "public int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "containsAll", "java.util", "AbstractCollection", "public boolean containsAll(Collection<? extends Object> arg0)" ], [ "iterator", "java.util", "AbstractList", "public Iterator<E> iterator()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator(int arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "lastIndexOf", "java.util", "AbstractList", "public int lastIndexOf(Object arg0)" ], [ "remove", "java.util", "AbstractList", "public E remove(int arg0)" ], [ "isEmpty", "java.util", "AbstractCollection", "public boolean isEmpty()" ], [ "subList", "java.util", "AbstractList", "public List<E> subList(int arg0, int arg1)" ], [ "toString", "java.util", "AbstractCollection", "public String toString()" ], [ "retainAll", "java.util", "AbstractCollection", "public boolean retainAll(Collection<? extends Object> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public <T> T[] toArray(T[] arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "get", "org.jgrapht.alg", "AbstractPathElementList", "public T get(int index)" ], [ "getVertex", "org.jgrapht.alg", "AbstractPathElementList", "public V getVertex()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "add", "java.util", "AbstractList", "public boolean add(E arg0)" ], [ "equals", "java.util", "AbstractList", "public boolean equals(Object arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public Object[] toArray()" ], [ "set", "java.util", "AbstractList", "public E set(int arg0, E arg1)" ], [ "get", "java.util", "AbstractList", "public abstract E get(int arg0)" ], [ "addAll", "java.util", "AbstractList", "public boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "indexOf", "java.util", "AbstractList", "public int indexOf(Object arg0)" ], [ "removeAll", "java.util", "AbstractCollection", "public boolean removeAll(Collection<? extends Object> arg0)" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator()" ], [ "contains", "java.util", "AbstractCollection", "public boolean contains(Object arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "size", "org.jgrapht.alg", "AbstractPathElementList", "public int size()" ], [ "remove", "java.util", "AbstractCollection", "public boolean remove(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "containsVertex", "org.jgrapht", "Graph", "public abstract boolean containsVertex(V arg0)" ], [ "getEdgeTarget", "org.jgrapht", "Graph", "public abstract V getEdgeTarget(E arg0)" ], [ "addVertex", "org.jgrapht", "Graph", "public abstract boolean addVertex(V arg0)" ], [ "edgesOf", "org.jgrapht", "Graph", "public abstract Set<E> edgesOf(V arg0)" ], [ "edgeSet", "org.jgrapht", "Graph", "public abstract Set<E> edgeSet()" ], [ "getEdgeSource", "org.jgrapht", "Graph", "public abstract V getEdgeSource(E arg0)" ], [ "getEdge", "org.jgrapht", "Graph", "public abstract E getEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract boolean removeEdge(E arg0)" ], [ "getEdgeWeight", "org.jgrapht", "Graph", "public abstract double getEdgeWeight(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract E addEdge(V arg0, V arg1)" ], [ "getAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract Set<E> removeAllEdges(V arg0, V arg1)" ], [ "vertexSet", "org.jgrapht", "Graph", "public abstract Set<V> vertexSet()" ], [ "removeVertex", "org.jgrapht", "Graph", "public abstract boolean removeVertex(V arg0)" ], [ "getEdgeFactory", "org.jgrapht", "Graph", "public abstract EdgeFactory<V, E> getEdgeFactory()" ], [ "removeEdge", "org.jgrapht", "Graph", "public abstract E removeEdge(V arg0, V arg1)" ], [ "removeAllVertices", "org.jgrapht", "Graph", "public abstract boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "removeAllEdges", "org.jgrapht", "Graph", "public abstract boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(E arg0)" ], [ "addEdge", "org.jgrapht", "Graph", "public abstract boolean addEdge(V arg0, V arg1, E arg2)" ], [ "containsEdge", "org.jgrapht", "Graph", "public abstract boolean containsEdge(V arg0, V arg1)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "graph", "org.jgrapht.alg", "AbstractPathElementList", "protected Graph<V,E> graph;" ], [ "maxSize", "org.jgrapht.alg", "AbstractPathElementList", "protected int maxSize;" ], [ "pathElements", "org.jgrapht.alg", "AbstractPathElementList", "protected ArrayList<T> pathElements = new ArrayList<T>();" ], [ "vertex", "org.jgrapht.alg", "AbstractPathElementList", "protected V vertex;" ], [ "modCount", "java.util", "AbstractList", "protected int modCount;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25781,
  "oracle" : "size<0;",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.generate",
  "className" : "LinearGraphGenerator",
  "javadocTag" : "@throws IllegalArgumentException if the specified size is negative.",
  "methodJavadoc" : "    /**\n     * Construct a new LinearGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */",
  "methodSourceCode" : "public LinearGraphGenerator(int size){\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}",
  "classJavadoc" : "/**\n * Generates a linear graph of any size. For a directed graph, the edges are\n * oriented from START_VERTEX to END_VERTEX.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * LinearGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by John V. Sichi and Contributors.\n *\n * Original Author:  John V. Sichi\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 16-Sep-2003 : Initial revision (JVS);\n *\n */\npackage org.jgrapht.generate;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Generates a linear graph of any size. For a directed graph, the edges are\n * oriented from START_VERTEX to END_VERTEX.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n */\npublic class LinearGraphGenerator<V, E>\n    implements GraphGenerator<V, E, V>\n{\n    /**\n     * Role for the first vertex generated.\n     */\n    public static final String START_VERTEX = \"Start Vertex\";\n\n    /**\n     * Role for the last vertex generated.\n     */\n    public static final String END_VERTEX = \"End Vertex\";\n\n    private int size;\n\n    /**\n     * Construct a new LinearGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     */\n    public LinearGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        V lastVertex = null;\n\n        for (int i = 0; i < size; ++i) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n\n            if (lastVertex == null) {\n                if (resultMap != null) {\n                    resultMap.put(START_VERTEX, newVertex);\n                }\n            } else {\n                target.addEdge(lastVertex, newVertex);\n            }\n\n            lastVertex = newVertex;\n        }\n\n        if ((resultMap != null) && (lastVertex != null)) {\n            resultMap.put(END_VERTEX, lastVertex);\n        }\n    }\n}\n\n// End LinearGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "size", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25782,
  "oracle" : "true ? methodResultID.equals(this.getG2()) : true;",
  "oracleType" : "NORMAL_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.graph",
  "className" : "GraphUnion",
  "javadocTag" : "@return G<sub>1</sub>",
  "methodJavadoc" : "    /**\n     * @return G<sub>1</sub>\n     */",
  "methodSourceCode" : "public G getG1(){\n    return g1;\n}",
  "classJavadoc" : "/**\n * <p>Read-only union of two graphs: G<sub>1</sub> and G<sub>2</sub>. If\n * G<sub>1</sub> = (V<sub>1</sub>, E<sub>1</sub>) and G<sub>2</sub> =\n * (V<sub>2</sub>, E<sub>2</sub>) then their union G = (V, E), where V is the\n * union of V<sub>1</sub> and V<sub>2</sub>, and E is the union of E<sub>1</sub>\n * and E<sub>1</sub>.</p>\n *\n * <p><tt>GraphUnion</tt> implements <tt>Graph</tt> interface. <tt>\n * GraphUnion</tt> uses <tt>WeightCombiner</tt> to choose policy for calculating\n * edge weight.</p>\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2009, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * GraphUnion.java\n * -------------------------\n * (C) Copyright 2009-2009, by Ilya Razenshteyn\n *\n * Original Author:  Ilya Razenshteyn and Contributors.\n *\n * $Id$\n *\n * Changes\n * -------\n * 02-Feb-2009 : Initial revision (IR);\n *\n */\npackage org.jgrapht.graph;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.util.*;\n\n\n/**\n * <p>Read-only union of two graphs: G<sub>1</sub> and G<sub>2</sub>. If\n * G<sub>1</sub> = (V<sub>1</sub>, E<sub>1</sub>) and G<sub>2</sub> =\n * (V<sub>2</sub>, E<sub>2</sub>) then their union G = (V, E), where V is the\n * union of V<sub>1</sub> and V<sub>2</sub>, and E is the union of E<sub>1</sub>\n * and E<sub>1</sub>.</p>\n *\n * <p><tt>GraphUnion</tt> implements <tt>Graph</tt> interface. <tt>\n * GraphUnion</tt> uses <tt>WeightCombiner</tt> to choose policy for calculating\n * edge weight.</p>\n */\npublic class GraphUnion<V, E, G extends Graph<V, E>>\n    extends AbstractGraph<V, E>\n    implements Serializable\n{\n    private static final long serialVersionUID = -740199233080172450L;\n\n    private static final String READ_ONLY = \"union of graphs is read-only\";\n\n    private G g1;\n    private G g2;\n    private WeightCombiner operator;\n\n    public GraphUnion(G g1, G g2, WeightCombiner operator)\n    {\n        if (g1 == null) {\n            throw new NullPointerException(\"g1 is null\");\n        }\n        if (g2 == null) {\n            throw new NullPointerException(\"g2 is null\");\n        }\n        if (g1 == g2) {\n            throw new IllegalArgumentException(\"g1 is equal to g2\");\n        }\n        this.g1 = g1;\n        this.g2 = g2;\n        this.operator = operator;\n    }\n\n    public GraphUnion(G g1, G g2)\n    {\n        this(g1, g2, WeightCombiner.SUM);\n    }\n\n    @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        if (g1.containsVertex(sourceVertex)\n            && g1.containsVertex(targetVertex))\n        {\n            res.addAll(g1.getAllEdges(sourceVertex, targetVertex));\n        }\n        if (g2.containsVertex(sourceVertex)\n            && g2.containsVertex(targetVertex))\n        {\n            res.addAll(g2.getAllEdges(sourceVertex, targetVertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }\n\n    @Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        E res = null;\n        if (g1.containsVertex(sourceVertex)\n            && g1.containsVertex(targetVertex))\n        {\n            res = g1.getEdge(sourceVertex, targetVertex);\n        }\n        if ((res == null)\n            && g2.containsVertex(sourceVertex)\n            && g2.containsVertex(targetVertex))\n        {\n            res = g2.getEdge(sourceVertex, targetVertex);\n        }\n        return res;\n    }\n\n    /**\n     * Throws <tt>UnsupportedOperationException</tt>, because <tt>\n     * GraphUnion</tt> is read-only.\n     */\n    @Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }\n\n    /**\n     * Throws <tt>UnsupportedOperationException</tt>, because <tt>\n     * GraphUnion</tt> is read-only.\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }\n\n    /**\n     * Throws <tt>UnsupportedOperationException</tt>, because <tt>\n     * GraphUnion</tt> is read-only.\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }\n\n    /**\n     * Throws <tt>UnsupportedOperationException</tt>, because <tt>\n     * GraphUnion</tt> is read-only.\n     */\n    @Override public boolean addVertex(V v)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }\n\n    @Override public boolean containsEdge(E e)\n    {\n        return g1.containsEdge(e) || g2.containsEdge(e);\n    }\n\n    @Override public boolean containsVertex(V v)\n    {\n        return g1.containsVertex(v) || g2.containsVertex(v);\n    }\n\n    @Override public Set<E> edgeSet()\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        res.addAll(g1.edgeSet());\n        res.addAll(g2.edgeSet());\n        return Collections.unmodifiableSet(res);\n    }\n\n    @Override public Set<E> edgesOf(V vertex)\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        if (g1.containsVertex(vertex)) {\n            res.addAll(g1.edgesOf(vertex));\n        }\n        if (g2.containsVertex(vertex)) {\n            res.addAll(g2.edgesOf(vertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }\n\n    /**\n     * Throws <tt>UnsupportedOperationException</tt>, because <tt>\n     * GraphUnion</tt> is read-only.\n     */\n    @Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }\n\n    /**\n     * Throws <tt>UnsupportedOperationException</tt>, because <tt>\n     * GraphUnion</tt> is read-only.\n     */\n    @Override public boolean removeEdge(E e)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }\n\n    /**\n     * Throws <tt>UnsupportedOperationException</tt>, because <tt>\n     * GraphUnion</tt> is read-only.\n     */\n    @Override public boolean removeVertex(V v)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }\n\n    @Override public Set<V> vertexSet()\n    {\n        Set<V> res = new HashSet<V>();\n        res.addAll(g1.vertexSet());\n        res.addAll(g2.vertexSet());\n        return Collections.unmodifiableSet(res);\n    }\n\n    @Override public V getEdgeSource(E e)\n    {\n        if (g1.containsEdge(e)) {\n            return g1.getEdgeSource(e);\n        }\n        if (g2.containsEdge(e)) {\n            return g2.getEdgeSource(e);\n        }\n        return null;\n    }\n\n    @Override public V getEdgeTarget(E e)\n    {\n        if (g1.containsEdge(e)) {\n            return g1.getEdgeTarget(e);\n        }\n        if (g2.containsEdge(e)) {\n            return g2.getEdgeTarget(e);\n        }\n        return null;\n    }\n\n    @Override public double getEdgeWeight(E e)\n    {\n        if (g1.containsEdge(e) && g2.containsEdge(e)) {\n            return operator.combine(g1.getEdgeWeight(e), g2.getEdgeWeight(e));\n        }\n        if (g1.containsEdge(e)) {\n            return g1.getEdgeWeight(e);\n        }\n        if (g2.containsEdge(e)) {\n            return g2.getEdgeWeight(e);\n        }\n        throw new IllegalArgumentException(\"no such edge in the union\");\n    }\n\n    /**\n     * @return G<sub>1</sub>\n     */\n    public G getG1()\n    {\n        return g1;\n    }\n\n    /**\n     * @return G<sub>2</sub>\n     */\n    public G getG2()\n    {\n        return g2;\n    }\n}\n\n// End GraphUnion.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "containsEdge", "org.jgrapht.graph", "GraphUnion", "public boolean containsEdge(E e)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "getEdgeFactory", "org.jgrapht.graph", "GraphUnion", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "addEdge", "org.jgrapht.graph", "GraphUnion", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "getEdge", "org.jgrapht.graph", "GraphUnion", "public E getEdge(V sourceVertex, V targetVertex)" ], [ "getEdgeSource", "org.jgrapht.graph", "GraphUnion", "public V getEdgeSource(E e)" ], [ "vertexSet", "org.jgrapht.graph", "GraphUnion", "public Set<V> vertexSet()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "addEdge", "org.jgrapht.graph", "GraphUnion", "public boolean addEdge(V sourceVertex, V targetVertex, E e)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht.graph", "GraphUnion", "public Set<E> edgeSet()" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "getG1", "org.jgrapht.graph", "GraphUnion", "public G getG1()" ], [ "getEdgeTarget", "org.jgrapht.graph", "GraphUnion", "public V getEdgeTarget(E e)" ], [ "containsVertex", "org.jgrapht.graph", "GraphUnion", "public boolean containsVertex(V v)" ], [ "removeAllVertices", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeEdge", "org.jgrapht.graph", "GraphUnion", "public boolean removeEdge(E e)" ], [ "getAllEdges", "org.jgrapht.graph", "GraphUnion", "public Set<E> getAllEdges(V sourceVertex, V targetVertex)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "removeVertex", "org.jgrapht.graph", "GraphUnion", "public boolean removeVertex(V v)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "addVertex", "org.jgrapht.graph", "GraphUnion", "public boolean addVertex(V v)" ], [ "getEdgeWeight", "org.jgrapht.graph", "GraphUnion", "public double getEdgeWeight(E e)" ], [ "getG2", "org.jgrapht.graph", "GraphUnion", "public G getG2()" ], [ "edgesOf", "org.jgrapht.graph", "GraphUnion", "public Set<E> edgesOf(V vertex)" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "removeEdge", "org.jgrapht.graph", "GraphUnion", "public E removeEdge(V sourceVertex, V targetVertex)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25789,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental",
  "className" : "PartiteRandomGraphGenerator",
  "javadocTag" : "@throws IllegalArgumentException",
  "methodJavadoc" : "    /**\n     * Construct a new PartiteRandomGraphGenerator for a bipartite graph.\n     *\n     * @param numVertices1 number of vertices in the first partition\n     * @param numVertices2 number of vertices in the second partition\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */",
  "methodSourceCode" : "public PartiteRandomGraphGenerator(int numVertices1, int numVertices2, int numEdges){\n    if ((numVertices1 < 0) || (numVertices2 < 0)) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    if ((numEdges < 0) || (numEdges > (numVertices1 * numVertices2))) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    final int[] numVertices = { numVertices1, numVertices2 };\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}",
  "classJavadoc" : "/**\n * PartiteRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">partite uniform random\n * graph</a> of any size. A partite uniform random graph contains edges chosen\n * independently uniformly at random from the set of possible edges between\n * partition classes.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * PartiteRandomGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by Michael Behrisch and Contributors.\n *\n * Original Author:  Michael Behrisch\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 13-Sep-2004 : Initial revision (MB);\n *\n */\n// package org.jgrapht.generate;\npackage org.jgrapht.experimental;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.generate.*;\n\n\n/**\n * PartiteRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">partite uniform random\n * graph</a> of any size. A partite uniform random graph contains edges chosen\n * independently uniformly at random from the set of possible edges between\n * partition classes.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */\npublic class PartiteRandomGraphGenerator<V, E>\n    implements GraphGenerator<V, E, Object[]>\n{\n    private final int [] numVertices;\n    private final int numEdges;\n\n    /**\n     * Construct a new PartiteRandomGraphGenerator for a bipartite graph.\n     *\n     * @param numVertices1 number of vertices in the first partition\n     * @param numVertices2 number of vertices in the second partition\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */\n    public PartiteRandomGraphGenerator(\n        int numVertices1,\n        int numVertices2,\n        int numEdges)\n    {\n        if ((numVertices1 < 0) || (numVertices2 < 0)) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        if ((numEdges < 0) || (numEdges > (numVertices1 * numVertices2))) {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        final int [] numVertices = {\n            numVertices1,\n            numVertices2\n        };\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }\n\n    /**\n     * Construct a new PartiteRandomGraphGenerator for a k-partite graph.\n     *\n     * @param numVertices number of vertices in the k partitions\n     * @param numEdges number of edges to be generated between any two\n     * partitions\n     *\n     * @throws IllegalArgumentException\n     */\n    public PartiteRandomGraphGenerator(int [] numVertices, int numEdges)\n    {\n        if (numEdges < 0) {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        for (int i = 0; i < numVertices.length; i++) {\n            if (numVertices[i] < 0) {\n                throw new IllegalArgumentException(\"must be non-negative\");\n            }\n\n            for (int j = 0; j < i; j++) {\n                if (numEdges > (numVertices[i] * numVertices[j])) {\n                    throw new IllegalArgumentException(\n                        \"illegal number of edges\");\n                }\n            }\n        }\n\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }\n\n    /**\n     * TODO hb 30-nov-05: document me\n     *\n     * @param target\n     * @param vertexFactory\n     * @param resultMap some array of vertices\n     *\n     * @see GraphGenerator#generateGraph\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, Object[]> resultMap)\n    {\n        Object [][] vertices = new Object[numVertices.length][];\n\n        for (int i = 0; i < numVertices.length; i++) {\n            vertices[i] =\n                RandomGraphHelper.addVertices(\n                    target,\n                    vertexFactory,\n                    numVertices[i]);\n\n            if (resultMap != null) {\n                resultMap.put(Integer.toString(i), vertices[i]);\n            }\n\n            for (int j = 0; j < i; j++) {\n                RandomGraphHelper.addEdges(\n                    target,\n                    Arrays.asList(vertices[i]),\n                    Arrays.asList(vertices[j]),\n                    numEdges);\n            }\n        }\n    }\n}\n\n// End PartiteRandomGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ] ],
  "tokensMethodArguments" : [ [ "numVertices1", "", "int" ], [ "numVertices2", "", "int" ], [ "numEdges", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25792,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental",
  "className" : "PartiteRandomGraphGenerator",
  "javadocTag" : "@throws IllegalArgumentException",
  "methodJavadoc" : "    /**\n     * Construct a new PartiteRandomGraphGenerator for a k-partite graph.\n     *\n     * @param numVertices number of vertices in the k partitions\n     * @param numEdges number of edges to be generated between any two\n     * partitions\n     *\n     * @throws IllegalArgumentException\n     */",
  "methodSourceCode" : "public PartiteRandomGraphGenerator(int[] numVertices, int numEdges){\n    if (numEdges < 0) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    for (int i = 0; i < numVertices.length; i++) {\n        if (numVertices[i] < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n        for (int j = 0; j < i; j++) {\n            if (numEdges > (numVertices[i] * numVertices[j])) {\n                throw new IllegalArgumentException(\"illegal number of edges\");\n            }\n        }\n    }\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}",
  "classJavadoc" : "/**\n * PartiteRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">partite uniform random\n * graph</a> of any size. A partite uniform random graph contains edges chosen\n * independently uniformly at random from the set of possible edges between\n * partition classes.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * PartiteRandomGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by Michael Behrisch and Contributors.\n *\n * Original Author:  Michael Behrisch\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 13-Sep-2004 : Initial revision (MB);\n *\n */\n// package org.jgrapht.generate;\npackage org.jgrapht.experimental;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.generate.*;\n\n\n/**\n * PartiteRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">partite uniform random\n * graph</a> of any size. A partite uniform random graph contains edges chosen\n * independently uniformly at random from the set of possible edges between\n * partition classes.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */\npublic class PartiteRandomGraphGenerator<V, E>\n    implements GraphGenerator<V, E, Object[]>\n{\n    private final int [] numVertices;\n    private final int numEdges;\n\n    /**\n     * Construct a new PartiteRandomGraphGenerator for a bipartite graph.\n     *\n     * @param numVertices1 number of vertices in the first partition\n     * @param numVertices2 number of vertices in the second partition\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */\n    public PartiteRandomGraphGenerator(\n        int numVertices1,\n        int numVertices2,\n        int numEdges)\n    {\n        if ((numVertices1 < 0) || (numVertices2 < 0)) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        if ((numEdges < 0) || (numEdges > (numVertices1 * numVertices2))) {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        final int [] numVertices = {\n            numVertices1,\n            numVertices2\n        };\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }\n\n    /**\n     * Construct a new PartiteRandomGraphGenerator for a k-partite graph.\n     *\n     * @param numVertices number of vertices in the k partitions\n     * @param numEdges number of edges to be generated between any two\n     * partitions\n     *\n     * @throws IllegalArgumentException\n     */\n    public PartiteRandomGraphGenerator(int [] numVertices, int numEdges)\n    {\n        if (numEdges < 0) {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        for (int i = 0; i < numVertices.length; i++) {\n            if (numVertices[i] < 0) {\n                throw new IllegalArgumentException(\"must be non-negative\");\n            }\n\n            for (int j = 0; j < i; j++) {\n                if (numEdges > (numVertices[i] * numVertices[j])) {\n                    throw new IllegalArgumentException(\n                        \"illegal number of edges\");\n                }\n            }\n        }\n\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }\n\n    /**\n     * TODO hb 30-nov-05: document me\n     *\n     * @param target\n     * @param vertexFactory\n     * @param resultMap some array of vertices\n     *\n     * @see GraphGenerator#generateGraph\n     */\n    @Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, Object[]> resultMap)\n    {\n        Object [][] vertices = new Object[numVertices.length][];\n\n        for (int i = 0; i < numVertices.length; i++) {\n            vertices[i] =\n                RandomGraphHelper.addVertices(\n                    target,\n                    vertexFactory,\n                    numVertices[i]);\n\n            if (resultMap != null) {\n                resultMap.put(Integer.toString(i), vertices[i]);\n            }\n\n            for (int j = 0; j < i; j++) {\n                RandomGraphHelper.addEdges(\n                    target,\n                    Arrays.asList(vertices[i]),\n                    Arrays.asList(vertices[j]),\n                    numEdges);\n            }\n        }\n    }\n}\n\n// End PartiteRandomGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "numVertices", "", "int[]" ], [ "numEdges", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "", "int[]", "public boolean equals(Object);" ], [ "toString", "", "int[]", "public String toString()" ], [ "hashCode", "", "int[]", "public native int hashCode()" ], [ "getClass", "", "int[]", "public final native Class getClass();" ], [ "clone", "", "int[]", "public T[] clone();" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "length", "", "int[]", "public final int length;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25802,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental.dag",
  "className" : "DirectedAcyclicGraph",
  "javadocTag" : "@throws IllegalArgumentException If either fromVertex or toVertex is not\na member of the graph",
  "methodJavadoc" : "    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return null if the edge is already in the graph, else the created edge\n     * is returned\n     *\n     * @throws IllegalArgumentException If either fromVertex or toVertex is not\n     * a member of the graph\n     * @throws CycleFoundException if the edge would induce a cycle in the graph\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */",
  "methodSourceCode" : "public E addDagEdge(V fromVertex, V toVertex) throws CycleFoundException{\n    updateDag(fromVertex, toVertex);\n    return super.addEdge(fromVertex, toVertex);\n}",
  "classJavadoc" : "/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * DirectedAcyclicGraph.java\n * -------------------\n * (C) Copyright 2008-2008, by Peter Giles and Contributors.\n *\n * Original Author:  Peter Giles\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Mar-2008 : Initial revision (PG);\n * 23-Aug-2008 : Added VisitedBitSetImpl and made it the default (JVS);\n *\n */\npackage org.jgrapht.experimental.dag;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */\npublic class DirectedAcyclicGraph<V, E>\n    extends SimpleDirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 4522128427004938150L;\n\n    private TopoComparator<V> topoComparator;\n\n    private TopoOrderMapping<V> topoOrderMap;\n\n    private int maxTopoIndex = 0;\n    private int minTopoIndex = 0;\n\n    // this update count is used to keep internal topological iterators honest\n    private long topologyUpdateCount = 0;\n\n    /**\n     * Pluggable VisitedFactory implementation\n     */\n    private VisitedFactory visitedFactory = new VisitedBitSetImpl();\n\n    /**\n     * Pluggable TopoOrderMappingFactory implementation\n     */\n    private TopoOrderMappingFactory<V> topoOrderFactory = new TopoVertexBiMap();\n\n    public DirectedAcyclicGraph(Class<? extends E> arg0)\n    {\n        super(arg0);\n        initialize();\n    }\n\n    public DirectedAcyclicGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n        initialize();\n    }\n\n    DirectedAcyclicGraph(\n        Class<? extends E> arg0,\n        VisitedFactory visitedFactory,\n        TopoOrderMappingFactory<V> topoOrderFactory)\n    {\n        super(arg0);\n        if (visitedFactory != null) {\n            this.visitedFactory = visitedFactory;\n        }\n        if (topoOrderFactory != null) {\n            this.topoOrderFactory = topoOrderFactory;\n        }\n        initialize();\n    }\n\n    /**\n     * set the topoOrderMap based on the current factory, and create the\n     * comparator;\n     */\n    private void initialize()\n    {\n        topoOrderMap = topoOrderFactory.getTopoOrderMapping();\n        topoComparator = new TopoComparator<V>(topoOrderMap);\n    }\n\n    /**\n     * iterator will traverse the vertices in topological order, meaning that\n     * for a directed graph G = (V,E), if there exists a path from vertex va to\n     * vertex vb then va is guaranteed to come before vertex vb in the iteration\n     * order.\n     *\n     * @return an iterator that will traverse the graph in topological order\n     */\n    public Iterator<V> iterator()\n    {\n        return new TopoIterator();\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it at the top\n     * of the internal topological vertex ordering\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            // add to the top\n            ++maxTopoIndex;\n            topoOrderMap.putVertex(maxTopoIndex, v);\n\n            ++topologyUpdateCount;\n        }\n\n        return added;\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it either at\n     * the top or the bottom of the topological ordering, depending on the value\n     * of addToTop. This may provide useful optimizations for merging\n     * DirectedAcyclicGraphs that become connected.\n     *\n     * @param v\n     * @param addToTop\n     *\n     * @return whether new vertex was added\n     */\n    public boolean addVertex(V v, boolean addToTop)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            int insertIndex;\n\n            // add to the top\n            if (addToTop) {\n                insertIndex = ++maxTopoIndex;\n            } else {\n                insertIndex = --minTopoIndex;\n            }\n            topoOrderMap.putVertex(insertIndex, v);\n\n            ++topologyUpdateCount;\n        }\n        return added;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return null if the edge is already in the graph, else the created edge\n     * is returned\n     *\n     * @throws IllegalArgumentException If either fromVertex or toVertex is not\n     * a member of the graph\n     * @throws CycleFoundException if the edge would induce a cycle in the graph\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public E addDagEdge(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex);\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object)}, except an unchecked\n     * {@link IllegalArgumentException} is thrown if a cycle would have been\n     * induced by this edge\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E result = null;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>the given edge is not already a member of the graph\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return true if the edge was added to the graph\n     *\n     * @throws CycleFoundException if adding an edge (fromVertex, toVertex) to\n     * the graph would induce a cycle.\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public boolean addDagEdge(V fromVertex, V toVertex, E e)\n        throws CycleFoundException\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex, e);\n    }\n\n    private void updateDag(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        Integer lb = topoOrderMap.getTopologicalIndex(toVertex);\n        Integer ub = topoOrderMap.getTopologicalIndex(fromVertex);\n\n        if ((lb == null) || (ub == null)) {\n            throw new IllegalArgumentException(\n                \"vertices must be in the graph already!\");\n        }\n\n        if (lb < ub) {\n            Set<V> df = new HashSet<V>();\n            Set<V> db = new HashSet<V>();\n\n            // Discovery\n            Region affectedRegion = new Region(lb, ub);\n            Visited visited = visitedFactory.getInstance(affectedRegion);\n\n            // throws CycleFoundException if there is a cycle\n            dfsF(toVertex, df, visited, affectedRegion);\n\n            dfsB(fromVertex, db, visited, affectedRegion);\n            reorder(df, db, visited);\n            ++topologyUpdateCount; // if we do a reorder, than the topology has\n                                   // been updated\n        }\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object, Object)}, except an\n     * unchecked {@link IllegalArgumentException} is thrown if a cycle would\n     * have been induced by this edge\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E edge)\n    {\n        boolean result;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex, edge);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    // note that this can leave holes in the topological ordering, which\n    // (depending on the TopoOrderMap implementation) can degrade performance\n    // for certain operations over time\n    @Override public boolean removeVertex(V v)\n    {\n        boolean removed = super.removeVertex(v);\n\n        if (removed) {\n            Integer topoIndex = topoOrderMap.removeVertex(v);\n\n            // contract minTopoIndex as we are able\n            if (topoIndex == minTopoIndex) {\n                while (\n                    (minTopoIndex < 0)\n                    && (null == topoOrderMap.getVertex(minTopoIndex)))\n                {\n                    ++minTopoIndex;\n                }\n            }\n\n            // contract maxTopoIndex as we are able\n            if (topoIndex == maxTopoIndex) {\n                while (\n                    (maxTopoIndex > 0)\n                    && (null == topoOrderMap.getVertex(maxTopoIndex)))\n                {\n                    --maxTopoIndex;\n                }\n            }\n\n            ++topologyUpdateCount;\n        }\n\n        return removed;\n    }\n\n    @Override public boolean removeAllVertices(Collection<? extends V> arg0)\n    {\n        boolean removed = super.removeAllVertices(arg0);\n\n        topoOrderMap.removeAllVertices();\n\n        maxTopoIndex = 0;\n        minTopoIndex = 0;\n\n        ++topologyUpdateCount;\n\n        return removed;\n    }\n\n    /**\n     * Depth first search forward, building up the set (df) of forward-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param df the set we are populating with forward connected vertices in\n     * the Affected Region\n     * @param visited a simple data structure that lets us know if we already\n     * visited a node with a given topo index\n     * @param topoIndexMap for quick lookups, a map from vertex to topo index in\n     * the AR\n     * @param ub the topo index of the original fromVertex -- used for cycle\n     * detection\n     *\n     * @throws CycleFoundException if a cycle is discovered\n     */\n    private void dfsF(\n        V vertex,\n        Set<V> df,\n        Visited visited,\n        Region affectedRegion)\n        throws CycleFoundException\n    {\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n        // Assumption: vertex is in the AR and so it will be in visited\n        visited.setVisited(topoIndex);\n\n        df.add(vertex);\n\n        for (E outEdge : outgoingEdgesOf(vertex)) {\n            V nextVertex = getEdgeTarget(outEdge);\n            Integer nextVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(nextVertex);\n\n            if (nextVertexTopoIndex.intValue() == affectedRegion.finish) {\n                // reset visited\n                try {\n                    for (V visitedVertex : df) {\n                        visited.clearVisited(\n                            topoOrderMap.getTopologicalIndex(visitedVertex));\n                    }\n                } catch (UnsupportedOperationException e) {\n                    // okay, fine, some implementations (ones that automatically\n                    // clear themselves out) don't work this way\n                }\n                throw new CycleFoundException();\n            }\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(nextVertexTopoIndex)\n                && !visited.getVisited(nextVertexTopoIndex))\n            {\n                dfsF(nextVertex, df, visited, affectedRegion); // recurse\n            }\n        }\n    }\n\n    /**\n     * Depth first search backward, building up the set (db) of back-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param db the set we are populating with back-connected vertices in the\n     * AR\n     * @param visited\n     * @param topoIndexMap\n     */\n    private void dfsB(\n        V vertex,\n        Set<V> db,\n        Visited visited,\n        Region affectedRegion)\n    {\n        // Assumption: vertex is in the AR and so we will get a topoIndex from\n        // the map\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n        visited.setVisited(topoIndex);\n\n        db.add(vertex);\n\n        for (E inEdge : incomingEdgesOf(vertex)) {\n            V previousVertex = getEdgeSource(inEdge);\n            Integer previousVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(previousVertex);\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(previousVertexTopoIndex)\n                && !visited.getVisited(previousVertexTopoIndex))\n            {\n                // if prevousVertexTopoIndex != null, the vertex is in the\n                // Affected Region according to our topoIndexMap\n\n                dfsB(previousVertex, db, visited, affectedRegion);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void reorder(Set<V> df, Set<V> db, Visited visited)\n    {\n        List<V> topoDf = new ArrayList<V>(df);\n        List<V> topoDb = new ArrayList<V>(db);\n\n        Collections.sort(topoDf, topoComparator);\n        Collections.sort(topoDb, topoComparator);\n\n        // merge these suckers together in topo order\n\n        SortedSet<Integer> availableTopoIndices = new TreeSet<Integer>();\n\n        // we have to cast to the generic type, can't do \"new V[size]\" in java\n        // 5;\n        V [] bigL = (V []) new Object[df.size() + db.size()];\n        int lIndex = 0; // this index is used for the sole purpose of pushing\n                        // into\n\n        // the correct index of bigL\n\n        // assume (for now) that we are resetting visited\n        boolean clearVisited = true;\n\n        for (V vertex : topoDb) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        for (V vertex : topoDf) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        lIndex = 0; // reusing lIndex\n        for (Integer topoIndex : availableTopoIndices) {\n            // assign the indexes to the elements of bigL in order\n            V vertex = bigL[lIndex++]; // note the post-increment\n            topoOrderMap.putVertex(topoIndex, vertex);\n        }\n    }\n\n    /**\n     * For performance tuning, an interface for storing the topological ordering\n     *\n     * @author gilesp\n     */\n    public interface TopoOrderMapping<V>\n        extends Serializable\n    {\n        /**\n         * add a vertex at the given topological index.\n         *\n         * @param index\n         * @param vertex\n         */\n        public void putVertex(Integer index, V vertex);\n\n        /**\n         * get the vertex at the given topological index.\n         *\n         * @param index\n         *\n         * @return vertex\n         */\n        public V getVertex(Integer index);\n\n        /**\n         * get the topological index of the given vertex.\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex is at, or null if the vertex isn't\n         * in the topological ordering\n         */\n        public Integer getTopologicalIndex(V vertex);\n\n        /**\n         * remove the given vertex from the topological ordering\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex was at, or null if the vertex\n         * wasn't in the topological ordering\n         */\n        public Integer removeVertex(V vertex);\n\n        /**\n         * remove all vertices from the topological ordering\n         */\n        public void removeAllVertices();\n    }\n\n    public interface TopoOrderMappingFactory<V>\n    {\n        public TopoOrderMapping<V> getTopoOrderMapping();\n    }\n\n    /**\n     * this interface allows specification of a strategy for marking vertices as\n     * visited (based on their topological index, so the vertex type isn't part\n     * of the interface).\n     */\n    public interface Visited\n    {\n        /**\n         * mark the given topological index as visited\n         *\n         * @param index the topological index\n         */\n        public void setVisited(int index);\n\n        /**\n         * has the given topological index been visited?\n         *\n         * @param index the topological index\n         */\n        public boolean getVisited(int index);\n\n        /**\n         * Clear the visited state of the given topological index\n         *\n         * @param index\n         *\n         * @throws UnsupportedOperationException if the implementation doesn't\n         * support (or doesn't need) clearance. For example, if the factory\n         * vends a new instance every time, it is a waste of cycles to clear the\n         * state after the search of the Affected Region is done, so an\n         * UnsupportedOperationException *should* be thrown.\n         */\n        public void clearVisited(int index)\n            throws UnsupportedOperationException;\n    }\n\n    /**\n     * interface for a factory that vends Visited implementations\n     *\n     * @author gilesp\n     */\n    public interface VisitedFactory\n        extends Serializable\n    {\n        public Visited getInstance(Region affectedRegion);\n    }\n\n    /**\n     * Note, this is a lazy and incomplete implementation, with assumptions that\n     * inputs are in the given topoIndexMap\n     *\n     * @param <V>\n     *\n     * @author gilesp\n     */\n    private static class TopoComparator<V>\n        implements Comparator<V>,\n            Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private TopoOrderMapping<V> topoOrderMap;\n\n        public TopoComparator(TopoOrderMapping<V> topoOrderMap)\n        {\n            this.topoOrderMap = topoOrderMap;\n        }\n\n        @Override public int compare(V o1, V o2)\n        {\n            return topoOrderMap.getTopologicalIndex(o1).compareTo(\n                topoOrderMap.getTopologicalIndex(o2));\n        }\n    }\n\n    /**\n     * a dual HashMap implementation\n     *\n     * @author gilesp\n     */\n    private class TopoVertexBiMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Map<Integer, V> topoToVertex = new HashMap<Integer, V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            topoToVertex.put(index, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(index);\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.get(vertex);\n            return topoIndex;\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.remove(topoIndex);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n    }\n\n    /**\n     * For performance and flexibility uses an ArrayList for topological index\n     * to vertex mapping, and a HashMap for vertex to topological index mapping.\n     *\n     * @author gilesp\n     */\n    public class TopoVertexMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<V> topoToVertex = new ArrayList<V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            int translatedIndex = translateIndex(index);\n\n            // grow topoToVertex as needed to accommodate elements\n            while ((translatedIndex + 1) > topoToVertex.size()) {\n                topoToVertex.add(null);\n            }\n\n            topoToVertex.set(translatedIndex, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(translateIndex(index));\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            return vertexToTopo.get(vertex);\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.set(translateIndex(topoIndex), null);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private final int translateIndex(int index)\n        {\n            if (index >= 0) {\n                return 2 * index;\n            }\n            return -1 * ((index * 2) - 1);\n        }\n    }\n\n    /**\n     * Region is an *inclusive* range of indices. Esthetically displeasing, but\n     * convenient for our purposes.\n     *\n     * @author gilesp\n     */\n    public static class Region\n        implements Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        public final int start;\n        public final int finish;\n\n        public Region(int start, int finish)\n        {\n            if (start > finish) {\n                throw new IllegalArgumentException(\n                    \"(start > finish): invariant broken\");\n            }\n            this.start = start;\n            this.finish = finish;\n        }\n\n        public int getSize()\n        {\n            return (finish - start) + 1;\n        }\n\n        public boolean isIn(int index)\n        {\n            return (index >= start) && (index <= finish);\n        }\n    }\n\n    /**\n     * This implementation is close to the performance of VisitedArrayListImpl,\n     * with 1/8 the memory usage.\n     *\n     * @author perfecthash\n     */\n    public static class VisitedBitSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final BitSet visited = new BitSet();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), true);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.get(translateIndex(index));\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.clear(translateIndex(index));\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation seems to offer the best performance in most cases. It\n     * grows the internal ArrayList as needed to be as large as |AR|, so it will\n     * be more memory intensive than the HashSet implementation, and unlike the\n     * Array implementation, it will hold on to that memory (it expands, but\n     * never contracts).\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayListImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<Boolean> visited = new ArrayList<Boolean>();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            // Make sure visited is big enough\n            int minSize = (affectedRegion.finish - affectedRegion.start) + 1;\n            /* plus one because the region range is inclusive of both indices */\n\n            while (visited.size() < minSize) {\n                visited.add(Boolean.FALSE);\n            }\n\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), Boolean.TRUE);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            Boolean result = null;\n\n            result = visited.get(translateIndex(index));\n\n            return result;\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.set(translateIndex(index), Boolean.FALSE);\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation doesn't seem to perform as well, though I can imagine\n     * circumstances where it should shine (lots and lots of vertices). It also\n     * should have the lowest memory footprint as it only uses storage for\n     * indices that have been visited.\n     *\n     * @author gilesp\n     */\n    public static class VisitedHashSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Set<Integer> visited = new HashSet<Integer>();\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            visited.clear();\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.add(index);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.contains(index);\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * This implementation, somewhat to my surprise, is slower than the\n     * ArrayList version, probably due to its reallocation of the underlying\n     * array for every topology reorder that is required.\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final boolean [] visited;\n\n        private final Region region;\n\n        /**\n         * Constructs empty factory instance\n         */\n        public VisitedArrayImpl()\n        {\n            this(null);\n        }\n\n        public VisitedArrayImpl(Region region)\n        {\n            if (region == null) { // make empty instance\n                this.visited = null;\n                this.region = null;\n            } else { // fill in the needed pieces\n                this.region = region;\n\n                // initialized to all false by default\n                visited = new boolean[region.getSize()];\n            }\n        }\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            return new VisitedArrayImpl(affectedRegion);\n        }\n\n        @Override public void setVisited(int index)\n        {\n            try {\n                visited[index - region.start] = true;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            try {\n                return visited[index - region.start];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Exception used in dfsF when a cycle is found\n     *\n     * @author gilesp\n     */\n    public static class CycleFoundException\n        extends Exception\n    {\n        private static final long serialVersionUID = 5583471522212552754L;\n    }\n\n    /**\n     * iterator which follows topological order\n     *\n     * @author gilesp\n     */\n    private class TopoIterator\n        implements Iterator<V>\n    {\n        private int currentTopoIndex;\n        private final long updateCountAtCreation;\n        private Integer nextIndex = null;\n\n        public TopoIterator()\n        {\n            updateCountAtCreation = topologyUpdateCount;\n            currentTopoIndex = minTopoIndex - 1;\n        }\n\n        @Override public boolean hasNext()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            nextIndex = getNextIndex();\n            return nextIndex != null;\n        }\n\n        @Override public V next()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            if (nextIndex == null) {\n                // find nextIndex\n                nextIndex = getNextIndex();\n            }\n            if (nextIndex == null) {\n                throw new NoSuchElementException();\n            }\n            currentTopoIndex = nextIndex;\n            nextIndex = null;\n            return topoOrderMap.getVertex(currentTopoIndex); //topoToVertex.get(currentTopoIndex);\n        }\n\n        @Override public void remove()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            V vertexToRemove = null;\n            if (null\n                != (vertexToRemove =\n                        topoOrderMap.getVertex(\n                            currentTopoIndex)))\n            {\n                topoOrderMap.removeVertex(vertexToRemove);\n            } else {\n                // should only happen if next() hasn't been called\n                throw new IllegalStateException();\n            }\n        }\n\n        private Integer getNextIndex()\n        {\n            for (int i = currentTopoIndex + 1; i <= maxTopoIndex; i++) {\n                if (null != topoOrderMap.getVertex(i)) {\n                    return i;\n                }\n            }\n            return null;\n        }\n    }\n}\n\n// End DirectedAcyclicGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "fromVertex", "", "V" ], [ "toVertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "inDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int inDegreeOf(V arg0)" ], [ "degreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int degreeOf(V arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "getAllEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "edgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgesOf(V arg0)" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v)" ], [ "getEdgeTarget", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeTarget(E arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "isAllowingMultipleEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingMultipleEdges()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllVertices", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addDagEdge(V fromVertex, V toVertex) throws CycleFoundException" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E removeEdge(V arg0, V arg1)" ], [ "edgeSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgeSet()" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "isAllowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingLoops()" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "getEdgeFactory", "org.jgrapht.graph", "AbstractBaseGraph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E edge)" ], [ "incomingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> incomingEdgesOf(V arg0)" ], [ "getEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E getEdge(V arg0, V arg1)" ], [ "removeVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeVertex(V v)" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v, boolean addToTop)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsEdge(E arg0)" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean removeEdge(E arg0)" ], [ "createUndirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()" ], [ "createDirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()" ], [ "vertexSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<V> vertexSet()" ], [ "outDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int outDegreeOf(V arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeSource(E arg0)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addDagEdge(V fromVertex, V toVertex, E e) throws CycleFoundException" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "getEdgeWeight", "org.jgrapht.graph", "AbstractBaseGraph", "public double getEdgeWeight(E arg0)" ], [ "containsVertex", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsVertex(V arg0)" ], [ "iterator", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public Iterator<V> iterator()" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "clone", "org.jgrapht.graph", "AbstractBaseGraph", "public Object clone()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "allowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "boolean allowingLoops;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25803,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental.dag",
  "className" : "DirectedAcyclicGraph",
  "javadocTag" : "@throws CycleFoundException if the edge would induce a cycle in the graph",
  "methodJavadoc" : "    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return null if the edge is already in the graph, else the created edge\n     * is returned\n     *\n     * @throws IllegalArgumentException If either fromVertex or toVertex is not\n     * a member of the graph\n     * @throws CycleFoundException if the edge would induce a cycle in the graph\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */",
  "methodSourceCode" : "public E addDagEdge(V fromVertex, V toVertex) throws CycleFoundException{\n    updateDag(fromVertex, toVertex);\n    return super.addEdge(fromVertex, toVertex);\n}",
  "classJavadoc" : "/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * DirectedAcyclicGraph.java\n * -------------------\n * (C) Copyright 2008-2008, by Peter Giles and Contributors.\n *\n * Original Author:  Peter Giles\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Mar-2008 : Initial revision (PG);\n * 23-Aug-2008 : Added VisitedBitSetImpl and made it the default (JVS);\n *\n */\npackage org.jgrapht.experimental.dag;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */\npublic class DirectedAcyclicGraph<V, E>\n    extends SimpleDirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 4522128427004938150L;\n\n    private TopoComparator<V> topoComparator;\n\n    private TopoOrderMapping<V> topoOrderMap;\n\n    private int maxTopoIndex = 0;\n    private int minTopoIndex = 0;\n\n    // this update count is used to keep internal topological iterators honest\n    private long topologyUpdateCount = 0;\n\n    /**\n     * Pluggable VisitedFactory implementation\n     */\n    private VisitedFactory visitedFactory = new VisitedBitSetImpl();\n\n    /**\n     * Pluggable TopoOrderMappingFactory implementation\n     */\n    private TopoOrderMappingFactory<V> topoOrderFactory = new TopoVertexBiMap();\n\n    public DirectedAcyclicGraph(Class<? extends E> arg0)\n    {\n        super(arg0);\n        initialize();\n    }\n\n    public DirectedAcyclicGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n        initialize();\n    }\n\n    DirectedAcyclicGraph(\n        Class<? extends E> arg0,\n        VisitedFactory visitedFactory,\n        TopoOrderMappingFactory<V> topoOrderFactory)\n    {\n        super(arg0);\n        if (visitedFactory != null) {\n            this.visitedFactory = visitedFactory;\n        }\n        if (topoOrderFactory != null) {\n            this.topoOrderFactory = topoOrderFactory;\n        }\n        initialize();\n    }\n\n    /**\n     * set the topoOrderMap based on the current factory, and create the\n     * comparator;\n     */\n    private void initialize()\n    {\n        topoOrderMap = topoOrderFactory.getTopoOrderMapping();\n        topoComparator = new TopoComparator<V>(topoOrderMap);\n    }\n\n    /**\n     * iterator will traverse the vertices in topological order, meaning that\n     * for a directed graph G = (V,E), if there exists a path from vertex va to\n     * vertex vb then va is guaranteed to come before vertex vb in the iteration\n     * order.\n     *\n     * @return an iterator that will traverse the graph in topological order\n     */\n    public Iterator<V> iterator()\n    {\n        return new TopoIterator();\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it at the top\n     * of the internal topological vertex ordering\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            // add to the top\n            ++maxTopoIndex;\n            topoOrderMap.putVertex(maxTopoIndex, v);\n\n            ++topologyUpdateCount;\n        }\n\n        return added;\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it either at\n     * the top or the bottom of the topological ordering, depending on the value\n     * of addToTop. This may provide useful optimizations for merging\n     * DirectedAcyclicGraphs that become connected.\n     *\n     * @param v\n     * @param addToTop\n     *\n     * @return whether new vertex was added\n     */\n    public boolean addVertex(V v, boolean addToTop)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            int insertIndex;\n\n            // add to the top\n            if (addToTop) {\n                insertIndex = ++maxTopoIndex;\n            } else {\n                insertIndex = --minTopoIndex;\n            }\n            topoOrderMap.putVertex(insertIndex, v);\n\n            ++topologyUpdateCount;\n        }\n        return added;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return null if the edge is already in the graph, else the created edge\n     * is returned\n     *\n     * @throws IllegalArgumentException If either fromVertex or toVertex is not\n     * a member of the graph\n     * @throws CycleFoundException if the edge would induce a cycle in the graph\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public E addDagEdge(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex);\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object)}, except an unchecked\n     * {@link IllegalArgumentException} is thrown if a cycle would have been\n     * induced by this edge\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E result = null;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>the given edge is not already a member of the graph\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return true if the edge was added to the graph\n     *\n     * @throws CycleFoundException if adding an edge (fromVertex, toVertex) to\n     * the graph would induce a cycle.\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public boolean addDagEdge(V fromVertex, V toVertex, E e)\n        throws CycleFoundException\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex, e);\n    }\n\n    private void updateDag(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        Integer lb = topoOrderMap.getTopologicalIndex(toVertex);\n        Integer ub = topoOrderMap.getTopologicalIndex(fromVertex);\n\n        if ((lb == null) || (ub == null)) {\n            throw new IllegalArgumentException(\n                \"vertices must be in the graph already!\");\n        }\n\n        if (lb < ub) {\n            Set<V> df = new HashSet<V>();\n            Set<V> db = new HashSet<V>();\n\n            // Discovery\n            Region affectedRegion = new Region(lb, ub);\n            Visited visited = visitedFactory.getInstance(affectedRegion);\n\n            // throws CycleFoundException if there is a cycle\n            dfsF(toVertex, df, visited, affectedRegion);\n\n            dfsB(fromVertex, db, visited, affectedRegion);\n            reorder(df, db, visited);\n            ++topologyUpdateCount; // if we do a reorder, than the topology has\n                                   // been updated\n        }\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object, Object)}, except an\n     * unchecked {@link IllegalArgumentException} is thrown if a cycle would\n     * have been induced by this edge\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E edge)\n    {\n        boolean result;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex, edge);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    // note that this can leave holes in the topological ordering, which\n    // (depending on the TopoOrderMap implementation) can degrade performance\n    // for certain operations over time\n    @Override public boolean removeVertex(V v)\n    {\n        boolean removed = super.removeVertex(v);\n\n        if (removed) {\n            Integer topoIndex = topoOrderMap.removeVertex(v);\n\n            // contract minTopoIndex as we are able\n            if (topoIndex == minTopoIndex) {\n                while (\n                    (minTopoIndex < 0)\n                    && (null == topoOrderMap.getVertex(minTopoIndex)))\n                {\n                    ++minTopoIndex;\n                }\n            }\n\n            // contract maxTopoIndex as we are able\n            if (topoIndex == maxTopoIndex) {\n                while (\n                    (maxTopoIndex > 0)\n                    && (null == topoOrderMap.getVertex(maxTopoIndex)))\n                {\n                    --maxTopoIndex;\n                }\n            }\n\n            ++topologyUpdateCount;\n        }\n\n        return removed;\n    }\n\n    @Override public boolean removeAllVertices(Collection<? extends V> arg0)\n    {\n        boolean removed = super.removeAllVertices(arg0);\n\n        topoOrderMap.removeAllVertices();\n\n        maxTopoIndex = 0;\n        minTopoIndex = 0;\n\n        ++topologyUpdateCount;\n\n        return removed;\n    }\n\n    /**\n     * Depth first search forward, building up the set (df) of forward-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param df the set we are populating with forward connected vertices in\n     * the Affected Region\n     * @param visited a simple data structure that lets us know if we already\n     * visited a node with a given topo index\n     * @param topoIndexMap for quick lookups, a map from vertex to topo index in\n     * the AR\n     * @param ub the topo index of the original fromVertex -- used for cycle\n     * detection\n     *\n     * @throws CycleFoundException if a cycle is discovered\n     */\n    private void dfsF(\n        V vertex,\n        Set<V> df,\n        Visited visited,\n        Region affectedRegion)\n        throws CycleFoundException\n    {\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n        // Assumption: vertex is in the AR and so it will be in visited\n        visited.setVisited(topoIndex);\n\n        df.add(vertex);\n\n        for (E outEdge : outgoingEdgesOf(vertex)) {\n            V nextVertex = getEdgeTarget(outEdge);\n            Integer nextVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(nextVertex);\n\n            if (nextVertexTopoIndex.intValue() == affectedRegion.finish) {\n                // reset visited\n                try {\n                    for (V visitedVertex : df) {\n                        visited.clearVisited(\n                            topoOrderMap.getTopologicalIndex(visitedVertex));\n                    }\n                } catch (UnsupportedOperationException e) {\n                    // okay, fine, some implementations (ones that automatically\n                    // clear themselves out) don't work this way\n                }\n                throw new CycleFoundException();\n            }\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(nextVertexTopoIndex)\n                && !visited.getVisited(nextVertexTopoIndex))\n            {\n                dfsF(nextVertex, df, visited, affectedRegion); // recurse\n            }\n        }\n    }\n\n    /**\n     * Depth first search backward, building up the set (db) of back-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param db the set we are populating with back-connected vertices in the\n     * AR\n     * @param visited\n     * @param topoIndexMap\n     */\n    private void dfsB(\n        V vertex,\n        Set<V> db,\n        Visited visited,\n        Region affectedRegion)\n    {\n        // Assumption: vertex is in the AR and so we will get a topoIndex from\n        // the map\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n        visited.setVisited(topoIndex);\n\n        db.add(vertex);\n\n        for (E inEdge : incomingEdgesOf(vertex)) {\n            V previousVertex = getEdgeSource(inEdge);\n            Integer previousVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(previousVertex);\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(previousVertexTopoIndex)\n                && !visited.getVisited(previousVertexTopoIndex))\n            {\n                // if prevousVertexTopoIndex != null, the vertex is in the\n                // Affected Region according to our topoIndexMap\n\n                dfsB(previousVertex, db, visited, affectedRegion);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void reorder(Set<V> df, Set<V> db, Visited visited)\n    {\n        List<V> topoDf = new ArrayList<V>(df);\n        List<V> topoDb = new ArrayList<V>(db);\n\n        Collections.sort(topoDf, topoComparator);\n        Collections.sort(topoDb, topoComparator);\n\n        // merge these suckers together in topo order\n\n        SortedSet<Integer> availableTopoIndices = new TreeSet<Integer>();\n\n        // we have to cast to the generic type, can't do \"new V[size]\" in java\n        // 5;\n        V [] bigL = (V []) new Object[df.size() + db.size()];\n        int lIndex = 0; // this index is used for the sole purpose of pushing\n                        // into\n\n        // the correct index of bigL\n\n        // assume (for now) that we are resetting visited\n        boolean clearVisited = true;\n\n        for (V vertex : topoDb) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        for (V vertex : topoDf) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        lIndex = 0; // reusing lIndex\n        for (Integer topoIndex : availableTopoIndices) {\n            // assign the indexes to the elements of bigL in order\n            V vertex = bigL[lIndex++]; // note the post-increment\n            topoOrderMap.putVertex(topoIndex, vertex);\n        }\n    }\n\n    /**\n     * For performance tuning, an interface for storing the topological ordering\n     *\n     * @author gilesp\n     */\n    public interface TopoOrderMapping<V>\n        extends Serializable\n    {\n        /**\n         * add a vertex at the given topological index.\n         *\n         * @param index\n         * @param vertex\n         */\n        public void putVertex(Integer index, V vertex);\n\n        /**\n         * get the vertex at the given topological index.\n         *\n         * @param index\n         *\n         * @return vertex\n         */\n        public V getVertex(Integer index);\n\n        /**\n         * get the topological index of the given vertex.\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex is at, or null if the vertex isn't\n         * in the topological ordering\n         */\n        public Integer getTopologicalIndex(V vertex);\n\n        /**\n         * remove the given vertex from the topological ordering\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex was at, or null if the vertex\n         * wasn't in the topological ordering\n         */\n        public Integer removeVertex(V vertex);\n\n        /**\n         * remove all vertices from the topological ordering\n         */\n        public void removeAllVertices();\n    }\n\n    public interface TopoOrderMappingFactory<V>\n    {\n        public TopoOrderMapping<V> getTopoOrderMapping();\n    }\n\n    /**\n     * this interface allows specification of a strategy for marking vertices as\n     * visited (based on their topological index, so the vertex type isn't part\n     * of the interface).\n     */\n    public interface Visited\n    {\n        /**\n         * mark the given topological index as visited\n         *\n         * @param index the topological index\n         */\n        public void setVisited(int index);\n\n        /**\n         * has the given topological index been visited?\n         *\n         * @param index the topological index\n         */\n        public boolean getVisited(int index);\n\n        /**\n         * Clear the visited state of the given topological index\n         *\n         * @param index\n         *\n         * @throws UnsupportedOperationException if the implementation doesn't\n         * support (or doesn't need) clearance. For example, if the factory\n         * vends a new instance every time, it is a waste of cycles to clear the\n         * state after the search of the Affected Region is done, so an\n         * UnsupportedOperationException *should* be thrown.\n         */\n        public void clearVisited(int index)\n            throws UnsupportedOperationException;\n    }\n\n    /**\n     * interface for a factory that vends Visited implementations\n     *\n     * @author gilesp\n     */\n    public interface VisitedFactory\n        extends Serializable\n    {\n        public Visited getInstance(Region affectedRegion);\n    }\n\n    /**\n     * Note, this is a lazy and incomplete implementation, with assumptions that\n     * inputs are in the given topoIndexMap\n     *\n     * @param <V>\n     *\n     * @author gilesp\n     */\n    private static class TopoComparator<V>\n        implements Comparator<V>,\n            Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private TopoOrderMapping<V> topoOrderMap;\n\n        public TopoComparator(TopoOrderMapping<V> topoOrderMap)\n        {\n            this.topoOrderMap = topoOrderMap;\n        }\n\n        @Override public int compare(V o1, V o2)\n        {\n            return topoOrderMap.getTopologicalIndex(o1).compareTo(\n                topoOrderMap.getTopologicalIndex(o2));\n        }\n    }\n\n    /**\n     * a dual HashMap implementation\n     *\n     * @author gilesp\n     */\n    private class TopoVertexBiMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Map<Integer, V> topoToVertex = new HashMap<Integer, V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            topoToVertex.put(index, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(index);\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.get(vertex);\n            return topoIndex;\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.remove(topoIndex);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n    }\n\n    /**\n     * For performance and flexibility uses an ArrayList for topological index\n     * to vertex mapping, and a HashMap for vertex to topological index mapping.\n     *\n     * @author gilesp\n     */\n    public class TopoVertexMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<V> topoToVertex = new ArrayList<V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            int translatedIndex = translateIndex(index);\n\n            // grow topoToVertex as needed to accommodate elements\n            while ((translatedIndex + 1) > topoToVertex.size()) {\n                topoToVertex.add(null);\n            }\n\n            topoToVertex.set(translatedIndex, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(translateIndex(index));\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            return vertexToTopo.get(vertex);\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.set(translateIndex(topoIndex), null);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private final int translateIndex(int index)\n        {\n            if (index >= 0) {\n                return 2 * index;\n            }\n            return -1 * ((index * 2) - 1);\n        }\n    }\n\n    /**\n     * Region is an *inclusive* range of indices. Esthetically displeasing, but\n     * convenient for our purposes.\n     *\n     * @author gilesp\n     */\n    public static class Region\n        implements Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        public final int start;\n        public final int finish;\n\n        public Region(int start, int finish)\n        {\n            if (start > finish) {\n                throw new IllegalArgumentException(\n                    \"(start > finish): invariant broken\");\n            }\n            this.start = start;\n            this.finish = finish;\n        }\n\n        public int getSize()\n        {\n            return (finish - start) + 1;\n        }\n\n        public boolean isIn(int index)\n        {\n            return (index >= start) && (index <= finish);\n        }\n    }\n\n    /**\n     * This implementation is close to the performance of VisitedArrayListImpl,\n     * with 1/8 the memory usage.\n     *\n     * @author perfecthash\n     */\n    public static class VisitedBitSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final BitSet visited = new BitSet();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), true);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.get(translateIndex(index));\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.clear(translateIndex(index));\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation seems to offer the best performance in most cases. It\n     * grows the internal ArrayList as needed to be as large as |AR|, so it will\n     * be more memory intensive than the HashSet implementation, and unlike the\n     * Array implementation, it will hold on to that memory (it expands, but\n     * never contracts).\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayListImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<Boolean> visited = new ArrayList<Boolean>();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            // Make sure visited is big enough\n            int minSize = (affectedRegion.finish - affectedRegion.start) + 1;\n            /* plus one because the region range is inclusive of both indices */\n\n            while (visited.size() < minSize) {\n                visited.add(Boolean.FALSE);\n            }\n\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), Boolean.TRUE);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            Boolean result = null;\n\n            result = visited.get(translateIndex(index));\n\n            return result;\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.set(translateIndex(index), Boolean.FALSE);\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation doesn't seem to perform as well, though I can imagine\n     * circumstances where it should shine (lots and lots of vertices). It also\n     * should have the lowest memory footprint as it only uses storage for\n     * indices that have been visited.\n     *\n     * @author gilesp\n     */\n    public static class VisitedHashSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Set<Integer> visited = new HashSet<Integer>();\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            visited.clear();\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.add(index);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.contains(index);\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * This implementation, somewhat to my surprise, is slower than the\n     * ArrayList version, probably due to its reallocation of the underlying\n     * array for every topology reorder that is required.\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final boolean [] visited;\n\n        private final Region region;\n\n        /**\n         * Constructs empty factory instance\n         */\n        public VisitedArrayImpl()\n        {\n            this(null);\n        }\n\n        public VisitedArrayImpl(Region region)\n        {\n            if (region == null) { // make empty instance\n                this.visited = null;\n                this.region = null;\n            } else { // fill in the needed pieces\n                this.region = region;\n\n                // initialized to all false by default\n                visited = new boolean[region.getSize()];\n            }\n        }\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            return new VisitedArrayImpl(affectedRegion);\n        }\n\n        @Override public void setVisited(int index)\n        {\n            try {\n                visited[index - region.start] = true;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            try {\n                return visited[index - region.start];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Exception used in dfsF when a cycle is found\n     *\n     * @author gilesp\n     */\n    public static class CycleFoundException\n        extends Exception\n    {\n        private static final long serialVersionUID = 5583471522212552754L;\n    }\n\n    /**\n     * iterator which follows topological order\n     *\n     * @author gilesp\n     */\n    private class TopoIterator\n        implements Iterator<V>\n    {\n        private int currentTopoIndex;\n        private final long updateCountAtCreation;\n        private Integer nextIndex = null;\n\n        public TopoIterator()\n        {\n            updateCountAtCreation = topologyUpdateCount;\n            currentTopoIndex = minTopoIndex - 1;\n        }\n\n        @Override public boolean hasNext()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            nextIndex = getNextIndex();\n            return nextIndex != null;\n        }\n\n        @Override public V next()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            if (nextIndex == null) {\n                // find nextIndex\n                nextIndex = getNextIndex();\n            }\n            if (nextIndex == null) {\n                throw new NoSuchElementException();\n            }\n            currentTopoIndex = nextIndex;\n            nextIndex = null;\n            return topoOrderMap.getVertex(currentTopoIndex); //topoToVertex.get(currentTopoIndex);\n        }\n\n        @Override public void remove()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            V vertexToRemove = null;\n            if (null\n                != (vertexToRemove =\n                        topoOrderMap.getVertex(\n                            currentTopoIndex)))\n            {\n                topoOrderMap.removeVertex(vertexToRemove);\n            } else {\n                // should only happen if next() hasn't been called\n                throw new IllegalStateException();\n            }\n        }\n\n        private Integer getNextIndex()\n        {\n            for (int i = currentTopoIndex + 1; i <= maxTopoIndex; i++) {\n                if (null != topoOrderMap.getVertex(i)) {\n                    return i;\n                }\n            }\n            return null;\n        }\n    }\n}\n\n// End DirectedAcyclicGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "fromVertex", "", "V" ], [ "toVertex", "", "V" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addDagEdge(V fromVertex, V toVertex) throws CycleFoundException" ], [ "removeVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeVertex(V v)" ], [ "containsVertex", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsVertex(V arg0)" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "getAllEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "getEdgeTarget", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeTarget(E arg0)" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E edge)" ], [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addDagEdge(V fromVertex, V toVertex, E e) throws CycleFoundException" ], [ "edgeSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgeSet()" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E removeEdge(V arg0, V arg1)" ], [ "createDirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "removeAllVertices", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "vertexSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<V> vertexSet()" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "isAllowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingLoops()" ], [ "getEdgeWeight", "org.jgrapht.graph", "AbstractBaseGraph", "public double getEdgeWeight(E arg0)" ], [ "incomingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> incomingEdgesOf(V arg0)" ], [ "createUndirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v, boolean addToTop)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsEdge(E arg0)" ], [ "clone", "org.jgrapht.graph", "AbstractBaseGraph", "public Object clone()" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "getEdgeSource", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeSource(E arg0)" ], [ "iterator", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public Iterator<V> iterator()" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean removeEdge(E arg0)" ], [ "getEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E getEdge(V arg0, V arg1)" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "edgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgesOf(V arg0)" ], [ "isAllowingMultipleEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingMultipleEdges()" ], [ "inDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int inDegreeOf(V arg0)" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "degreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int degreeOf(V arg0)" ], [ "getEdgeFactory", "org.jgrapht.graph", "AbstractBaseGraph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v)" ], [ "outDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int outDegreeOf(V arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "allowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "boolean allowingLoops;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25805,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental.dag",
  "className" : "DirectedAcyclicGraph",
  "javadocTag" : "@throws CycleFoundException if adding an edge (fromVertex, toVertex) to\nthe graph would induce a cycle.",
  "methodJavadoc" : "    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>the given edge is not already a member of the graph\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return true if the edge was added to the graph\n     *\n     * @throws CycleFoundException if adding an edge (fromVertex, toVertex) to\n     * the graph would induce a cycle.\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */",
  "methodSourceCode" : "public boolean addDagEdge(V fromVertex, V toVertex, E e) throws CycleFoundException{\n    if (e == null) {\n        throw new NullPointerException();\n    } else if (containsEdge(e)) {\n        return false;\n    }\n    updateDag(fromVertex, toVertex);\n    return super.addEdge(fromVertex, toVertex, e);\n}",
  "classJavadoc" : "/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * DirectedAcyclicGraph.java\n * -------------------\n * (C) Copyright 2008-2008, by Peter Giles and Contributors.\n *\n * Original Author:  Peter Giles\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Mar-2008 : Initial revision (PG);\n * 23-Aug-2008 : Added VisitedBitSetImpl and made it the default (JVS);\n *\n */\npackage org.jgrapht.experimental.dag;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */\npublic class DirectedAcyclicGraph<V, E>\n    extends SimpleDirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 4522128427004938150L;\n\n    private TopoComparator<V> topoComparator;\n\n    private TopoOrderMapping<V> topoOrderMap;\n\n    private int maxTopoIndex = 0;\n    private int minTopoIndex = 0;\n\n    // this update count is used to keep internal topological iterators honest\n    private long topologyUpdateCount = 0;\n\n    /**\n     * Pluggable VisitedFactory implementation\n     */\n    private VisitedFactory visitedFactory = new VisitedBitSetImpl();\n\n    /**\n     * Pluggable TopoOrderMappingFactory implementation\n     */\n    private TopoOrderMappingFactory<V> topoOrderFactory = new TopoVertexBiMap();\n\n    public DirectedAcyclicGraph(Class<? extends E> arg0)\n    {\n        super(arg0);\n        initialize();\n    }\n\n    public DirectedAcyclicGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n        initialize();\n    }\n\n    DirectedAcyclicGraph(\n        Class<? extends E> arg0,\n        VisitedFactory visitedFactory,\n        TopoOrderMappingFactory<V> topoOrderFactory)\n    {\n        super(arg0);\n        if (visitedFactory != null) {\n            this.visitedFactory = visitedFactory;\n        }\n        if (topoOrderFactory != null) {\n            this.topoOrderFactory = topoOrderFactory;\n        }\n        initialize();\n    }\n\n    /**\n     * set the topoOrderMap based on the current factory, and create the\n     * comparator;\n     */\n    private void initialize()\n    {\n        topoOrderMap = topoOrderFactory.getTopoOrderMapping();\n        topoComparator = new TopoComparator<V>(topoOrderMap);\n    }\n\n    /**\n     * iterator will traverse the vertices in topological order, meaning that\n     * for a directed graph G = (V,E), if there exists a path from vertex va to\n     * vertex vb then va is guaranteed to come before vertex vb in the iteration\n     * order.\n     *\n     * @return an iterator that will traverse the graph in topological order\n     */\n    public Iterator<V> iterator()\n    {\n        return new TopoIterator();\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it at the top\n     * of the internal topological vertex ordering\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            // add to the top\n            ++maxTopoIndex;\n            topoOrderMap.putVertex(maxTopoIndex, v);\n\n            ++topologyUpdateCount;\n        }\n\n        return added;\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it either at\n     * the top or the bottom of the topological ordering, depending on the value\n     * of addToTop. This may provide useful optimizations for merging\n     * DirectedAcyclicGraphs that become connected.\n     *\n     * @param v\n     * @param addToTop\n     *\n     * @return whether new vertex was added\n     */\n    public boolean addVertex(V v, boolean addToTop)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            int insertIndex;\n\n            // add to the top\n            if (addToTop) {\n                insertIndex = ++maxTopoIndex;\n            } else {\n                insertIndex = --minTopoIndex;\n            }\n            topoOrderMap.putVertex(insertIndex, v);\n\n            ++topologyUpdateCount;\n        }\n        return added;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return null if the edge is already in the graph, else the created edge\n     * is returned\n     *\n     * @throws IllegalArgumentException If either fromVertex or toVertex is not\n     * a member of the graph\n     * @throws CycleFoundException if the edge would induce a cycle in the graph\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public E addDagEdge(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex);\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object)}, except an unchecked\n     * {@link IllegalArgumentException} is thrown if a cycle would have been\n     * induced by this edge\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E result = null;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>the given edge is not already a member of the graph\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return true if the edge was added to the graph\n     *\n     * @throws CycleFoundException if adding an edge (fromVertex, toVertex) to\n     * the graph would induce a cycle.\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public boolean addDagEdge(V fromVertex, V toVertex, E e)\n        throws CycleFoundException\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex, e);\n    }\n\n    private void updateDag(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        Integer lb = topoOrderMap.getTopologicalIndex(toVertex);\n        Integer ub = topoOrderMap.getTopologicalIndex(fromVertex);\n\n        if ((lb == null) || (ub == null)) {\n            throw new IllegalArgumentException(\n                \"vertices must be in the graph already!\");\n        }\n\n        if (lb < ub) {\n            Set<V> df = new HashSet<V>();\n            Set<V> db = new HashSet<V>();\n\n            // Discovery\n            Region affectedRegion = new Region(lb, ub);\n            Visited visited = visitedFactory.getInstance(affectedRegion);\n\n            // throws CycleFoundException if there is a cycle\n            dfsF(toVertex, df, visited, affectedRegion);\n\n            dfsB(fromVertex, db, visited, affectedRegion);\n            reorder(df, db, visited);\n            ++topologyUpdateCount; // if we do a reorder, than the topology has\n                                   // been updated\n        }\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object, Object)}, except an\n     * unchecked {@link IllegalArgumentException} is thrown if a cycle would\n     * have been induced by this edge\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E edge)\n    {\n        boolean result;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex, edge);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    // note that this can leave holes in the topological ordering, which\n    // (depending on the TopoOrderMap implementation) can degrade performance\n    // for certain operations over time\n    @Override public boolean removeVertex(V v)\n    {\n        boolean removed = super.removeVertex(v);\n\n        if (removed) {\n            Integer topoIndex = topoOrderMap.removeVertex(v);\n\n            // contract minTopoIndex as we are able\n            if (topoIndex == minTopoIndex) {\n                while (\n                    (minTopoIndex < 0)\n                    && (null == topoOrderMap.getVertex(minTopoIndex)))\n                {\n                    ++minTopoIndex;\n                }\n            }\n\n            // contract maxTopoIndex as we are able\n            if (topoIndex == maxTopoIndex) {\n                while (\n                    (maxTopoIndex > 0)\n                    && (null == topoOrderMap.getVertex(maxTopoIndex)))\n                {\n                    --maxTopoIndex;\n                }\n            }\n\n            ++topologyUpdateCount;\n        }\n\n        return removed;\n    }\n\n    @Override public boolean removeAllVertices(Collection<? extends V> arg0)\n    {\n        boolean removed = super.removeAllVertices(arg0);\n\n        topoOrderMap.removeAllVertices();\n\n        maxTopoIndex = 0;\n        minTopoIndex = 0;\n\n        ++topologyUpdateCount;\n\n        return removed;\n    }\n\n    /**\n     * Depth first search forward, building up the set (df) of forward-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param df the set we are populating with forward connected vertices in\n     * the Affected Region\n     * @param visited a simple data structure that lets us know if we already\n     * visited a node with a given topo index\n     * @param topoIndexMap for quick lookups, a map from vertex to topo index in\n     * the AR\n     * @param ub the topo index of the original fromVertex -- used for cycle\n     * detection\n     *\n     * @throws CycleFoundException if a cycle is discovered\n     */\n    private void dfsF(\n        V vertex,\n        Set<V> df,\n        Visited visited,\n        Region affectedRegion)\n        throws CycleFoundException\n    {\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n        // Assumption: vertex is in the AR and so it will be in visited\n        visited.setVisited(topoIndex);\n\n        df.add(vertex);\n\n        for (E outEdge : outgoingEdgesOf(vertex)) {\n            V nextVertex = getEdgeTarget(outEdge);\n            Integer nextVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(nextVertex);\n\n            if (nextVertexTopoIndex.intValue() == affectedRegion.finish) {\n                // reset visited\n                try {\n                    for (V visitedVertex : df) {\n                        visited.clearVisited(\n                            topoOrderMap.getTopologicalIndex(visitedVertex));\n                    }\n                } catch (UnsupportedOperationException e) {\n                    // okay, fine, some implementations (ones that automatically\n                    // clear themselves out) don't work this way\n                }\n                throw new CycleFoundException();\n            }\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(nextVertexTopoIndex)\n                && !visited.getVisited(nextVertexTopoIndex))\n            {\n                dfsF(nextVertex, df, visited, affectedRegion); // recurse\n            }\n        }\n    }\n\n    /**\n     * Depth first search backward, building up the set (db) of back-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param db the set we are populating with back-connected vertices in the\n     * AR\n     * @param visited\n     * @param topoIndexMap\n     */\n    private void dfsB(\n        V vertex,\n        Set<V> db,\n        Visited visited,\n        Region affectedRegion)\n    {\n        // Assumption: vertex is in the AR and so we will get a topoIndex from\n        // the map\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n        visited.setVisited(topoIndex);\n\n        db.add(vertex);\n\n        for (E inEdge : incomingEdgesOf(vertex)) {\n            V previousVertex = getEdgeSource(inEdge);\n            Integer previousVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(previousVertex);\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(previousVertexTopoIndex)\n                && !visited.getVisited(previousVertexTopoIndex))\n            {\n                // if prevousVertexTopoIndex != null, the vertex is in the\n                // Affected Region according to our topoIndexMap\n\n                dfsB(previousVertex, db, visited, affectedRegion);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void reorder(Set<V> df, Set<V> db, Visited visited)\n    {\n        List<V> topoDf = new ArrayList<V>(df);\n        List<V> topoDb = new ArrayList<V>(db);\n\n        Collections.sort(topoDf, topoComparator);\n        Collections.sort(topoDb, topoComparator);\n\n        // merge these suckers together in topo order\n\n        SortedSet<Integer> availableTopoIndices = new TreeSet<Integer>();\n\n        // we have to cast to the generic type, can't do \"new V[size]\" in java\n        // 5;\n        V [] bigL = (V []) new Object[df.size() + db.size()];\n        int lIndex = 0; // this index is used for the sole purpose of pushing\n                        // into\n\n        // the correct index of bigL\n\n        // assume (for now) that we are resetting visited\n        boolean clearVisited = true;\n\n        for (V vertex : topoDb) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        for (V vertex : topoDf) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        lIndex = 0; // reusing lIndex\n        for (Integer topoIndex : availableTopoIndices) {\n            // assign the indexes to the elements of bigL in order\n            V vertex = bigL[lIndex++]; // note the post-increment\n            topoOrderMap.putVertex(topoIndex, vertex);\n        }\n    }\n\n    /**\n     * For performance tuning, an interface for storing the topological ordering\n     *\n     * @author gilesp\n     */\n    public interface TopoOrderMapping<V>\n        extends Serializable\n    {\n        /**\n         * add a vertex at the given topological index.\n         *\n         * @param index\n         * @param vertex\n         */\n        public void putVertex(Integer index, V vertex);\n\n        /**\n         * get the vertex at the given topological index.\n         *\n         * @param index\n         *\n         * @return vertex\n         */\n        public V getVertex(Integer index);\n\n        /**\n         * get the topological index of the given vertex.\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex is at, or null if the vertex isn't\n         * in the topological ordering\n         */\n        public Integer getTopologicalIndex(V vertex);\n\n        /**\n         * remove the given vertex from the topological ordering\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex was at, or null if the vertex\n         * wasn't in the topological ordering\n         */\n        public Integer removeVertex(V vertex);\n\n        /**\n         * remove all vertices from the topological ordering\n         */\n        public void removeAllVertices();\n    }\n\n    public interface TopoOrderMappingFactory<V>\n    {\n        public TopoOrderMapping<V> getTopoOrderMapping();\n    }\n\n    /**\n     * this interface allows specification of a strategy for marking vertices as\n     * visited (based on their topological index, so the vertex type isn't part\n     * of the interface).\n     */\n    public interface Visited\n    {\n        /**\n         * mark the given topological index as visited\n         *\n         * @param index the topological index\n         */\n        public void setVisited(int index);\n\n        /**\n         * has the given topological index been visited?\n         *\n         * @param index the topological index\n         */\n        public boolean getVisited(int index);\n\n        /**\n         * Clear the visited state of the given topological index\n         *\n         * @param index\n         *\n         * @throws UnsupportedOperationException if the implementation doesn't\n         * support (or doesn't need) clearance. For example, if the factory\n         * vends a new instance every time, it is a waste of cycles to clear the\n         * state after the search of the Affected Region is done, so an\n         * UnsupportedOperationException *should* be thrown.\n         */\n        public void clearVisited(int index)\n            throws UnsupportedOperationException;\n    }\n\n    /**\n     * interface for a factory that vends Visited implementations\n     *\n     * @author gilesp\n     */\n    public interface VisitedFactory\n        extends Serializable\n    {\n        public Visited getInstance(Region affectedRegion);\n    }\n\n    /**\n     * Note, this is a lazy and incomplete implementation, with assumptions that\n     * inputs are in the given topoIndexMap\n     *\n     * @param <V>\n     *\n     * @author gilesp\n     */\n    private static class TopoComparator<V>\n        implements Comparator<V>,\n            Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private TopoOrderMapping<V> topoOrderMap;\n\n        public TopoComparator(TopoOrderMapping<V> topoOrderMap)\n        {\n            this.topoOrderMap = topoOrderMap;\n        }\n\n        @Override public int compare(V o1, V o2)\n        {\n            return topoOrderMap.getTopologicalIndex(o1).compareTo(\n                topoOrderMap.getTopologicalIndex(o2));\n        }\n    }\n\n    /**\n     * a dual HashMap implementation\n     *\n     * @author gilesp\n     */\n    private class TopoVertexBiMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Map<Integer, V> topoToVertex = new HashMap<Integer, V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            topoToVertex.put(index, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(index);\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.get(vertex);\n            return topoIndex;\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.remove(topoIndex);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n    }\n\n    /**\n     * For performance and flexibility uses an ArrayList for topological index\n     * to vertex mapping, and a HashMap for vertex to topological index mapping.\n     *\n     * @author gilesp\n     */\n    public class TopoVertexMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<V> topoToVertex = new ArrayList<V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            int translatedIndex = translateIndex(index);\n\n            // grow topoToVertex as needed to accommodate elements\n            while ((translatedIndex + 1) > topoToVertex.size()) {\n                topoToVertex.add(null);\n            }\n\n            topoToVertex.set(translatedIndex, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(translateIndex(index));\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            return vertexToTopo.get(vertex);\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.set(translateIndex(topoIndex), null);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private final int translateIndex(int index)\n        {\n            if (index >= 0) {\n                return 2 * index;\n            }\n            return -1 * ((index * 2) - 1);\n        }\n    }\n\n    /**\n     * Region is an *inclusive* range of indices. Esthetically displeasing, but\n     * convenient for our purposes.\n     *\n     * @author gilesp\n     */\n    public static class Region\n        implements Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        public final int start;\n        public final int finish;\n\n        public Region(int start, int finish)\n        {\n            if (start > finish) {\n                throw new IllegalArgumentException(\n                    \"(start > finish): invariant broken\");\n            }\n            this.start = start;\n            this.finish = finish;\n        }\n\n        public int getSize()\n        {\n            return (finish - start) + 1;\n        }\n\n        public boolean isIn(int index)\n        {\n            return (index >= start) && (index <= finish);\n        }\n    }\n\n    /**\n     * This implementation is close to the performance of VisitedArrayListImpl,\n     * with 1/8 the memory usage.\n     *\n     * @author perfecthash\n     */\n    public static class VisitedBitSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final BitSet visited = new BitSet();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), true);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.get(translateIndex(index));\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.clear(translateIndex(index));\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation seems to offer the best performance in most cases. It\n     * grows the internal ArrayList as needed to be as large as |AR|, so it will\n     * be more memory intensive than the HashSet implementation, and unlike the\n     * Array implementation, it will hold on to that memory (it expands, but\n     * never contracts).\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayListImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<Boolean> visited = new ArrayList<Boolean>();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            // Make sure visited is big enough\n            int minSize = (affectedRegion.finish - affectedRegion.start) + 1;\n            /* plus one because the region range is inclusive of both indices */\n\n            while (visited.size() < minSize) {\n                visited.add(Boolean.FALSE);\n            }\n\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), Boolean.TRUE);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            Boolean result = null;\n\n            result = visited.get(translateIndex(index));\n\n            return result;\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.set(translateIndex(index), Boolean.FALSE);\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation doesn't seem to perform as well, though I can imagine\n     * circumstances where it should shine (lots and lots of vertices). It also\n     * should have the lowest memory footprint as it only uses storage for\n     * indices that have been visited.\n     *\n     * @author gilesp\n     */\n    public static class VisitedHashSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Set<Integer> visited = new HashSet<Integer>();\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            visited.clear();\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.add(index);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.contains(index);\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * This implementation, somewhat to my surprise, is slower than the\n     * ArrayList version, probably due to its reallocation of the underlying\n     * array for every topology reorder that is required.\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final boolean [] visited;\n\n        private final Region region;\n\n        /**\n         * Constructs empty factory instance\n         */\n        public VisitedArrayImpl()\n        {\n            this(null);\n        }\n\n        public VisitedArrayImpl(Region region)\n        {\n            if (region == null) { // make empty instance\n                this.visited = null;\n                this.region = null;\n            } else { // fill in the needed pieces\n                this.region = region;\n\n                // initialized to all false by default\n                visited = new boolean[region.getSize()];\n            }\n        }\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            return new VisitedArrayImpl(affectedRegion);\n        }\n\n        @Override public void setVisited(int index)\n        {\n            try {\n                visited[index - region.start] = true;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            try {\n                return visited[index - region.start];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Exception used in dfsF when a cycle is found\n     *\n     * @author gilesp\n     */\n    public static class CycleFoundException\n        extends Exception\n    {\n        private static final long serialVersionUID = 5583471522212552754L;\n    }\n\n    /**\n     * iterator which follows topological order\n     *\n     * @author gilesp\n     */\n    private class TopoIterator\n        implements Iterator<V>\n    {\n        private int currentTopoIndex;\n        private final long updateCountAtCreation;\n        private Integer nextIndex = null;\n\n        public TopoIterator()\n        {\n            updateCountAtCreation = topologyUpdateCount;\n            currentTopoIndex = minTopoIndex - 1;\n        }\n\n        @Override public boolean hasNext()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            nextIndex = getNextIndex();\n            return nextIndex != null;\n        }\n\n        @Override public V next()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            if (nextIndex == null) {\n                // find nextIndex\n                nextIndex = getNextIndex();\n            }\n            if (nextIndex == null) {\n                throw new NoSuchElementException();\n            }\n            currentTopoIndex = nextIndex;\n            nextIndex = null;\n            return topoOrderMap.getVertex(currentTopoIndex); //topoToVertex.get(currentTopoIndex);\n        }\n\n        @Override public void remove()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            V vertexToRemove = null;\n            if (null\n                != (vertexToRemove =\n                        topoOrderMap.getVertex(\n                            currentTopoIndex)))\n            {\n                topoOrderMap.removeVertex(vertexToRemove);\n            } else {\n                // should only happen if next() hasn't been called\n                throw new IllegalStateException();\n            }\n        }\n\n        private Integer getNextIndex()\n        {\n            for (int i = currentTopoIndex + 1; i <= maxTopoIndex; i++) {\n                if (null != topoOrderMap.getVertex(i)) {\n                    return i;\n                }\n            }\n            return null;\n        }\n    }\n}\n\n// End DirectedAcyclicGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "fromVertex", "", "V" ], [ "toVertex", "", "V" ], [ "e", "", "E" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdgeTarget", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeTarget(E arg0)" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "outDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int outDegreeOf(V arg0)" ], [ "getEdgeFactory", "org.jgrapht.graph", "AbstractBaseGraph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E edge)" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v, boolean addToTop)" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "clone", "org.jgrapht.graph", "AbstractBaseGraph", "public Object clone()" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "removeVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeVertex(V v)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "edgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgesOf(V arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "getEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E getEdge(V arg0, V arg1)" ], [ "inDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int inDegreeOf(V arg0)" ], [ "incomingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> incomingEdgesOf(V arg0)" ], [ "containsVertex", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsVertex(V arg0)" ], [ "createDirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean removeEdge(E arg0)" ], [ "isAllowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingLoops()" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "getEdgeWeight", "org.jgrapht.graph", "AbstractBaseGraph", "public double getEdgeWeight(E arg0)" ], [ "vertexSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<V> vertexSet()" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E removeEdge(V arg0, V arg1)" ], [ "iterator", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public Iterator<V> iterator()" ], [ "removeAllVertices", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "edgeSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgeSet()" ], [ "createUndirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addDagEdge(V fromVertex, V toVertex) throws CycleFoundException" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsEdge(E arg0)" ], [ "getAllEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addDagEdge(V fromVertex, V toVertex, E e) throws CycleFoundException" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "isAllowingMultipleEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingMultipleEdges()" ], [ "getEdgeSource", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeSource(E arg0)" ], [ "degreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int degreeOf(V arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "allowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "boolean allowingLoops;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25811,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental.dag",
  "className" : "DirectedAcyclicGraph",
  "javadocTag" : "@throws CycleFoundException if a cycle is discovered",
  "methodJavadoc" : "    /**\n     * Depth first search forward, building up the set (df) of forward-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param df the set we are populating with forward connected vertices in\n     * the Affected Region\n     * @param visited a simple data structure that lets us know if we already\n     * visited a node with a given topo index\n     * @param topoIndexMap for quick lookups, a map from vertex to topo index in\n     * the AR\n     * @param ub the topo index of the original fromVertex -- used for cycle\n     * detection\n     *\n     * @throws CycleFoundException if a cycle is discovered\n     */",
  "methodSourceCode" : "private void dfsF(V vertex, Set<V> df, Visited visited, Region affectedRegion) throws CycleFoundException{\n    int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n    // Assumption: vertex is in the AR and so it will be in visited\n    visited.setVisited(topoIndex);\n    df.add(vertex);\n    for (E outEdge : outgoingEdgesOf(vertex)) {\n        V nextVertex = getEdgeTarget(outEdge);\n        Integer nextVertexTopoIndex = topoOrderMap.getTopologicalIndex(nextVertex);\n        if (nextVertexTopoIndex.intValue() == affectedRegion.finish) {\n            // reset visited\n            try {\n                for (V visitedVertex : df) {\n                    visited.clearVisited(topoOrderMap.getTopologicalIndex(visitedVertex));\n                }\n            } catch (UnsupportedOperationException e) {\n                // okay, fine, some implementations (ones that automatically\n                // clear themselves out) don't work this way\n            }\n            throw new CycleFoundException();\n        }\n        // note, order of checks is important as we need to make sure the\n        // vertex is in the affected region before we check its visited\n        // status (otherwise we will be causing an\n        // ArrayIndexOutOfBoundsException).\n        if (affectedRegion.isIn(nextVertexTopoIndex) && !visited.getVisited(nextVertexTopoIndex)) {\n            // recurse\n            dfsF(nextVertex, df, visited, affectedRegion);\n        }\n    }\n}",
  "classJavadoc" : "/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * DirectedAcyclicGraph.java\n * -------------------\n * (C) Copyright 2008-2008, by Peter Giles and Contributors.\n *\n * Original Author:  Peter Giles\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 17-Mar-2008 : Initial revision (PG);\n * 23-Aug-2008 : Added VisitedBitSetImpl and made it the default (JVS);\n *\n */\npackage org.jgrapht.experimental.dag;\n\nimport java.io.*;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.*;\n\n\n/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.</p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http://www.mcs.vuw.ac.nz/~djp/files/PK-JEA07.pdf\">Paper</a> or <a\n * href=\"http://doi.acm.org/10.1145/1187436.1210590\">ACM link</a> for details).\n * </p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.</p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.</p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n */\npublic class DirectedAcyclicGraph<V, E>\n    extends SimpleDirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 4522128427004938150L;\n\n    private TopoComparator<V> topoComparator;\n\n    private TopoOrderMapping<V> topoOrderMap;\n\n    private int maxTopoIndex = 0;\n    private int minTopoIndex = 0;\n\n    // this update count is used to keep internal topological iterators honest\n    private long topologyUpdateCount = 0;\n\n    /**\n     * Pluggable VisitedFactory implementation\n     */\n    private VisitedFactory visitedFactory = new VisitedBitSetImpl();\n\n    /**\n     * Pluggable TopoOrderMappingFactory implementation\n     */\n    private TopoOrderMappingFactory<V> topoOrderFactory = new TopoVertexBiMap();\n\n    public DirectedAcyclicGraph(Class<? extends E> arg0)\n    {\n        super(arg0);\n        initialize();\n    }\n\n    public DirectedAcyclicGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n        initialize();\n    }\n\n    DirectedAcyclicGraph(\n        Class<? extends E> arg0,\n        VisitedFactory visitedFactory,\n        TopoOrderMappingFactory<V> topoOrderFactory)\n    {\n        super(arg0);\n        if (visitedFactory != null) {\n            this.visitedFactory = visitedFactory;\n        }\n        if (topoOrderFactory != null) {\n            this.topoOrderFactory = topoOrderFactory;\n        }\n        initialize();\n    }\n\n    /**\n     * set the topoOrderMap based on the current factory, and create the\n     * comparator;\n     */\n    private void initialize()\n    {\n        topoOrderMap = topoOrderFactory.getTopoOrderMapping();\n        topoComparator = new TopoComparator<V>(topoOrderMap);\n    }\n\n    /**\n     * iterator will traverse the vertices in topological order, meaning that\n     * for a directed graph G = (V,E), if there exists a path from vertex va to\n     * vertex vb then va is guaranteed to come before vertex vb in the iteration\n     * order.\n     *\n     * @return an iterator that will traverse the graph in topological order\n     */\n    public Iterator<V> iterator()\n    {\n        return new TopoIterator();\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it at the top\n     * of the internal topological vertex ordering\n     */\n    @Override public boolean addVertex(V v)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            // add to the top\n            ++maxTopoIndex;\n            topoOrderMap.putVertex(maxTopoIndex, v);\n\n            ++topologyUpdateCount;\n        }\n\n        return added;\n    }\n\n    /**\n     * adds the vertex if it wasn't already in the graph, and puts it either at\n     * the top or the bottom of the topological ordering, depending on the value\n     * of addToTop. This may provide useful optimizations for merging\n     * DirectedAcyclicGraphs that become connected.\n     *\n     * @param v\n     * @param addToTop\n     *\n     * @return whether new vertex was added\n     */\n    public boolean addVertex(V v, boolean addToTop)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            int insertIndex;\n\n            // add to the top\n            if (addToTop) {\n                insertIndex = ++maxTopoIndex;\n            } else {\n                insertIndex = --minTopoIndex;\n            }\n            topoOrderMap.putVertex(insertIndex, v);\n\n            ++topologyUpdateCount;\n        }\n        return added;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return null if the edge is already in the graph, else the created edge\n     * is returned\n     *\n     * @throws IllegalArgumentException If either fromVertex or toVertex is not\n     * a member of the graph\n     * @throws CycleFoundException if the edge would induce a cycle in the graph\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public E addDagEdge(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex);\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object)}, except an unchecked\n     * {@link IllegalArgumentException} is thrown if a cycle would have been\n     * induced by this edge\n     */\n    @Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E result = null;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>the given edge is not already a member of the graph\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * </ul>\n     *\n     * @return true if the edge was added to the graph\n     *\n     * @throws CycleFoundException if adding an edge (fromVertex, toVertex) to\n     * the graph would induce a cycle.\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     */\n    public boolean addDagEdge(V fromVertex, V toVertex, E e)\n        throws CycleFoundException\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex, e);\n    }\n\n    private void updateDag(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        Integer lb = topoOrderMap.getTopologicalIndex(toVertex);\n        Integer ub = topoOrderMap.getTopologicalIndex(fromVertex);\n\n        if ((lb == null) || (ub == null)) {\n            throw new IllegalArgumentException(\n                \"vertices must be in the graph already!\");\n        }\n\n        if (lb < ub) {\n            Set<V> df = new HashSet<V>();\n            Set<V> db = new HashSet<V>();\n\n            // Discovery\n            Region affectedRegion = new Region(lb, ub);\n            Visited visited = visitedFactory.getInstance(affectedRegion);\n\n            // throws CycleFoundException if there is a cycle\n            dfsF(toVertex, df, visited, affectedRegion);\n\n            dfsB(fromVertex, db, visited, affectedRegion);\n            reorder(df, db, visited);\n            ++topologyUpdateCount; // if we do a reorder, than the topology has\n                                   // been updated\n        }\n    }\n\n    /**\n     * identical to {@link #addDagEdge(Object, Object, Object)}, except an\n     * unchecked {@link IllegalArgumentException} is thrown if a cycle would\n     * have been induced by this edge\n     */\n    @Override public boolean addEdge(V sourceVertex, V targetVertex, E edge)\n    {\n        boolean result;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex, edge);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }\n\n    // note that this can leave holes in the topological ordering, which\n    // (depending on the TopoOrderMap implementation) can degrade performance\n    // for certain operations over time\n    @Override public boolean removeVertex(V v)\n    {\n        boolean removed = super.removeVertex(v);\n\n        if (removed) {\n            Integer topoIndex = topoOrderMap.removeVertex(v);\n\n            // contract minTopoIndex as we are able\n            if (topoIndex == minTopoIndex) {\n                while (\n                    (minTopoIndex < 0)\n                    && (null == topoOrderMap.getVertex(minTopoIndex)))\n                {\n                    ++minTopoIndex;\n                }\n            }\n\n            // contract maxTopoIndex as we are able\n            if (topoIndex == maxTopoIndex) {\n                while (\n                    (maxTopoIndex > 0)\n                    && (null == topoOrderMap.getVertex(maxTopoIndex)))\n                {\n                    --maxTopoIndex;\n                }\n            }\n\n            ++topologyUpdateCount;\n        }\n\n        return removed;\n    }\n\n    @Override public boolean removeAllVertices(Collection<? extends V> arg0)\n    {\n        boolean removed = super.removeAllVertices(arg0);\n\n        topoOrderMap.removeAllVertices();\n\n        maxTopoIndex = 0;\n        minTopoIndex = 0;\n\n        ++topologyUpdateCount;\n\n        return removed;\n    }\n\n    /**\n     * Depth first search forward, building up the set (df) of forward-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param df the set we are populating with forward connected vertices in\n     * the Affected Region\n     * @param visited a simple data structure that lets us know if we already\n     * visited a node with a given topo index\n     * @param topoIndexMap for quick lookups, a map from vertex to topo index in\n     * the AR\n     * @param ub the topo index of the original fromVertex -- used for cycle\n     * detection\n     *\n     * @throws CycleFoundException if a cycle is discovered\n     */\n    private void dfsF(\n        V vertex,\n        Set<V> df,\n        Visited visited,\n        Region affectedRegion)\n        throws CycleFoundException\n    {\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n        // Assumption: vertex is in the AR and so it will be in visited\n        visited.setVisited(topoIndex);\n\n        df.add(vertex);\n\n        for (E outEdge : outgoingEdgesOf(vertex)) {\n            V nextVertex = getEdgeTarget(outEdge);\n            Integer nextVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(nextVertex);\n\n            if (nextVertexTopoIndex.intValue() == affectedRegion.finish) {\n                // reset visited\n                try {\n                    for (V visitedVertex : df) {\n                        visited.clearVisited(\n                            topoOrderMap.getTopologicalIndex(visitedVertex));\n                    }\n                } catch (UnsupportedOperationException e) {\n                    // okay, fine, some implementations (ones that automatically\n                    // clear themselves out) don't work this way\n                }\n                throw new CycleFoundException();\n            }\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(nextVertexTopoIndex)\n                && !visited.getVisited(nextVertexTopoIndex))\n            {\n                dfsF(nextVertex, df, visited, affectedRegion); // recurse\n            }\n        }\n    }\n\n    /**\n     * Depth first search backward, building up the set (db) of back-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param db the set we are populating with back-connected vertices in the\n     * AR\n     * @param visited\n     * @param topoIndexMap\n     */\n    private void dfsB(\n        V vertex,\n        Set<V> db,\n        Visited visited,\n        Region affectedRegion)\n    {\n        // Assumption: vertex is in the AR and so we will get a topoIndex from\n        // the map\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n        visited.setVisited(topoIndex);\n\n        db.add(vertex);\n\n        for (E inEdge : incomingEdgesOf(vertex)) {\n            V previousVertex = getEdgeSource(inEdge);\n            Integer previousVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(previousVertex);\n\n            // note, order of checks is important as we need to make sure the\n            // vertex is in the affected region before we check its visited\n            // status (otherwise we will be causing an\n            // ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(previousVertexTopoIndex)\n                && !visited.getVisited(previousVertexTopoIndex))\n            {\n                // if prevousVertexTopoIndex != null, the vertex is in the\n                // Affected Region according to our topoIndexMap\n\n                dfsB(previousVertex, db, visited, affectedRegion);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void reorder(Set<V> df, Set<V> db, Visited visited)\n    {\n        List<V> topoDf = new ArrayList<V>(df);\n        List<V> topoDb = new ArrayList<V>(db);\n\n        Collections.sort(topoDf, topoComparator);\n        Collections.sort(topoDb, topoComparator);\n\n        // merge these suckers together in topo order\n\n        SortedSet<Integer> availableTopoIndices = new TreeSet<Integer>();\n\n        // we have to cast to the generic type, can't do \"new V[size]\" in java\n        // 5;\n        V [] bigL = (V []) new Object[df.size() + db.size()];\n        int lIndex = 0; // this index is used for the sole purpose of pushing\n                        // into\n\n        // the correct index of bigL\n\n        // assume (for now) that we are resetting visited\n        boolean clearVisited = true;\n\n        for (V vertex : topoDb) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        for (V vertex : topoDf) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            // add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { // reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        lIndex = 0; // reusing lIndex\n        for (Integer topoIndex : availableTopoIndices) {\n            // assign the indexes to the elements of bigL in order\n            V vertex = bigL[lIndex++]; // note the post-increment\n            topoOrderMap.putVertex(topoIndex, vertex);\n        }\n    }\n\n    /**\n     * For performance tuning, an interface for storing the topological ordering\n     *\n     * @author gilesp\n     */\n    public interface TopoOrderMapping<V>\n        extends Serializable\n    {\n        /**\n         * add a vertex at the given topological index.\n         *\n         * @param index\n         * @param vertex\n         */\n        public void putVertex(Integer index, V vertex);\n\n        /**\n         * get the vertex at the given topological index.\n         *\n         * @param index\n         *\n         * @return vertex\n         */\n        public V getVertex(Integer index);\n\n        /**\n         * get the topological index of the given vertex.\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex is at, or null if the vertex isn't\n         * in the topological ordering\n         */\n        public Integer getTopologicalIndex(V vertex);\n\n        /**\n         * remove the given vertex from the topological ordering\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex was at, or null if the vertex\n         * wasn't in the topological ordering\n         */\n        public Integer removeVertex(V vertex);\n\n        /**\n         * remove all vertices from the topological ordering\n         */\n        public void removeAllVertices();\n    }\n\n    public interface TopoOrderMappingFactory<V>\n    {\n        public TopoOrderMapping<V> getTopoOrderMapping();\n    }\n\n    /**\n     * this interface allows specification of a strategy for marking vertices as\n     * visited (based on their topological index, so the vertex type isn't part\n     * of the interface).\n     */\n    public interface Visited\n    {\n        /**\n         * mark the given topological index as visited\n         *\n         * @param index the topological index\n         */\n        public void setVisited(int index);\n\n        /**\n         * has the given topological index been visited?\n         *\n         * @param index the topological index\n         */\n        public boolean getVisited(int index);\n\n        /**\n         * Clear the visited state of the given topological index\n         *\n         * @param index\n         *\n         * @throws UnsupportedOperationException if the implementation doesn't\n         * support (or doesn't need) clearance. For example, if the factory\n         * vends a new instance every time, it is a waste of cycles to clear the\n         * state after the search of the Affected Region is done, so an\n         * UnsupportedOperationException *should* be thrown.\n         */\n        public void clearVisited(int index)\n            throws UnsupportedOperationException;\n    }\n\n    /**\n     * interface for a factory that vends Visited implementations\n     *\n     * @author gilesp\n     */\n    public interface VisitedFactory\n        extends Serializable\n    {\n        public Visited getInstance(Region affectedRegion);\n    }\n\n    /**\n     * Note, this is a lazy and incomplete implementation, with assumptions that\n     * inputs are in the given topoIndexMap\n     *\n     * @param <V>\n     *\n     * @author gilesp\n     */\n    private static class TopoComparator<V>\n        implements Comparator<V>,\n            Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private TopoOrderMapping<V> topoOrderMap;\n\n        public TopoComparator(TopoOrderMapping<V> topoOrderMap)\n        {\n            this.topoOrderMap = topoOrderMap;\n        }\n\n        @Override public int compare(V o1, V o2)\n        {\n            return topoOrderMap.getTopologicalIndex(o1).compareTo(\n                topoOrderMap.getTopologicalIndex(o2));\n        }\n    }\n\n    /**\n     * a dual HashMap implementation\n     *\n     * @author gilesp\n     */\n    private class TopoVertexBiMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Map<Integer, V> topoToVertex = new HashMap<Integer, V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            topoToVertex.put(index, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(index);\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.get(vertex);\n            return topoIndex;\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.remove(topoIndex);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n    }\n\n    /**\n     * For performance and flexibility uses an ArrayList for topological index\n     * to vertex mapping, and a HashMap for vertex to topological index mapping.\n     *\n     * @author gilesp\n     */\n    public class TopoVertexMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<V> topoToVertex = new ArrayList<V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            int translatedIndex = translateIndex(index);\n\n            // grow topoToVertex as needed to accommodate elements\n            while ((translatedIndex + 1) > topoToVertex.size()) {\n                topoToVertex.add(null);\n            }\n\n            topoToVertex.set(translatedIndex, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(translateIndex(index));\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            return vertexToTopo.get(vertex);\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.set(translateIndex(topoIndex), null);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private final int translateIndex(int index)\n        {\n            if (index >= 0) {\n                return 2 * index;\n            }\n            return -1 * ((index * 2) - 1);\n        }\n    }\n\n    /**\n     * Region is an *inclusive* range of indices. Esthetically displeasing, but\n     * convenient for our purposes.\n     *\n     * @author gilesp\n     */\n    public static class Region\n        implements Serializable\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        public final int start;\n        public final int finish;\n\n        public Region(int start, int finish)\n        {\n            if (start > finish) {\n                throw new IllegalArgumentException(\n                    \"(start > finish): invariant broken\");\n            }\n            this.start = start;\n            this.finish = finish;\n        }\n\n        public int getSize()\n        {\n            return (finish - start) + 1;\n        }\n\n        public boolean isIn(int index)\n        {\n            return (index >= start) && (index <= finish);\n        }\n    }\n\n    /**\n     * This implementation is close to the performance of VisitedArrayListImpl,\n     * with 1/8 the memory usage.\n     *\n     * @author perfecthash\n     */\n    public static class VisitedBitSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final BitSet visited = new BitSet();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), true);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.get(translateIndex(index));\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.clear(translateIndex(index));\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation seems to offer the best performance in most cases. It\n     * grows the internal ArrayList as needed to be as large as |AR|, so it will\n     * be more memory intensive than the HashSet implementation, and unlike the\n     * Array implementation, it will hold on to that memory (it expands, but\n     * never contracts).\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayListImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final List<Boolean> visited = new ArrayList<Boolean>();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            // Make sure visited is big enough\n            int minSize = (affectedRegion.finish - affectedRegion.start) + 1;\n            /* plus one because the region range is inclusive of both indices */\n\n            while (visited.size() < minSize) {\n                visited.add(Boolean.FALSE);\n            }\n\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), Boolean.TRUE);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            Boolean result = null;\n\n            result = visited.get(translateIndex(index));\n\n            return result;\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.set(translateIndex(index), Boolean.FALSE);\n        }\n\n        /**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         */\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }\n\n    /**\n     * This implementation doesn't seem to perform as well, though I can imagine\n     * circumstances where it should shine (lots and lots of vertices). It also\n     * should have the lowest memory footprint as it only uses storage for\n     * indices that have been visited.\n     *\n     * @author gilesp\n     */\n    public static class VisitedHashSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final Set<Integer> visited = new HashSet<Integer>();\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            visited.clear();\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.add(index);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.contains(index);\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * This implementation, somewhat to my surprise, is slower than the\n     * ArrayList version, probably due to its reallocation of the underlying\n     * array for every topology reorder that is required.\n     *\n     * @author gilesp\n     */\n    public static class VisitedArrayImpl\n        implements Visited,\n            VisitedFactory\n    {\n        /**\n         */\n        private static final long serialVersionUID = 1L;\n\n        private final boolean [] visited;\n\n        private final Region region;\n\n        /**\n         * Constructs empty factory instance\n         */\n        public VisitedArrayImpl()\n        {\n            this(null);\n        }\n\n        public VisitedArrayImpl(Region region)\n        {\n            if (region == null) { // make empty instance\n                this.visited = null;\n                this.region = null;\n            } else { // fill in the needed pieces\n                this.region = region;\n\n                // initialized to all false by default\n                visited = new boolean[region.getSize()];\n            }\n        }\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            return new VisitedArrayImpl(affectedRegion);\n        }\n\n        @Override public void setVisited(int index)\n        {\n            try {\n                visited[index - region.start] = true;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            try {\n                return visited[index - region.start];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                */\n                throw e;\n            }\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Exception used in dfsF when a cycle is found\n     *\n     * @author gilesp\n     */\n    public static class CycleFoundException\n        extends Exception\n    {\n        private static final long serialVersionUID = 5583471522212552754L;\n    }\n\n    /**\n     * iterator which follows topological order\n     *\n     * @author gilesp\n     */\n    private class TopoIterator\n        implements Iterator<V>\n    {\n        private int currentTopoIndex;\n        private final long updateCountAtCreation;\n        private Integer nextIndex = null;\n\n        public TopoIterator()\n        {\n            updateCountAtCreation = topologyUpdateCount;\n            currentTopoIndex = minTopoIndex - 1;\n        }\n\n        @Override public boolean hasNext()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            nextIndex = getNextIndex();\n            return nextIndex != null;\n        }\n\n        @Override public V next()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            if (nextIndex == null) {\n                // find nextIndex\n                nextIndex = getNextIndex();\n            }\n            if (nextIndex == null) {\n                throw new NoSuchElementException();\n            }\n            currentTopoIndex = nextIndex;\n            nextIndex = null;\n            return topoOrderMap.getVertex(currentTopoIndex); //topoToVertex.get(currentTopoIndex);\n        }\n\n        @Override public void remove()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            V vertexToRemove = null;\n            if (null\n                != (vertexToRemove =\n                        topoOrderMap.getVertex(\n                            currentTopoIndex)))\n            {\n                topoOrderMap.removeVertex(vertexToRemove);\n            } else {\n                // should only happen if next() hasn't been called\n                throw new IllegalStateException();\n            }\n        }\n\n        private Integer getNextIndex()\n        {\n            for (int i = currentTopoIndex + 1; i <= maxTopoIndex; i++) {\n                if (null != topoOrderMap.getVertex(i)) {\n                    return i;\n                }\n            }\n            return null;\n        }\n    }\n}\n\n// End DirectedAcyclicGraph.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "vertex", "", "V" ], [ "df", "java.util.Set", "Set<V>" ], [ "visited", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph.Visited" ], [ "affectedRegion", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph.Region" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addDagEdge(V fromVertex, V toVertex, E e) throws CycleFoundException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "degreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int degreeOf(V arg0)" ], [ "removeAllVertices", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeAllVertices(Collection<? extends V> arg0)" ], [ "edgeSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgeSet()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public boolean removeAllEdges(Collection<? extends E> arg0)" ], [ "toStringFromSets", "org.jgrapht.graph", "AbstractGraph", "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)" ], [ "incomingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> incomingEdgesOf(V arg0)" ], [ "outDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int outDegreeOf(V arg0)" ], [ "iterator", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public Iterator<V> iterator()" ], [ "getEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E getEdge(V arg0, V arg1)" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addEdge(V sourceVertex, V targetVertex)" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v, boolean addToTop)" ], [ "assertVertexExist", "org.jgrapht.graph", "AbstractGraph", "protected boolean assertVertexExist(V arg0)" ], [ "removeVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean removeVertex(V v)" ], [ "toString", "org.jgrapht.graph", "AbstractGraph", "public String toString()" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "public Set<E> removeAllEdges(V arg0, V arg1)" ], [ "removeAllEdges", "org.jgrapht.graph", "AbstractGraph", "protected boolean removeAllEdges(E[] arg0)" ], [ "createUndirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()" ], [ "inDegreeOf", "org.jgrapht.graph", "AbstractBaseGraph", "public int inDegreeOf(V arg0)" ], [ "addEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addEdge(V sourceVertex, V targetVertex, E edge)" ], [ "clone", "org.jgrapht.graph", "AbstractBaseGraph", "public Object clone()" ], [ "isAllowingMultipleEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingMultipleEdges()" ], [ "containsEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsEdge(E arg0)" ], [ "containsEdge", "org.jgrapht.graph", "AbstractGraph", "public boolean containsEdge(V arg0, V arg1)" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public E removeEdge(V arg0, V arg1)" ], [ "containsVertex", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean containsVertex(V arg0)" ], [ "getAllEdges", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> getAllEdges(V arg0, V arg1)" ], [ "createDirectedSpecifics", "org.jgrapht.graph", "AbstractBaseGraph", "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()" ], [ "getEdgeWeight", "org.jgrapht.graph", "AbstractBaseGraph", "public double getEdgeWeight(E arg0)" ], [ "isAllowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean isAllowingLoops()" ], [ "addDagEdge", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public E addDagEdge(V fromVertex, V toVertex) throws CycleFoundException" ], [ "outgoingEdgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> outgoingEdgesOf(V arg0)" ], [ "getEdgeFactory", "org.jgrapht.graph", "AbstractBaseGraph", "public EdgeFactory<V, E> getEdgeFactory()" ], [ "hashCode", "org.jgrapht.graph", "AbstractGraph", "public int hashCode()" ], [ "vertexSet", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<V> vertexSet()" ], [ "removeEdge", "org.jgrapht.graph", "AbstractBaseGraph", "public boolean removeEdge(E arg0)" ], [ "getEdgeTarget", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeTarget(E arg0)" ], [ "getEdgeSource", "org.jgrapht.graph", "AbstractBaseGraph", "public V getEdgeSource(E arg0)" ], [ "edgesOf", "org.jgrapht.graph", "AbstractBaseGraph", "public Set<E> edgesOf(V arg0)" ], [ "equals", "org.jgrapht.graph", "AbstractGraph", "public boolean equals(Object arg0)" ], [ "addVertex", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph", "public boolean addVertex(V v)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toArray", "java.util", "Set", "public abstract Object[] toArray()" ], [ "equals", "java.util", "Set", "public abstract boolean equals(Object arg0)" ], [ "size", "java.util", "Set", "public abstract int size()" ], [ "addAll", "java.util", "Set", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "contains", "java.util", "Set", "public abstract boolean contains(Object arg0)" ], [ "add", "java.util", "Set", "public abstract boolean add(E arg0)" ], [ "retainAll", "java.util", "Set", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "removeAll", "java.util", "Set", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "containsAll", "java.util", "Set", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "Set", "public abstract int hashCode()" ], [ "spliterator", "java.util", "Set", "public default Spliterator<E> spliterator()" ], [ "isEmpty", "java.util", "Set", "public abstract boolean isEmpty()" ], [ "toArray", "java.util", "Set", "public abstract <T> T[] toArray(T[] arg0)" ], [ "iterator", "java.util", "Set", "public abstract Iterator<E> iterator()" ], [ "remove", "java.util", "Set", "public abstract boolean remove(Object arg0)" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getVisited", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph.Visited", "public boolean getVisited(int index)" ], [ "getSize", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph.Region", "public int getSize()" ], [ "isIn", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph.Region", "public boolean isIn(int index)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "allowingLoops", "org.jgrapht.graph", "AbstractBaseGraph", "boolean allowingLoops;" ], [ "start", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph.Region", "public final int start;" ], [ "finish", "org.jgrapht.experimental.dag", "DirectedAcyclicGraph.Region", "public final int finish;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25818,
  "oracle" : "numVertices >= 0 && (numEdges <= (numVertices * (numVertices - 1) / 2));",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental",
  "className" : "UniformRandomGraphGenerator",
  "javadocTag" : "@param numVertices number of vertices to be generated",
  "methodJavadoc" : "    /**\n     * Construct a new UniformRandomGraphGenerator.\n     *\n     * @param numVertices number of vertices to be generated\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */",
  "methodSourceCode" : "public UniformRandomGraphGenerator(int numVertices, int numEdges){\n    if (numVertices < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    if ((numEdges < 0) || (numEdges > (numVertices * (numVertices - 1) / 2))) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}",
  "classJavadoc" : "/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">uniform random graph</a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * UniformRandomGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by Michael Behrisch and Contributors.\n *\n * Original Author:  Michael Behrisch\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 13-Sep-2004 : Initial revision (MB);\n *\n */\n// package org.jgrapht.generate;\npackage org.jgrapht.experimental;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.generate.*;\n\n\n/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">uniform random graph</a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */\npublic class UniformRandomGraphGenerator\n    implements GraphGenerator\n{\n    private final int numEdges;\n    private final int numVertices;\n\n    /**\n     * Construct a new UniformRandomGraphGenerator.\n     *\n     * @param numVertices number of vertices to be generated\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */\n    public UniformRandomGraphGenerator(int numVertices, int numEdges)\n    {\n        if (numVertices < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        if ((numEdges < 0)\n            || (numEdges > (numVertices * (numVertices - 1) / 2)))\n        {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }\n\n    /**\n     * @see GraphGenerator#generateGraph\n     */\n    @Override public void generateGraph(\n        Graph target,\n        VertexFactory vertexFactory,\n        Map resultMap)\n    {\n        Object [] vertices =\n            RandomGraphHelper.addVertices(\n                target,\n                vertexFactory,\n                numVertices);\n        RandomGraphHelper.addEdges(\n            target,\n            Arrays.asList(vertices),\n            Arrays.asList(vertices),\n            numEdges);\n    }\n}\n\n// End UniformRandomGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "numVertices", "", "int" ], [ "numEdges", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25819,
  "oracle" : "(numEdges >= 0) && (numEdges <= (numVertices * (numVertices - 1) / 2));",
  "oracleType" : "PRE",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental",
  "className" : "UniformRandomGraphGenerator",
  "javadocTag" : "@param numEdges number of edges to be generated",
  "methodJavadoc" : "    /**\n     * Construct a new UniformRandomGraphGenerator.\n     *\n     * @param numVertices number of vertices to be generated\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */",
  "methodSourceCode" : "public UniformRandomGraphGenerator(int numVertices, int numEdges){\n    if (numVertices < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    if ((numEdges < 0) || (numEdges > (numVertices * (numVertices - 1) / 2))) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}",
  "classJavadoc" : "/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">uniform random graph</a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * UniformRandomGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by Michael Behrisch and Contributors.\n *\n * Original Author:  Michael Behrisch\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 13-Sep-2004 : Initial revision (MB);\n *\n */\n// package org.jgrapht.generate;\npackage org.jgrapht.experimental;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.generate.*;\n\n\n/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">uniform random graph</a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */\npublic class UniformRandomGraphGenerator\n    implements GraphGenerator\n{\n    private final int numEdges;\n    private final int numVertices;\n\n    /**\n     * Construct a new UniformRandomGraphGenerator.\n     *\n     * @param numVertices number of vertices to be generated\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */\n    public UniformRandomGraphGenerator(int numVertices, int numEdges)\n    {\n        if (numVertices < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        if ((numEdges < 0)\n            || (numEdges > (numVertices * (numVertices - 1) / 2)))\n        {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }\n\n    /**\n     * @see GraphGenerator#generateGraph\n     */\n    @Override public void generateGraph(\n        Graph target,\n        VertexFactory vertexFactory,\n        Map resultMap)\n    {\n        Object [] vertices =\n            RandomGraphHelper.addVertices(\n                target,\n                vertexFactory,\n                numVertices);\n        RandomGraphHelper.addEdges(\n            target,\n            Arrays.asList(vertices),\n            Arrays.asList(vertices),\n            numEdges);\n    }\n}\n\n// End UniformRandomGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "numVertices", "", "int" ], [ "numEdges", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 25820,
  "oracle" : "numVertices < 0 || (numEdges < 0) || (numEdges > (numVertices * (numVertices - 1) / 2));",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "jgrapht-core-0.9.2",
  "packageName" : "org.jgrapht.experimental",
  "className" : "UniformRandomGraphGenerator",
  "javadocTag" : "@throws IllegalArgumentException",
  "methodJavadoc" : "    /**\n     * Construct a new UniformRandomGraphGenerator.\n     *\n     * @param numVertices number of vertices to be generated\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */",
  "methodSourceCode" : "public UniformRandomGraphGenerator(int numVertices, int numEdges){\n    if (numVertices < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    if ((numEdges < 0) || (numEdges > (numVertices * (numVertices - 1) / 2))) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}",
  "classJavadoc" : "/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">uniform random graph</a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */",
  "classSourceCode" : "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------\n * UniformRandomGraphGenerator.java\n * -------------------\n * (C) Copyright 2003-2008, by Michael Behrisch and Contributors.\n *\n * Original Author:  Michael Behrisch\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 13-Sep-2004 : Initial revision (MB);\n *\n */\n// package org.jgrapht.generate;\npackage org.jgrapht.experimental;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\nimport org.jgrapht.generate.*;\n\n\n/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http://mathworld.wolfram.com/RandomGraph.html\">uniform random graph</a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n */\npublic class UniformRandomGraphGenerator\n    implements GraphGenerator\n{\n    private final int numEdges;\n    private final int numVertices;\n\n    /**\n     * Construct a new UniformRandomGraphGenerator.\n     *\n     * @param numVertices number of vertices to be generated\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     */\n    public UniformRandomGraphGenerator(int numVertices, int numEdges)\n    {\n        if (numVertices < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        if ((numEdges < 0)\n            || (numEdges > (numVertices * (numVertices - 1) / 2)))\n        {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }\n\n    /**\n     * @see GraphGenerator#generateGraph\n     */\n    @Override public void generateGraph(\n        Graph target,\n        VertexFactory vertexFactory,\n        Map resultMap)\n    {\n        Object [] vertices =\n            RandomGraphHelper.addVertices(\n                target,\n                vertexFactory,\n                numVertices);\n        RandomGraphHelper.addEdges(\n            target,\n            Arrays.asList(vertices),\n            Arrays.asList(vertices),\n            numEdges);\n    }\n}\n\n// End UniformRandomGraphGenerator.java\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "PartiteRandomGraphGenerator", "org.jgrapht.experimental" ], [ "RandomGraphHelper", "org.jgrapht.experimental" ], [ "GraphReader", "org.jgrapht.experimental" ], [ "DirectedAcyclicGraph", "org.jgrapht.experimental.dag" ], [ "GraphSquare", "org.jgrapht.experimental" ], [ "UniformRandomGraphGenerator", "org.jgrapht.experimental" ], [ "GraphTests", "org.jgrapht.experimental" ], [ "ApproximationAlgorithm", "org.jgrapht.experimental.alg" ], [ "BrownBacktrackColoring", "org.jgrapht.experimental.alg.color" ], [ "GreedyColoring", "org.jgrapht.experimental.alg.color" ], [ "IntArrayGraphAlgorithm", "org.jgrapht.experimental.alg" ], [ "ExactAlgorithm", "org.jgrapht.experimental.alg" ], [ "ListenableGraph", "org.jgrapht" ], [ "ModifiableInteger", "org.jgrapht.util" ], [ "FibonacciHeapNode", "org.jgrapht.util" ], [ "WeightCombiner", "org.jgrapht.util" ], [ "FibonacciHeap", "org.jgrapht.util" ], [ "TypeUtil", "org.jgrapht.util" ], [ "ArrayUnenforcedSet", "org.jgrapht.util" ], [ "VertexPair", "org.jgrapht.util" ], [ "MathUtil", "org.jgrapht.util" ], [ "PrefetchIterator", "org.jgrapht.util" ], [ "VertexFactory", "org.jgrapht" ], [ "Graph", "org.jgrapht" ], [ "GraphPath", "org.jgrapht" ], [ "UndirectedGraphUnion", "org.jgrapht.graph" ], [ "SimpleGraph", "org.jgrapht.graph" ], [ "MixedGraphUnion", "org.jgrapht.graph" ], [ "DefaultGraphMapping", "org.jgrapht.graph" ], [ "WeightedPseudograph", "org.jgrapht.graph" ], [ "UndirectedMaskSubgraph", "org.jgrapht.graph" ], [ "MaskEdgeSet", "org.jgrapht.graph" ], [ "Pseudograph", "org.jgrapht.graph" ], [ "MaskFunctor", "org.jgrapht.graph" ], [ "GraphUnion", "org.jgrapht.graph" ], [ "DirectedMaskSubgraph", "org.jgrapht.graph" ], [ "DirectedMultigraph", "org.jgrapht.graph" ], [ "AbstractBaseGraph", "org.jgrapht.graph" ], [ "DirectedWeightedPseudograph", "org.jgrapht.graph" ], [ "Multigraph", "org.jgrapht.graph" ], [ "DefaultDirectedGraph", "org.jgrapht.graph" ], [ "DefaultWeightedEdge", "org.jgrapht.graph" ], [ "ListenableDirectedWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphUnion", "org.jgrapht.graph" ], [ "AsUnweightedGraph", "org.jgrapht.graph" ], [ "EdgeSetFactory", "org.jgrapht.graph" ], [ "GraphDelegator", "org.jgrapht.graph" ], [ "DefaultListenableGraph", "org.jgrapht.graph" ], [ "AsUndirectedGraph", "org.jgrapht.graph" ], [ "ClassBasedVertexFactory", "org.jgrapht.graph" ], [ "DefaultEdge", "org.jgrapht.graph" ], [ "MaskVertexSet", "org.jgrapht.graph" ], [ "ListenableUndirectedGraph", "org.jgrapht.graph" ], [ "DirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "ListenableUndirectedWeightedGraph", "org.jgrapht.graph" ], [ "AsUnweightedDirectedGraph", "org.jgrapht.graph" ], [ "DefaultDirectedWeightedGraph", "org.jgrapht.graph" ], [ "IntrusiveEdge", "org.jgrapht.graph" ], [ "UnmodifiableGraph", "org.jgrapht.graph" ], [ "GraphPathImpl", "org.jgrapht.graph" ], [ "Subgraph", "org.jgrapht.graph" ], [ "UndirectedWeightedSubgraph", "org.jgrapht.graph" ], [ "DirectedPseudograph", "org.jgrapht.graph" ], [ "AbstractGraph", "org.jgrapht.graph" ], [ "MaskSubgraph", "org.jgrapht.graph" ], [ "ClassBasedEdgeFactory", "org.jgrapht.graph" ], [ "SimpleWeightedGraph", "org.jgrapht.graph" ], [ "AsWeightedDirectedGraph", "org.jgrapht.graph" ], [ "SimpleDirectedWeightedGraph", "org.jgrapht.graph" ], [ "UnmodifiableUndirectedGraph", "org.jgrapht.graph" ], [ "UndirectedSubgraph", "org.jgrapht.graph" ], [ "WeightedMultigraph", "org.jgrapht.graph" ], [ "EdgeReversedGraph", "org.jgrapht.graph" ], [ "AsWeightedGraph", "org.jgrapht.graph" ], [ "DirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "UndirectedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "UndirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "AbstractGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedWeightedGraphBuilder", "org.jgrapht.graph.builder" ], [ "DirectedGraphBuilderBase", "org.jgrapht.graph.builder" ], [ "ListenableDirectedGraph", "org.jgrapht.graph" ], [ "UnmodifiableDirectedGraph", "org.jgrapht.graph" ], [ "SimpleGraphPath", "org.jgrapht.graph" ], [ "ParanoidGraph", "org.jgrapht.graph" ], [ "DirectedWeightedMultigraph", "org.jgrapht.graph" ], [ "DirectedSubgraph", "org.jgrapht.graph" ], [ "SimpleDirectedGraph", "org.jgrapht.graph" ], [ "GraphHelper", "org.jgrapht" ], [ "Graphs", "org.jgrapht" ], [ "DirectedGraph", "org.jgrapht" ], [ "WeightedGraph", "org.jgrapht" ], [ "HyperCubeGraphGenerator", "org.jgrapht.generate" ], [ "RingGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedGraphMatrixGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGenerator", "org.jgrapht.generate" ], [ "WheelGraphGenerator", "org.jgrapht.generate" ], [ "GridGraphGenerator", "org.jgrapht.generate" ], [ "ScaleFreeGraphGenerator", "org.jgrapht.generate" ], [ "SimpleWeightedBipartiteGraphMatrixGenerator", "org.jgrapht.generate" ], [ "LinearGraphGenerator", "org.jgrapht.generate" ], [ "CompleteGraphGenerator", "org.jgrapht.generate" ], [ "RandomGraphGenerator", "org.jgrapht.generate" ], [ "WeightedGraphGeneratorAdapter", "org.jgrapht.generate" ], [ "EmptyGraphGenerator", "org.jgrapht.generate" ], [ "CompleteBipartiteGraphGenerator", "org.jgrapht.generate" ], [ "GraphGenerator", "org.jgrapht.generate" ], [ "StarGraphGenerator", "org.jgrapht.generate" ], [ "UndirectedGraph", "org.jgrapht" ], [ "TopologicalOrderIterator", "org.jgrapht.traverse" ], [ "CrossComponentIterator", "org.jgrapht.traverse" ], [ "AbstractGraphIterator", "org.jgrapht.traverse" ], [ "ClosestFirstIterator", "org.jgrapht.traverse" ], [ "BreadthFirstIterator", "org.jgrapht.traverse" ], [ "DepthFirstIterator", "org.jgrapht.traverse" ], [ "GraphIterator", "org.jgrapht.traverse" ], [ "EdgeFactory", "org.jgrapht" ], [ "GraphMapping", "org.jgrapht" ], [ "VertexSetListener", "org.jgrapht.event" ], [ "EdgeTraversalEvent", "org.jgrapht.event" ], [ "TraversalListener", "org.jgrapht.event" ], [ "GraphEdgeChangeEvent", "org.jgrapht.event" ], [ "VertexTraversalEvent", "org.jgrapht.event" ], [ "GraphChangeEvent", "org.jgrapht.event" ], [ "GraphListener", "org.jgrapht.event" ], [ "TraversalListenerAdapter", "org.jgrapht.event" ], [ "ConnectedComponentTraversalEvent", "org.jgrapht.event" ], [ "GraphVertexChangeEvent", "org.jgrapht.event" ], [ "TarjanLowestCommonAncestor", "org.jgrapht.alg" ], [ "PrimMinimumSpanningTree", "org.jgrapht.alg" ], [ "BlockCutpointGraph", "org.jgrapht.alg" ], [ "AllDirectedPaths", "org.jgrapht.alg" ], [ "KShortestPathsIterator", "org.jgrapht.alg" ], [ "KruskalMinimumSpanningTree", "org.jgrapht.alg" ], [ "StrongConnectivityInspector", "org.jgrapht.alg" ], [ "VF2State", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "VF2AbstractIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismState", "org.jgrapht.alg.isomorphism" ], [ "IsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "GraphOrdering", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "IsomorphicGraphMapping", "org.jgrapht.alg.isomorphism" ], [ "VF2GraphIsomorphismInspector", "org.jgrapht.alg.isomorphism" ], [ "VF2SubgraphMappingIterator", "org.jgrapht.alg.isomorphism" ], [ "VF2MappingIterator", "org.jgrapht.alg.isomorphism" ], [ "BronKerboschCliqueFinder", "org.jgrapht.alg" ], [ "ChromaticNumber", "org.jgrapht.alg" ], [ "KosarajuStrongConnectivityInspector", "org.jgrapht.alg" ], [ "BellmanFordShortestPath", "org.jgrapht.alg" ], [ "DijkstraShortestPath", "org.jgrapht.alg" ], [ "RankingPathElement", "org.jgrapht.alg" ], [ "AStarShortestPath", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg" ], [ "BellmanFordPathElement", "org.jgrapht.alg" ], [ "FloydWarshallShortestPaths", "org.jgrapht.alg" ], [ "UnionFind", "org.jgrapht.alg.util" ], [ "AlwaysEqualComparator", "org.jgrapht.alg.util" ], [ "Extension", "org.jgrapht.alg.util" ], [ "VertexDegreeComparator", "org.jgrapht.alg.util" ], [ "Pair", "org.jgrapht.alg.util" ], [ "GabowStrongConnectivityInspector", "org.jgrapht.alg" ], [ "HawickJamesSimpleCycles", "org.jgrapht.alg.cycle" ], [ "DirectedSimpleCycles", "org.jgrapht.alg.cycle" ], [ "JohnsonSimpleCycles", "org.jgrapht.alg.cycle" ], [ "TiernanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "UndirectedCycleBase", "org.jgrapht.alg.cycle" ], [ "PatonCycleBase", "org.jgrapht.alg.cycle" ], [ "TarjanSimpleCycles", "org.jgrapht.alg.cycle" ], [ "SzwarcfiterLauerSimpleCycles", "org.jgrapht.alg.cycle" ], [ "BiconnectivityInspector", "org.jgrapht.alg" ], [ "ConnectivityInspector", "org.jgrapht.alg" ], [ "MinSourceSinkCut", "org.jgrapht.alg" ], [ "RankingPathElementList", "org.jgrapht.alg" ], [ "EdmondsBlossomShrinking", "org.jgrapht.alg" ], [ "TransitiveClosure", "org.jgrapht.alg" ], [ "HopcroftKarpBipartiteMatching", "org.jgrapht.alg" ], [ "StoerWagnerMinimumCut", "org.jgrapht.alg" ], [ "AbstractPathElementList", "org.jgrapht.alg" ], [ "KuhnMunkresMinimalWeightBipartitePerfectMatching", "org.jgrapht.alg" ], [ "TransitiveReduction", "org.jgrapht.alg" ], [ "EulerianCircuit", "org.jgrapht.alg" ], [ "DirectedNeighborIndex", "org.jgrapht.alg" ], [ "NaiveLcaFinder", "org.jgrapht.alg" ], [ "MaximumWeightBipartiteMatching", "org.jgrapht.alg" ], [ "HamiltonianCycle", "org.jgrapht.alg" ], [ "KShortestPaths", "org.jgrapht.alg" ], [ "NeighborIndex", "org.jgrapht.alg" ], [ "VertexCovers", "org.jgrapht.alg" ], [ "CycleDetector", "org.jgrapht.alg" ], [ "AStarAdmissibleHeuristic", "org.jgrapht.alg.interfaces" ], [ "MinimumSpanningTree", "org.jgrapht.alg.interfaces" ], [ "WeightedMatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "StrongConnectivityAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MaximumFlowAlgorithm", "org.jgrapht.alg.interfaces" ], [ "MatchingAlgorithm", "org.jgrapht.alg.interfaces" ], [ "CliqueMinimalSeparatorDecomposition", "org.jgrapht.alg" ], [ "BellmanFordIterator", "org.jgrapht.alg" ], [ "AbstractPathElement", "org.jgrapht.alg" ], [ "EdmondsKarpMaximumFlow", "org.jgrapht.alg.flow" ], [ "PushRelabelMaximumFlow", "org.jgrapht.alg.flow" ], [ "MaximumFlowAlgorithmBase", "org.jgrapht.alg.flow" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "addVertices", "org.jgrapht.experimental", "RandomGraphHelper", "public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)" ], [ "isEmpty", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isEmpty(Graph<V, E> g)" ], [ "isComplete", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isComplete(Graph<V, E> g)" ], [ "isConnected", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isConnected(Graph<V, E> g)" ], [ "isTree", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isTree(Graph<V, E> g)" ], [ "isBipartite", "org.jgrapht.experimental", "GraphTests", "public static <V, E> boolean isBipartite(Graph<V, E> g)" ], [ "union", "org.jgrapht.util", "FibonacciHeap", "public static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)" ], [ "uncheckedCast", "org.jgrapht.util", "TypeUtil", "public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)" ], [ "factorial", "org.jgrapht.util", "MathUtil", "public static long factorial(int N)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleGraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedPseudograph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Pseudograph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedMultigraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedPseudograph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "Multigraph", "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DefaultDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedPseudograph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleWeightedGraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedWeightedGraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "WeightedMultigraph", "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "DirectedWeightedMultigraph", "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)" ], [ "builder", "org.jgrapht.graph", "SimpleDirectedGraph", "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)" ], [ "addEdge", "org.jgrapht", "Graphs", "public static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)" ], [ "addEdgeWithVertices", "org.jgrapht", "Graphs", "public static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)" ], [ "addGraph", "org.jgrapht", "Graphs", "public static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)" ], [ "addAllEdges", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)" ], [ "addAllVertices", "org.jgrapht", "Graphs", "public static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)" ], [ "neighborListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex)" ], [ "predecessorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "successorListOf", "org.jgrapht", "Graphs", "public static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex)" ], [ "undirectedGraph", "org.jgrapht", "Graphs", "public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)" ], [ "testIncidence", "org.jgrapht", "Graphs", "public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)" ], [ "getOppositeVertex", "org.jgrapht", "Graphs", "public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)" ], [ "getPathVertexList", "org.jgrapht", "Graphs", "public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)" ], [ "range", "org.jgrapht.generate", "SimpleWeightedGraphMatrixGenerator", "public static int[] range(final int from, final int to)" ], [ "createGraphSpecifics", "org.jgrapht.traverse", "CrossComponentIterator", "static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)" ], [ "findGreedyChromaticNumber", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)" ], [ "findGreedyColoredGroups", "org.jgrapht.alg", "ChromaticNumber", "public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)" ], [ "findPathBetween", "org.jgrapht.alg", "BellmanFordShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "findPathBetween", "org.jgrapht.alg", "DijkstraShortestPath", "public static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)" ], [ "of", "org.jgrapht.alg.util", "Pair", "public static <A, B> Pair<A, B> of(A a, B b)" ], [ "isEulerian", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)" ], [ "getEulerianCircuitVertices", "org.jgrapht.alg", "EulerianCircuit", "public static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)" ], [ "getApproximateOptimalForCompleteGraph", "org.jgrapht.alg", "HamiltonianCycle", "public static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)" ], [ "find2ApproximationCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)" ], [ "findGreedyCover", "org.jgrapht.alg", "VertexCovers", "public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "BEST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int BEST_ORDER = 0;" ], [ "NATURAL_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int NATURAL_ORDER = 1;" ], [ "SMALLEST_DEGREE_LAST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;" ], [ "LARGEST_SATURATION_FIRST_ORDER", "org.jgrapht.experimental.alg.color", "GreedyColoring", "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;" ], [ "DEFAULT_EDGE_WEIGHT", "org.jgrapht", "WeightedGraph", "public static double DEFAULT_EDGE_WEIGHT = 1.0;" ], [ "HUB_VERTEX", "org.jgrapht.generate", "WheelGraphGenerator", "public static final String HUB_VERTEX = \"Hub Vertex\";" ], [ "CORNER_VERTEX", "org.jgrapht.generate", "GridGraphGenerator", "public static final String CORNER_VERTEX = \"Corner Vertex\";" ], [ "START_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String START_VERTEX = \"Start Vertex\";" ], [ "END_VERTEX", "org.jgrapht.generate", "LinearGraphGenerator", "public static final String END_VERTEX = \"End Vertex\";" ], [ "CENTER_VERTEX", "org.jgrapht.generate", "StarGraphGenerator", "public static final String CENTER_VERTEX = \"Center Vertex\";" ], [ "SENTINEL", "org.jgrapht.traverse", "DepthFirstIterator", "public static final Object SENTINEL = new Object();" ], [ "BEFORE_EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_ADDED = 21;" ], [ "BEFORE_EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int BEFORE_EDGE_REMOVED = 22;" ], [ "EDGE_ADDED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_ADDED = 23;" ], [ "EDGE_REMOVED", "org.jgrapht.event", "GraphEdgeChangeEvent", "public static final int EDGE_REMOVED = 24;" ], [ "CONNECTED_COMPONENT_STARTED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_STARTED = 31;" ], [ "CONNECTED_COMPONENT_FINISHED", "org.jgrapht.event", "ConnectedComponentTraversalEvent", "public static final int CONNECTED_COMPONENT_FINISHED = 32;" ], [ "BEFORE_VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_ADDED = 11;" ], [ "BEFORE_VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int BEFORE_VERTEX_REMOVED = 12;" ], [ "VERTEX_ADDED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_ADDED = 13;" ], [ "VERTEX_REMOVED", "org.jgrapht.event", "GraphVertexChangeEvent", "public static final int VERTEX_REMOVED = 14;" ], [ "NULL_NODE", "org.jgrapht.alg.isomorphism", "VF2State", "public static final int NULL_NODE = -1;" ], [ "DEBUG", "org.jgrapht.alg.isomorphism", "VF2State", "protected static final boolean DEBUG = false;" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg", "EdmondsKarpMaximumFlow", "public static final double DEFAULT_EPSILON = 0.000000001;" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveClosure", "public static final TransitiveClosure INSTANCE = new TransitiveClosure();" ], [ "INSTANCE", "org.jgrapht.alg", "TransitiveReduction", "public static final TransitiveReduction INSTANCE = new TransitiveReduction();" ], [ "NEGATIVE_UNDIRECTED_EDGE", "org.jgrapht.alg", "BellmanFordIterator", "protected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";" ], [ "DEFAULT_EPSILON", "org.jgrapht.alg.flow", "MaximumFlowAlgorithmBase", "public static final double DEFAULT_EPSILON = 1e-9;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "numVertices", "", "int" ], [ "numEdges", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]