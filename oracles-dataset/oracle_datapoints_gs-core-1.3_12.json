[
    {
        "id": 3784,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream",
        "className": "SourceBase",
        "javadocTag": "@param nodeId The node identifier.",
        "methodJavadoc": "    /**\n\t * Send a \"node attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */",
        "methodSourceCode": "public void sendNodeAttributeChanged(String sourceId, String nodeId, String attribute, Object oldValue, Object newValue){\n    sendAttributeChangedEvent(sourceId, nodeId, ElementType.NODE, attribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n}",
        "classJavadoc": "/**\n * Base implementation of an input that provide basic sink handling.\n * \n * <p>\n * This implementation can register a set of graph sinks (or separate sets of\n * attributes or elements sinks) and provides protected methods to easily\n * broadcast events to all the sinks (beginning with \"send\").\n * </p>\n * \n * <p>\n * Each time you want to produce an event toward all registered sinks, you call\n * one of the \"send*\" methods with correct parameters. The parameters of the\n * \"send*\" methods maps to the usual GraphStream events.\n * </p>\n * \n * <p>\n * This class is \"reentrant\". This means that if a send*() method is called\n * during the execution of another or the same send*() method, the event is\n * deferred until the first send*() method is finished. This avoid recursive\n * loops if a sink modifies the input during event handling.\n * </p>\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.graphstream.graph.implementations.AbstractElement.AttributeChangeEvent;\nimport org.graphstream.stream.sync.SourceTime;\n\n/**\n * Base implementation of an input that provide basic sink handling.\n * \n * <p>\n * This implementation can register a set of graph sinks (or separate sets of\n * attributes or elements sinks) and provides protected methods to easily\n * broadcast events to all the sinks (beginning with \"send\").\n * </p>\n * \n * <p>\n * Each time you want to produce an event toward all registered sinks, you call\n * one of the \"send*\" methods with correct parameters. The parameters of the\n * \"send*\" methods maps to the usual GraphStream events.\n * </p>\n * \n * <p>\n * This class is \"reentrant\". This means that if a send*() method is called\n * during the execution of another or the same send*() method, the event is\n * deferred until the first send*() method is finished. This avoid recursive\n * loops if a sink modifies the input during event handling.\n * </p>\n */\npublic abstract class SourceBase implements Source {\n\t// Attribute\n\n\tpublic enum ElementType {\n\t\tNODE, EDGE, GRAPH\n\t};\n\n\t/**\n\t * Set of graph attributes sinks.\n\t */\n\tprotected ArrayList<AttributeSink> attrSinks = new ArrayList<AttributeSink>();\n\n\t/**\n\t * Set of graph elements sinks.\n\t */\n\tprotected ArrayList<ElementSink> eltsSinks = new ArrayList<ElementSink>();\n\n\t/**\n\t * A queue that allow the management of events (nodes/edge\n\t * add/delete/change) in the right order.\n\t */\n\tprotected LinkedList<GraphEvent> eventQueue = new LinkedList<GraphEvent>();\n\n\t/**\n\t * A boolean that indicates whether or not an Sink event is being sent\n\t * during another one.\n\t */\n\tprotected boolean eventProcessing = false;\n\n\t/**\n\t * Id of this source.\n\t */\n\tprotected String sourceId;\n\t\n\t/**\n\t * Time of this source.\n\t */\n\tprotected SourceTime sourceTime;\n\n\t// Construction\n\n\tprotected SourceBase() {\n\t\tthis(String.format(\"sourceOnThread#%d_%d\", Thread.currentThread()\n\t\t\t\t.getId(), System.currentTimeMillis()\n\t\t\t\t+ ((int) (Math.random() * 1000))));\n\t}\n\n\tprotected SourceBase(String sourceId) {\n\t\tthis.sourceId = sourceId;\n\t\tthis.sourceTime = new SourceTime(sourceId);\n\t}\n\n\t// Access\n\n\tpublic Iterable<AttributeSink> attributeSinks() {\n\t\treturn attrSinks;\n\t}\n\n\tpublic Iterable<ElementSink> elementSinks() {\n\t\treturn eltsSinks;\n\t}\n\n\t// Command\n\n\tpublic void addSink(Sink sink) {\n\t\taddAttributeSink(sink);\n\t\taddElementSink(sink);\n\t}\n\n\tpublic void addAttributeSink(AttributeSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tattrSinks.add(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AddToListEvent<AttributeSink>(attrSinks, sink));\n\t\t}\n\t}\n\n\tpublic void addElementSink(ElementSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\teltsSinks.add(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AddToListEvent<ElementSink>(eltsSinks, sink));\n\t\t}\n\t}\n\n\tpublic void clearSinks() {\n\t\tclearElementSinks();\n\t\tclearAttributeSinks();\n\t}\n\n\tpublic void clearElementSinks() {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\teltsSinks.clear();\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new ClearListEvent<ElementSink>(eltsSinks));\n\t\t}\n\t}\n\n\tpublic void clearAttributeSinks() {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tattrSinks.clear();\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new ClearListEvent<AttributeSink>(attrSinks));\n\t\t}\n\t}\n\n\tpublic void removeSink(Sink sink) {\n\t\tremoveAttributeSink(sink);\n\t\tremoveElementSink(sink);\n\t}\n\n\tpublic void removeAttributeSink(AttributeSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tattrSinks.remove(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new RemoveFromListEvent<AttributeSink>(attrSinks,\n\t\t\t\t\tsink));\n\t\t}\n\t}\n\n\tpublic void removeElementSink(ElementSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\teltsSinks.remove(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue\n\t\t\t\t\t.add(new RemoveFromListEvent<ElementSink>(eltsSinks, sink));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"graph cleared\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t */\n\tpublic void sendGraphCleared(String sourceId) {\n\t\tsendGraphCleared(sourceId, sourceTime.newEvent());\n\t}\n\n\t/**\n\t * Send a \"graph cleared\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t */\n\tpublic void sendGraphCleared(String sourceId, long timeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).graphCleared(sourceId, timeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new BeforeGraphClearEvent(sourceId, timeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"step begins\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param step\n\t *            The step time stamp.\n\t */\n\tpublic void sendStepBegins(String sourceId, double step) {\n\t\tsendStepBegins(sourceId, sourceTime.newEvent(), step);\n\t}\n\n\t/**\n\t * Send a \"step begins\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param timeId\n\t * @param step\n\t *            The step time stamp.\n\t */\n\tpublic void sendStepBegins(String sourceId, long timeId, double step) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).stepBegins(sourceId, timeId, step);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new StepBeginsEvent(sourceId, timeId, step));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"node added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeAdded(String sourceId, String nodeId) {\n\t\tsendNodeAdded(sourceId, sourceTime.newEvent(), nodeId);\n\t}\n\n\t/**\n\t * Send a \"node added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeAdded(String sourceId, long timeId, String nodeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeAdded(sourceId, timeId, nodeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AfterNodeAddEvent(sourceId, timeId, nodeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"node removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeRemoved(String sourceId, String nodeId) {\n\t\tsendNodeRemoved(sourceId, sourceTime.newEvent(), nodeId);\n\t}\n\n\t/**\n\t * Send a \"node removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeRemoved(String sourceId, long timeId, String nodeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeRemoved(sourceId, timeId, nodeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new BeforeNodeRemoveEvent(sourceId, timeId, nodeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send an \"edge added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param fromNodeId\n\t *            The edge start node.\n\t * @param toNodeId\n\t *            The edge end node.\n\t * @param directed\n\t *            Is the edge directed?.\n\t */\n\tpublic void sendEdgeAdded(String sourceId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\tsendEdgeAdded(sourceId, sourceTime.newEvent(), edgeId, fromNodeId,\n\t\t\t\ttoNodeId, directed);\n\t}\n\n\t/**\n\t * Send an \"edge added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param fromNodeId\n\t *            The edge start node.\n\t * @param toNodeId\n\t *            The edge end node.\n\t * @param directed\n\t *            Is the edge directed?.\n\t */\n\tpublic void sendEdgeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeAdded(sourceId, timeId, edgeId,\n\t\t\t\t\t\tfromNodeId, toNodeId, directed);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AfterEdgeAddEvent(sourceId, timeId, edgeId,\n\t\t\t\t\tfromNodeId, toNodeId, directed));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"edge removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t */\n\tpublic void sendEdgeRemoved(String sourceId, String edgeId) {\n\t\tsendEdgeRemoved(sourceId, sourceTime.newEvent(), edgeId);\n\t}\n\n\t/**\n\t * Send a \"edge removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t */\n\tpublic void sendEdgeRemoved(String sourceId, long timeId, String edgeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeRemoved(sourceId, timeId, edgeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new BeforeEdgeRemoveEvent(sourceId, timeId, edgeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"edge attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendEdgeAttributeAdded(String sourceId, String edgeId,\n\t\t\tString attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"edge attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendEdgeAttributeAdded(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"edge attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The old attribute value.\n\t * @param newValue\n\t *            The new attribute value.\n\t */\n\tpublic void sendEdgeAttributeChanged(String sourceId, String edgeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"edge attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The old attribute value.\n\t * @param newValue\n\t *            The new attribute value.\n\t */\n\tpublic void sendEdgeAttributeChanged(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"edge attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendEdgeAttributeRemoved(String sourceId, String edgeId,\n\t\t\tString attribute) {\n\t\tsendAttributeChangedEvent(sourceId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"edge attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendEdgeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"graph attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendGraphAttributeAdded(String sourceId, String attribute,\n\t\t\tObject value) {\n\t\tsendAttributeChangedEvent(sourceId, null, ElementType.GRAPH, attribute,\n\t\t\t\tAttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"graph attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendGraphAttributeAdded(String sourceId, long timeId,\n\t\t\tString attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, null, ElementType.GRAPH,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"graph attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendGraphAttributeChanged(String sourceId, String attribute,\n\t\t\tObject oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, null, ElementType.GRAPH, attribute,\n\t\t\t\tAttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"graph attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendGraphAttributeChanged(String sourceId, long timeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, null, ElementType.GRAPH,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"graph attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendGraphAttributeRemoved(String sourceId, String attribute) {\n\t\tsendAttributeChangedEvent(sourceId, null, ElementType.GRAPH, attribute,\n\t\t\t\tAttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"graph attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendGraphAttributeRemoved(String sourceId, long timeId,\n\t\t\tString attribute) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, null, ElementType.GRAPH,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"node attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendNodeAttributeAdded(String sourceId, String nodeId,\n\t\t\tString attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"node attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendNodeAttributeAdded(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"node attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendNodeAttributeChanged(String sourceId, String nodeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"node attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendNodeAttributeChanged(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"node attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendNodeAttributeRemoved(String sourceId, String nodeId,\n\t\t\tString attribute) {\n\t\tsendAttributeChangedEvent(sourceId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"node attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendNodeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a add/change/remove attribute event on an element. This method is a\n\t * generic way of notifying of an attribute change and is equivalent to\n\t * individual send*Attribute*() methods.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param eltId\n\t *            The changed element identifier.\n\t * @param eltType\n\t *            The changed element type.\n\t * @param attribute\n\t *            The changed attribute.\n\t * @param event\n\t *            The add/change/remove action.\n\t * @param oldValue\n\t *            The old attribute value (null if the attribute is removed or\n\t *            added).\n\t * @param newValue\n\t *            The new attribute value (null if removed).\n\t */\n\tpublic void sendAttributeChangedEvent(String sourceId, String eltId,\n\t\t\tElementType eltType, String attribute, AttributeChangeEvent event,\n\t\t\tObject oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, sourceTime.newEvent(), eltId,\n\t\t\t\teltType, attribute, event, oldValue, newValue);\n\t}\n\n\tpublic void sendAttributeChangedEvent(String sourceId, long timeId,\n\t\t\tString eltId, ElementType eltType, String attribute,\n\t\t\tAttributeChangeEvent event, Object oldValue, Object newValue) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tif (event == AttributeChangeEvent.ADD) {\n\t\t\t\tif (eltType == ElementType.NODE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t} else if (eltType == ElementType.EDGE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\tattribute, newValue);\n\t\t\t\t}\n\t\t\t} else if (event == AttributeChangeEvent.REMOVE) {\n\t\t\t\tif (eltType == ElementType.NODE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t} else if (eltType == ElementType.EDGE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeRemoved(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (eltType == ElementType.NODE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t} else if (eltType == ElementType.EDGE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeChanged(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute, oldValue, newValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AttributeChangedEvent(sourceId, timeId, eltId,\n\t\t\t\t\teltType, attribute, event, oldValue, newValue));\n\t\t}\n\t}\n\n\t// Deferred event management\n\n\t/**\n\t * If in \"event processing mode\", ensure all pending events are processed.\n\t */\n\tprotected void manageEvents() {\n\t\tif (eventProcessing) {\n\t\t\twhile (!eventQueue.isEmpty())\n\t\t\t\teventQueue.remove().trigger();\n\t\t}\n\t}\n\n\t// Events Management\n\n\t/**\n\t * Interface that provide general purpose classification for evens involved\n\t * in graph modifications\n\t */\n\tabstract class GraphEvent {\n\t\tString sourceId;\n\t\tlong timeId;\n\n\t\tGraphEvent(String sourceId, long timeId) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tthis.timeId = timeId;\n\t\t}\n\n\t\tabstract void trigger();\n\t}\n\n\tclass AfterEdgeAddEvent extends GraphEvent {\n\t\tString edgeId;\n\t\tString fromNodeId;\n\t\tString toNodeId;\n\t\tboolean directed;\n\n\t\tAfterEdgeAddEvent(String sourceId, long timeId, String edgeId,\n\t\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.edgeId = edgeId;\n\t\t\tthis.fromNodeId = fromNodeId;\n\t\t\tthis.toNodeId = toNodeId;\n\t\t\tthis.directed = directed;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeAdded(sourceId, timeId, edgeId,\n\t\t\t\t\t\tfromNodeId, toNodeId, directed);\n\t\t}\n\t}\n\n\tclass BeforeEdgeRemoveEvent extends GraphEvent {\n\t\tString edgeId;\n\n\t\tBeforeEdgeRemoveEvent(String sourceId, long timeId, String edgeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.edgeId = edgeId;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeRemoved(sourceId, timeId, edgeId);\n\t\t}\n\t}\n\n\tclass AfterNodeAddEvent extends GraphEvent {\n\t\tString nodeId;\n\n\t\tAfterNodeAddEvent(String sourceId, long timeId, String nodeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.nodeId = nodeId;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeAdded(sourceId, timeId, nodeId);\n\t\t}\n\t}\n\n\tclass BeforeNodeRemoveEvent extends GraphEvent {\n\t\tString nodeId;\n\n\t\tBeforeNodeRemoveEvent(String sourceId, long timeId, String nodeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.nodeId = nodeId;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeRemoved(sourceId, timeId, nodeId);\n\t\t}\n\t}\n\n\tclass BeforeGraphClearEvent extends GraphEvent {\n\t\tBeforeGraphClearEvent(String sourceId, long timeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).graphCleared(sourceId, timeId);\n\t\t}\n\t}\n\n\tclass StepBeginsEvent extends GraphEvent {\n\t\tdouble step;\n\n\t\tStepBeginsEvent(String sourceId, long timeId, double step) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.step = step;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).stepBegins(sourceId, timeId, step);\n\t\t}\n\t}\n\n\tclass AttributeChangedEvent extends GraphEvent {\n\t\tElementType eltType;\n\n\t\tString eltId;\n\n\t\tString attribute;\n\n\t\tAttributeChangeEvent event;\n\n\t\tObject oldValue;\n\n\t\tObject newValue;\n\n\t\tAttributeChangedEvent(String sourceId, long timeId, String eltId,\n\t\t\t\tElementType eltType, String attribute,\n\t\t\t\tAttributeChangeEvent event, Object oldValue, Object newValue) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.eltType = eltType;\n\t\t\tthis.eltId = eltId;\n\t\t\tthis.attribute = attribute;\n\t\t\tthis.event = event;\n\t\t\tthis.oldValue = oldValue;\n\t\t\tthis.newValue = newValue;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tswitch (event) {\n\t\t\tcase ADD:\n\t\t\t\tswitch (eltType) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\tattribute, newValue);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase REMOVE:\n\t\t\t\tswitch (eltType) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeRemoved(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tswitch (eltType) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeChanged(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute, oldValue, newValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass AddToListEvent<T> extends GraphEvent {\n\t\tList<T> l;\n\t\tT obj;\n\n\t\tAddToListEvent(List<T> l, T obj) {\n\t\t\tsuper(null, -1);\n\t\t\tthis.l = l;\n\t\t\tthis.obj = obj;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tl.add(obj);\n\t\t}\n\t}\n\n\tclass RemoveFromListEvent<T> extends GraphEvent {\n\t\tList<T> l;\n\t\tT obj;\n\n\t\tRemoveFromListEvent(List<T> l, T obj) {\n\t\t\tsuper(null, -1);\n\t\t\tthis.l = l;\n\t\t\tthis.obj = obj;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tl.remove(obj);\n\t\t}\n\t}\n\n\tclass ClearListEvent<T> extends GraphEvent {\n\t\tList<T> l;\n\n\t\tClearListEvent(List<T> l) {\n\t\t\tsuper(null, -1);\n\t\t\tthis.l = l;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tl.clear();\n\t\t}\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "\"node attribute changed\"",
                "String"
            ]
        ],
        "tokensMethodArguments": [
            [
                "sourceId",
                "java.lang",
                "String"
            ],
            [
                "nodeId",
                "java.lang",
                "String"
            ],
            [
                "attribute",
                "java.lang",
                "String"
            ],
            [
                "oldValue",
                "java.lang",
                "Object"
            ],
            [
                "newValue",
                "java.lang",
                "Object"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "attributeSinks",
                "org.graphstream.stream",
                "SourceBase",
                "// Access\npublic Iterable<AttributeSink> attributeSinks() {\n    return attrSinks;\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "elementSinks",
                "org.graphstream.stream",
                "SourceBase",
                "public Iterable<ElementSink> elementSinks() {\n    return eltsSinks;\n}"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "attrSinks",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Set of graph attributes sinks.\n */\nprotected ArrayList<AttributeSink> attrSinks = new ArrayList<AttributeSink>();"
            ],
            [
                "eltsSinks",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Set of graph elements sinks.\n */\nprotected ArrayList<ElementSink> eltsSinks = new ArrayList<ElementSink>();"
            ],
            [
                "eventQueue",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * A queue that allow the management of events (nodes/edge\n * add/delete/change) in the right order.\n */\nprotected LinkedList<GraphEvent> eventQueue = new LinkedList<GraphEvent>();"
            ],
            [
                "eventProcessing",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * A boolean that indicates whether or not an Sink event is being sent\n * during another one.\n */\nprotected boolean eventProcessing = false;"
            ],
            [
                "sourceId",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Id of this source.\n */\nprotected String sourceId;"
            ],
            [
                "sourceTime",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Time of this source.\n */\nprotected SourceTime sourceTime;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3802,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream",
        "className": "SourceBase",
        "javadocTag": "@param eltId The changed element identifier.",
        "methodJavadoc": "    /**\n\t * Send a add/change/remove attribute event on an element. This method is a\n\t * generic way of notifying of an attribute change and is equivalent to\n\t * individual send*Attribute*() methods.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param eltId\n\t *            The changed element identifier.\n\t * @param eltType\n\t *            The changed element type.\n\t * @param attribute\n\t *            The changed attribute.\n\t * @param event\n\t *            The add/change/remove action.\n\t * @param oldValue\n\t *            The old attribute value (null if the attribute is removed or\n\t *            added).\n\t * @param newValue\n\t *            The new attribute value (null if removed).\n\t */",
        "methodSourceCode": "public void sendAttributeChangedEvent(String sourceId, String eltId, ElementType eltType, String attribute, AttributeChangeEvent event, Object oldValue, Object newValue){\n    sendAttributeChangedEvent(sourceId, sourceTime.newEvent(), eltId, eltType, attribute, event, oldValue, newValue);\n}",
        "classJavadoc": "/**\n * Base implementation of an input that provide basic sink handling.\n * \n * <p>\n * This implementation can register a set of graph sinks (or separate sets of\n * attributes or elements sinks) and provides protected methods to easily\n * broadcast events to all the sinks (beginning with \"send\").\n * </p>\n * \n * <p>\n * Each time you want to produce an event toward all registered sinks, you call\n * one of the \"send*\" methods with correct parameters. The parameters of the\n * \"send*\" methods maps to the usual GraphStream events.\n * </p>\n * \n * <p>\n * This class is \"reentrant\". This means that if a send*() method is called\n * during the execution of another or the same send*() method, the event is\n * deferred until the first send*() method is finished. This avoid recursive\n * loops if a sink modifies the input during event handling.\n * </p>\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.graphstream.graph.implementations.AbstractElement.AttributeChangeEvent;\nimport org.graphstream.stream.sync.SourceTime;\n\n/**\n * Base implementation of an input that provide basic sink handling.\n * \n * <p>\n * This implementation can register a set of graph sinks (or separate sets of\n * attributes or elements sinks) and provides protected methods to easily\n * broadcast events to all the sinks (beginning with \"send\").\n * </p>\n * \n * <p>\n * Each time you want to produce an event toward all registered sinks, you call\n * one of the \"send*\" methods with correct parameters. The parameters of the\n * \"send*\" methods maps to the usual GraphStream events.\n * </p>\n * \n * <p>\n * This class is \"reentrant\". This means that if a send*() method is called\n * during the execution of another or the same send*() method, the event is\n * deferred until the first send*() method is finished. This avoid recursive\n * loops if a sink modifies the input during event handling.\n * </p>\n */\npublic abstract class SourceBase implements Source {\n\t// Attribute\n\n\tpublic enum ElementType {\n\t\tNODE, EDGE, GRAPH\n\t};\n\n\t/**\n\t * Set of graph attributes sinks.\n\t */\n\tprotected ArrayList<AttributeSink> attrSinks = new ArrayList<AttributeSink>();\n\n\t/**\n\t * Set of graph elements sinks.\n\t */\n\tprotected ArrayList<ElementSink> eltsSinks = new ArrayList<ElementSink>();\n\n\t/**\n\t * A queue that allow the management of events (nodes/edge\n\t * add/delete/change) in the right order.\n\t */\n\tprotected LinkedList<GraphEvent> eventQueue = new LinkedList<GraphEvent>();\n\n\t/**\n\t * A boolean that indicates whether or not an Sink event is being sent\n\t * during another one.\n\t */\n\tprotected boolean eventProcessing = false;\n\n\t/**\n\t * Id of this source.\n\t */\n\tprotected String sourceId;\n\t\n\t/**\n\t * Time of this source.\n\t */\n\tprotected SourceTime sourceTime;\n\n\t// Construction\n\n\tprotected SourceBase() {\n\t\tthis(String.format(\"sourceOnThread#%d_%d\", Thread.currentThread()\n\t\t\t\t.getId(), System.currentTimeMillis()\n\t\t\t\t+ ((int) (Math.random() * 1000))));\n\t}\n\n\tprotected SourceBase(String sourceId) {\n\t\tthis.sourceId = sourceId;\n\t\tthis.sourceTime = new SourceTime(sourceId);\n\t}\n\n\t// Access\n\n\tpublic Iterable<AttributeSink> attributeSinks() {\n\t\treturn attrSinks;\n\t}\n\n\tpublic Iterable<ElementSink> elementSinks() {\n\t\treturn eltsSinks;\n\t}\n\n\t// Command\n\n\tpublic void addSink(Sink sink) {\n\t\taddAttributeSink(sink);\n\t\taddElementSink(sink);\n\t}\n\n\tpublic void addAttributeSink(AttributeSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tattrSinks.add(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AddToListEvent<AttributeSink>(attrSinks, sink));\n\t\t}\n\t}\n\n\tpublic void addElementSink(ElementSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\teltsSinks.add(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AddToListEvent<ElementSink>(eltsSinks, sink));\n\t\t}\n\t}\n\n\tpublic void clearSinks() {\n\t\tclearElementSinks();\n\t\tclearAttributeSinks();\n\t}\n\n\tpublic void clearElementSinks() {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\teltsSinks.clear();\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new ClearListEvent<ElementSink>(eltsSinks));\n\t\t}\n\t}\n\n\tpublic void clearAttributeSinks() {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tattrSinks.clear();\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new ClearListEvent<AttributeSink>(attrSinks));\n\t\t}\n\t}\n\n\tpublic void removeSink(Sink sink) {\n\t\tremoveAttributeSink(sink);\n\t\tremoveElementSink(sink);\n\t}\n\n\tpublic void removeAttributeSink(AttributeSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tattrSinks.remove(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new RemoveFromListEvent<AttributeSink>(attrSinks,\n\t\t\t\t\tsink));\n\t\t}\n\t}\n\n\tpublic void removeElementSink(ElementSink sink) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\teltsSinks.remove(sink);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue\n\t\t\t\t\t.add(new RemoveFromListEvent<ElementSink>(eltsSinks, sink));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"graph cleared\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t */\n\tpublic void sendGraphCleared(String sourceId) {\n\t\tsendGraphCleared(sourceId, sourceTime.newEvent());\n\t}\n\n\t/**\n\t * Send a \"graph cleared\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t */\n\tpublic void sendGraphCleared(String sourceId, long timeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).graphCleared(sourceId, timeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new BeforeGraphClearEvent(sourceId, timeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"step begins\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param step\n\t *            The step time stamp.\n\t */\n\tpublic void sendStepBegins(String sourceId, double step) {\n\t\tsendStepBegins(sourceId, sourceTime.newEvent(), step);\n\t}\n\n\t/**\n\t * Send a \"step begins\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param timeId\n\t * @param step\n\t *            The step time stamp.\n\t */\n\tpublic void sendStepBegins(String sourceId, long timeId, double step) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).stepBegins(sourceId, timeId, step);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new StepBeginsEvent(sourceId, timeId, step));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"node added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeAdded(String sourceId, String nodeId) {\n\t\tsendNodeAdded(sourceId, sourceTime.newEvent(), nodeId);\n\t}\n\n\t/**\n\t * Send a \"node added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeAdded(String sourceId, long timeId, String nodeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeAdded(sourceId, timeId, nodeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AfterNodeAddEvent(sourceId, timeId, nodeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"node removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeRemoved(String sourceId, String nodeId) {\n\t\tsendNodeRemoved(sourceId, sourceTime.newEvent(), nodeId);\n\t}\n\n\t/**\n\t * Send a \"node removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The graph identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t */\n\tpublic void sendNodeRemoved(String sourceId, long timeId, String nodeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeRemoved(sourceId, timeId, nodeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new BeforeNodeRemoveEvent(sourceId, timeId, nodeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send an \"edge added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param fromNodeId\n\t *            The edge start node.\n\t * @param toNodeId\n\t *            The edge end node.\n\t * @param directed\n\t *            Is the edge directed?.\n\t */\n\tpublic void sendEdgeAdded(String sourceId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\tsendEdgeAdded(sourceId, sourceTime.newEvent(), edgeId, fromNodeId,\n\t\t\t\ttoNodeId, directed);\n\t}\n\n\t/**\n\t * Send an \"edge added\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param fromNodeId\n\t *            The edge start node.\n\t * @param toNodeId\n\t *            The edge end node.\n\t * @param directed\n\t *            Is the edge directed?.\n\t */\n\tpublic void sendEdgeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeAdded(sourceId, timeId, edgeId,\n\t\t\t\t\t\tfromNodeId, toNodeId, directed);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AfterEdgeAddEvent(sourceId, timeId, edgeId,\n\t\t\t\t\tfromNodeId, toNodeId, directed));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"edge removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t */\n\tpublic void sendEdgeRemoved(String sourceId, String edgeId) {\n\t\tsendEdgeRemoved(sourceId, sourceTime.newEvent(), edgeId);\n\t}\n\n\t/**\n\t * Send a \"edge removed\" event to all element sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t */\n\tpublic void sendEdgeRemoved(String sourceId, long timeId, String edgeId) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeRemoved(sourceId, timeId, edgeId);\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new BeforeEdgeRemoveEvent(sourceId, timeId, edgeId));\n\t\t}\n\t}\n\n\t/**\n\t * Send a \"edge attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendEdgeAttributeAdded(String sourceId, String edgeId,\n\t\t\tString attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"edge attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendEdgeAttributeAdded(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"edge attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The old attribute value.\n\t * @param newValue\n\t *            The new attribute value.\n\t */\n\tpublic void sendEdgeAttributeChanged(String sourceId, String edgeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"edge attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The old attribute value.\n\t * @param newValue\n\t *            The new attribute value.\n\t */\n\tpublic void sendEdgeAttributeChanged(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"edge attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendEdgeAttributeRemoved(String sourceId, String edgeId,\n\t\t\tString attribute) {\n\t\tsendAttributeChangedEvent(sourceId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"edge attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param edgeId\n\t *            The edge identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendEdgeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, edgeId, ElementType.EDGE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"graph attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendGraphAttributeAdded(String sourceId, String attribute,\n\t\t\tObject value) {\n\t\tsendAttributeChangedEvent(sourceId, null, ElementType.GRAPH, attribute,\n\t\t\t\tAttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"graph attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendGraphAttributeAdded(String sourceId, long timeId,\n\t\t\tString attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, null, ElementType.GRAPH,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"graph attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendGraphAttributeChanged(String sourceId, String attribute,\n\t\t\tObject oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, null, ElementType.GRAPH, attribute,\n\t\t\t\tAttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"graph attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendGraphAttributeChanged(String sourceId, long timeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, null, ElementType.GRAPH,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"graph attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendGraphAttributeRemoved(String sourceId, String attribute) {\n\t\tsendAttributeChangedEvent(sourceId, null, ElementType.GRAPH, attribute,\n\t\t\t\tAttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"graph attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendGraphAttributeRemoved(String sourceId, long timeId,\n\t\t\tString attribute) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, null, ElementType.GRAPH,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"node attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendNodeAttributeAdded(String sourceId, String nodeId,\n\t\t\tString attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"node attribute added\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param value\n\t *            The attribute value.\n\t */\n\tpublic void sendNodeAttributeAdded(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object value) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.ADD, null, value);\n\t}\n\n\t/**\n\t * Send a \"node attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendNodeAttributeChanged(String sourceId, String nodeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"node attribute changed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t * @param oldValue\n\t *            The attribute old value.\n\t * @param newValue\n\t *            The attribute new value.\n\t */\n\tpublic void sendNodeAttributeChanged(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.CHANGE, oldValue, newValue);\n\t}\n\n\t/**\n\t * Send a \"node attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendNodeAttributeRemoved(String sourceId, String nodeId,\n\t\t\tString attribute) {\n\t\tsendAttributeChangedEvent(sourceId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a \"node attribute removed\" event to all attribute sinks.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param timeId\n\t * @param nodeId\n\t *            The node identifier.\n\t * @param attribute\n\t *            The attribute name.\n\t */\n\tpublic void sendNodeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute) {\n\t\tsendAttributeChangedEvent(sourceId, timeId, nodeId, ElementType.NODE,\n\t\t\t\tattribute, AttributeChangeEvent.REMOVE, null, null);\n\t}\n\n\t/**\n\t * Send a add/change/remove attribute event on an element. This method is a\n\t * generic way of notifying of an attribute change and is equivalent to\n\t * individual send*Attribute*() methods.\n\t * \n\t * @param sourceId\n\t *            The source identifier.\n\t * @param eltId\n\t *            The changed element identifier.\n\t * @param eltType\n\t *            The changed element type.\n\t * @param attribute\n\t *            The changed attribute.\n\t * @param event\n\t *            The add/change/remove action.\n\t * @param oldValue\n\t *            The old attribute value (null if the attribute is removed or\n\t *            added).\n\t * @param newValue\n\t *            The new attribute value (null if removed).\n\t */\n\tpublic void sendAttributeChangedEvent(String sourceId, String eltId,\n\t\t\tElementType eltType, String attribute, AttributeChangeEvent event,\n\t\t\tObject oldValue, Object newValue) {\n\t\tsendAttributeChangedEvent(sourceId, sourceTime.newEvent(), eltId,\n\t\t\t\teltType, attribute, event, oldValue, newValue);\n\t}\n\n\tpublic void sendAttributeChangedEvent(String sourceId, long timeId,\n\t\t\tString eltId, ElementType eltType, String attribute,\n\t\t\tAttributeChangeEvent event, Object oldValue, Object newValue) {\n\t\tif (!eventProcessing) {\n\t\t\teventProcessing = true;\n\t\t\tmanageEvents();\n\n\t\t\tif (event == AttributeChangeEvent.ADD) {\n\t\t\t\tif (eltType == ElementType.NODE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t} else if (eltType == ElementType.EDGE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\tattribute, newValue);\n\t\t\t\t}\n\t\t\t} else if (event == AttributeChangeEvent.REMOVE) {\n\t\t\t\tif (eltType == ElementType.NODE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t} else if (eltType == ElementType.EDGE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeRemoved(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (eltType == ElementType.NODE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t} else if (eltType == ElementType.EDGE) {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeChanged(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute, oldValue, newValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmanageEvents();\n\t\t\teventProcessing = false;\n\t\t} else {\n\t\t\teventQueue.add(new AttributeChangedEvent(sourceId, timeId, eltId,\n\t\t\t\t\teltType, attribute, event, oldValue, newValue));\n\t\t}\n\t}\n\n\t// Deferred event management\n\n\t/**\n\t * If in \"event processing mode\", ensure all pending events are processed.\n\t */\n\tprotected void manageEvents() {\n\t\tif (eventProcessing) {\n\t\t\twhile (!eventQueue.isEmpty())\n\t\t\t\teventQueue.remove().trigger();\n\t\t}\n\t}\n\n\t// Events Management\n\n\t/**\n\t * Interface that provide general purpose classification for evens involved\n\t * in graph modifications\n\t */\n\tabstract class GraphEvent {\n\t\tString sourceId;\n\t\tlong timeId;\n\n\t\tGraphEvent(String sourceId, long timeId) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tthis.timeId = timeId;\n\t\t}\n\n\t\tabstract void trigger();\n\t}\n\n\tclass AfterEdgeAddEvent extends GraphEvent {\n\t\tString edgeId;\n\t\tString fromNodeId;\n\t\tString toNodeId;\n\t\tboolean directed;\n\n\t\tAfterEdgeAddEvent(String sourceId, long timeId, String edgeId,\n\t\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.edgeId = edgeId;\n\t\t\tthis.fromNodeId = fromNodeId;\n\t\t\tthis.toNodeId = toNodeId;\n\t\t\tthis.directed = directed;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeAdded(sourceId, timeId, edgeId,\n\t\t\t\t\t\tfromNodeId, toNodeId, directed);\n\t\t}\n\t}\n\n\tclass BeforeEdgeRemoveEvent extends GraphEvent {\n\t\tString edgeId;\n\n\t\tBeforeEdgeRemoveEvent(String sourceId, long timeId, String edgeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.edgeId = edgeId;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).edgeRemoved(sourceId, timeId, edgeId);\n\t\t}\n\t}\n\n\tclass AfterNodeAddEvent extends GraphEvent {\n\t\tString nodeId;\n\n\t\tAfterNodeAddEvent(String sourceId, long timeId, String nodeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.nodeId = nodeId;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeAdded(sourceId, timeId, nodeId);\n\t\t}\n\t}\n\n\tclass BeforeNodeRemoveEvent extends GraphEvent {\n\t\tString nodeId;\n\n\t\tBeforeNodeRemoveEvent(String sourceId, long timeId, String nodeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.nodeId = nodeId;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).nodeRemoved(sourceId, timeId, nodeId);\n\t\t}\n\t}\n\n\tclass BeforeGraphClearEvent extends GraphEvent {\n\t\tBeforeGraphClearEvent(String sourceId, long timeId) {\n\t\t\tsuper(sourceId, timeId);\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).graphCleared(sourceId, timeId);\n\t\t}\n\t}\n\n\tclass StepBeginsEvent extends GraphEvent {\n\t\tdouble step;\n\n\t\tStepBeginsEvent(String sourceId, long timeId, double step) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.step = step;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tfor (int i = 0; i < eltsSinks.size(); i++)\n\t\t\t\teltsSinks.get(i).stepBegins(sourceId, timeId, step);\n\t\t}\n\t}\n\n\tclass AttributeChangedEvent extends GraphEvent {\n\t\tElementType eltType;\n\n\t\tString eltId;\n\n\t\tString attribute;\n\n\t\tAttributeChangeEvent event;\n\n\t\tObject oldValue;\n\n\t\tObject newValue;\n\n\t\tAttributeChangedEvent(String sourceId, long timeId, String eltId,\n\t\t\t\tElementType eltType, String attribute,\n\t\t\t\tAttributeChangeEvent event, Object oldValue, Object newValue) {\n\t\t\tsuper(sourceId, timeId);\n\t\t\tthis.eltType = eltType;\n\t\t\tthis.eltId = eltId;\n\t\t\tthis.attribute = attribute;\n\t\t\tthis.event = event;\n\t\t\tthis.oldValue = oldValue;\n\t\t\tthis.newValue = newValue;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tswitch (event) {\n\t\t\tcase ADD:\n\t\t\t\tswitch (eltType) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeAdded(sourceId, timeId,\n\t\t\t\t\t\t\t\tattribute, newValue);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase REMOVE:\n\t\t\t\tswitch (eltType) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeRemoved(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeRemoved(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tswitch (eltType) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).nodeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGE:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).edgeAttributeChanged(sourceId, timeId,\n\t\t\t\t\t\t\t\teltId, attribute, oldValue, newValue);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (int i = 0; i < attrSinks.size(); i++)\n\t\t\t\t\t\tattrSinks.get(i).graphAttributeChanged(sourceId,\n\t\t\t\t\t\t\t\ttimeId, attribute, oldValue, newValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass AddToListEvent<T> extends GraphEvent {\n\t\tList<T> l;\n\t\tT obj;\n\n\t\tAddToListEvent(List<T> l, T obj) {\n\t\t\tsuper(null, -1);\n\t\t\tthis.l = l;\n\t\t\tthis.obj = obj;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tl.add(obj);\n\t\t}\n\t}\n\n\tclass RemoveFromListEvent<T> extends GraphEvent {\n\t\tList<T> l;\n\t\tT obj;\n\n\t\tRemoveFromListEvent(List<T> l, T obj) {\n\t\t\tsuper(null, -1);\n\t\t\tthis.l = l;\n\t\t\tthis.obj = obj;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tl.remove(obj);\n\t\t}\n\t}\n\n\tclass ClearListEvent<T> extends GraphEvent {\n\t\tList<T> l;\n\n\t\tClearListEvent(List<T> l) {\n\t\t\tsuper(null, -1);\n\t\t\tthis.l = l;\n\t\t}\n\n\t\tvoid trigger() {\n\t\t\tl.clear();\n\t\t}\n\t}\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "sourceId",
                "java.lang",
                "String"
            ],
            [
                "eltId",
                "java.lang",
                "String"
            ],
            [
                "eltType",
                "org.graphstream.stream",
                "SourceBase.ElementType"
            ],
            [
                "attribute",
                "java.lang",
                "String"
            ],
            [
                "event",
                "org.graphstream.graph.implementations",
                "AbstractElement.AttributeChangeEvent"
            ],
            [
                "oldValue",
                "java.lang",
                "Object"
            ],
            [
                "newValue",
                "java.lang",
                "Object"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "elementSinks",
                "org.graphstream.stream",
                "SourceBase",
                "public Iterable<ElementSink> elementSinks() {\n    return eltsSinks;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "attributeSinks",
                "org.graphstream.stream",
                "SourceBase",
                "// Access\npublic Iterable<AttributeSink> attributeSinks() {\n    return attrSinks;\n}"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ],
            [
                "toString",
                "java.lang",
                "Enum",
                "public String toString()"
            ],
            [
                "getDeclaringClass",
                "java.lang",
                "Enum",
                "public final Class<E> getDeclaringClass()"
            ],
            [
                "hashCode",
                "java.lang",
                "Enum",
                "public final int hashCode()"
            ],
            [
                "name",
                "java.lang",
                "Enum",
                "public final String name()"
            ],
            [
                "clone",
                "java.lang",
                "Enum",
                "protected final Object clone() throws CloneNotSupportedException"
            ],
            [
                "compareTo",
                "java.lang",
                "Enum",
                "public final int compareTo(E arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "Enum",
                "public final Optional<Enum.EnumDesc<E>> describeConstable()"
            ],
            [
                "ordinal",
                "java.lang",
                "Enum",
                "public final int ordinal()"
            ],
            [
                "equals",
                "java.lang",
                "Enum",
                "public final boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "attrSinks",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Set of graph attributes sinks.\n */\nprotected ArrayList<AttributeSink> attrSinks = new ArrayList<AttributeSink>();"
            ],
            [
                "eltsSinks",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Set of graph elements sinks.\n */\nprotected ArrayList<ElementSink> eltsSinks = new ArrayList<ElementSink>();"
            ],
            [
                "eventQueue",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * A queue that allow the management of events (nodes/edge\n * add/delete/change) in the right order.\n */\nprotected LinkedList<GraphEvent> eventQueue = new LinkedList<GraphEvent>();"
            ],
            [
                "eventProcessing",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * A boolean that indicates whether or not an Sink event is being sent\n * during another one.\n */\nprotected boolean eventProcessing = false;"
            ],
            [
                "sourceId",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Id of this source.\n */\nprotected String sourceId;"
            ],
            [
                "sourceTime",
                "org.graphstream.stream",
                "SourceBase",
                "/**\n * Time of this source.\n */\nprotected SourceTime sourceTime;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3812,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream.netstream",
        "className": "NetStreamDecoder",
        "javadocTag": "@throws Exception If another Pipe is already registered at the given name.",
        "methodJavadoc": "    /**\n\t * Register a stream. All events with the given stream name will be directed\n\t * to it. The user has to ensure the ThreadProxyPipe can be safely written\n\t * to by the Receiver's thread.\n\t * \n\t * @param name\n\t *            Filter only message with this name to the given message box.\n\t * @param stream\n\t *            The ThreadProxyPipe to push the events to.\n\t * @throws Exception\n\t *             If another Pipe is already registered at the given name.\n\t */",
        "methodSourceCode": "public abstract void register(String name, ThreadProxyPipe stream) throws Exception;",
        "classJavadoc": "/**\n * \n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.graphstream.stream.thread.ThreadProxyPipe;\n\n/**\n * \n */\npublic interface NetStreamDecoder {\n\n\t/**\n\t * Gives the stream (a ThreadProxyPipe) identified with this name. If no\n\t * pipe exists under this name, a new one is created and returned\n\t * \n\t * @param name\n\t *            Identifier of the stream.\n\t * @return the identified pipe\n\t */\n\tpublic abstract ThreadProxyPipe getStream(String name);\n\n\t/**\n\t * Gives the default stream (a ThreadProxyPipe) identified with the name\n\t * \"default\". It is created if it does not exist.\n\t * \n\t * @return the default pipe\n\t */\n\n\tpublic abstract ThreadProxyPipe getDefaultStream();\n\n\t/**\n\t * Register a stream. All events with the given stream name will be directed\n\t * to it. The user has to ensure the ThreadProxyPipe can be safely written\n\t * to by the Receiver's thread.\n\t * \n\t * @param name\n\t *            Filter only message with this name to the given message box.\n\t * @param stream\n\t *            The ThreadProxyPipe to push the events to.\n\t * @throws Exception\n\t *             If another Pipe is already registered at the given name.\n\t */\n\tpublic abstract void register(String name, ThreadProxyPipe stream)\n\t\t\tthrows Exception;\n\n\t/**\n\t * Decode one message.\n\t */\n\tpublic abstract void decodeMessage(InputStream in) throws IOException;\n\n\t/**\n\t * Enable or disable debugging.\n\t */\n\tpublic void setDebugOn(boolean on);\n}",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "name",
                "java.lang",
                "String"
            ],
            [
                "stream",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getDefaultStream",
                "org.graphstream.stream.netstream",
                "NetStreamDecoder",
                "/**\n * Gives the default stream (a ThreadProxyPipe) identified with the name\n * \"default\". It is created if it does not exist.\n *\n * @return the default pipe\n */\npublic abstract ThreadProxyPipe getDefaultStream();"
            ],
            [
                "getStream",
                "org.graphstream.stream.netstream",
                "NetStreamDecoder",
                "/**\n * Gives the stream (a ThreadProxyPipe) identified with this name. If no\n * pipe exists under this name, a new one is created and returned\n *\n * @param name\n *            Identifier of the stream.\n * @return the identified pipe\n */\npublic abstract ThreadProxyPipe getStream(String name);"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ],
            [
                "hasPostRemaining",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "public boolean hasPostRemaining()"
            ],
            [
                "toString",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "public String toString()"
            ],
            [
                "maybeUnregister",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected boolean maybeUnregister()"
            ],
            [
                "attributeSinks",
                "org.graphstream.stream",
                "SourceBase",
                "public Iterable<AttributeSink> attributeSinks()"
            ],
            [
                "elementSinks",
                "org.graphstream.stream",
                "SourceBase",
                "public Iterable<ElementSink> elementSinks()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "id",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected String id;"
            ],
            [
                "from",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected String from;"
            ],
            [
                "events",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected LinkedList<ThreadProxyPipe.GraphEvents> events;"
            ],
            [
                "eventsData",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected LinkedList<Object[]> eventsData;"
            ],
            [
                "lock",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected ReentrantLock lock;"
            ],
            [
                "notEmpty",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected Condition notEmpty;"
            ],
            [
                "input",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected Source input;"
            ],
            [
                "unregisterWhenPossible",
                "org.graphstream.stream.thread",
                "ThreadProxyPipe",
                "protected boolean unregisterWhenPossible;"
            ],
            [
                "attrSinks",
                "org.graphstream.stream",
                "SourceBase",
                "protected ArrayList<AttributeSink> attrSinks;"
            ],
            [
                "eltsSinks",
                "org.graphstream.stream",
                "SourceBase",
                "protected ArrayList<ElementSink> eltsSinks;"
            ],
            [
                "eventQueue",
                "org.graphstream.stream",
                "SourceBase",
                "protected LinkedList<SourceBase.GraphEvent> eventQueue;"
            ],
            [
                "eventProcessing",
                "org.graphstream.stream",
                "SourceBase",
                "protected boolean eventProcessing;"
            ],
            [
                "sourceId",
                "org.graphstream.stream",
                "SourceBase",
                "protected String sourceId;"
            ],
            [
                "sourceTime",
                "org.graphstream.stream",
                "SourceBase",
                "protected SourceTime sourceTime;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3814,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream.netstream",
        "className": "NetStreamReceiver",
        "javadocTag": "@param hostname The host name to listen at messages.",
        "methodJavadoc": "    /**\n\t * New NetStream Receiver, awaiting in its own thread at the given host name\n\t * and port, for new graph events.\n\t * \n\t * @param hostname\n\t *            The host name to listen at messages.\n\t * @param port\n\t *            The port to listen at messages.\n\t */",
        "methodSourceCode": "public NetStreamReceiver(String hostname, int port) throws IOException, UnknownHostException{\n    this(hostname, port, false);\n}",
        "classJavadoc": "/**\n * <p>\n * This class implements a receiver according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamSender\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamReceiver.java\n * @since Aug 13, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.graphstream.stream.netstream.packing.NetStreamUnpacker;\nimport org.graphstream.stream.thread.ThreadProxyPipe;\nimport org.miv.mbox.net.PositionableByteArrayInputStream;\n\n/**\n * <p>\n * This class implements a receiver according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamSender\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamReceiver.java\n * @since Aug 13, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */\npublic class NetStreamReceiver extends Thread implements NetStreamDecoder {\n\n\t/**\n\t * the hostname this receiver is listening at.\n\t */\n\tprivate String hostname;\n\n\t/**\n\t * the port listened to.\n\t */\n\tprivate int port;\n\n\t/**\n\t * Receiver socket.\n\t */\n\tprotected ServerSocketChannel server;\n\n\t/**\n\t * Multiplexor.\n\t */\n\tprotected Selector selector;\n\n\t/**\n\t * Key for the selector.\n\t */\n\tprotected SelectionKey key;\n\n\t/**\n\t * While true, the received is running.\n\t */\n\tprotected boolean loop = true;\n\n\t/**\n\t * Show debugging messages.\n\t */\n\tprotected boolean debug = true;\n\n\t/**\n\t * Last encountered error.\n\t */\n\tprotected String lastError = null;\n\n\t/**\n\t * The current pipe commands are being written to.\n\t */\n\tprotected ThreadProxyPipe currentStream;\n\n\t/**\n\t * Utility class that decodes messages according to the NetStream Protocol\n\t */\n\tprotected NetStreamDecoder decoder;\n\t\n\n\t/**\n\t * Current active incoming connections.\n\t */\n\tprotected HashMap<SelectionKey, IncomingBuffer> incoming = new HashMap<SelectionKey, IncomingBuffer>();\n\n\tclass DefaultUnpacker extends NetStreamUnpacker {\n\n\t\t@Override\n\t\tpublic ByteBuffer unpackMessage(ByteBuffer buffer, int startIndex,\n\t\t\t\tint endIndex) {\n\t\t\treturn buffer;\n\t\t}\n\n\t\t@Override\n\t\tpublic int unpackMessageSize(ByteBuffer buffer) {\n\t\t\treturn buffer.getInt();\n\t\t}\n\n\t\t/*\n\t\t * (non-Javadoc)\n\t\t * \n\t\t * @see\n\t\t * org.graphstream.stream.netstream.packing.NetStreamUnpacker#sizeOfInt\n\t\t * ()\n\t\t */\n\t\t@Override\n\t\tpublic int sizeOfInt() {\n\t\t\treturn 4;\n\t\t}\n\t};\n\tprivate NetStreamUnpacker unpacker;\n\n\t// Constructors\n\n\t/**\n\t * New NetStream Receiver, awaiting in its own thread at the given host name\n\t * and port, for new graph events.\n\t * \n\t * @param hostname\n\t *            The host name to listen at messages.\n\t * @param port\n\t *            The port to listen at messages.\n\t */\n\tpublic NetStreamReceiver(String hostname, int port) throws IOException,\n\t\t\tUnknownHostException {\n\t\tthis(hostname, port, false);\n\t}\n\n\t/**\n\t * New NetStream Receiver, awaiting in its own thread at \"localhost\" on the\n\t * given port, for new graph events.\n\t * \n\t * @param port\n\t *            The port to listen at messages.\n\t */\n\tpublic NetStreamReceiver(int port) throws IOException, UnknownHostException {\n\t\tthis(\"localhost\", port, false);\n\t}\n\n\t/**\n\t * New NetStream Receiver, awaiting in its own thread at the given host name\n\t * and port, for new graph events.\n\t * \n\t * @param hostname\n\t *            The host name to listen at messages.\n\t * @param port\n\t *            The port to listen at messages.\n\t * @param debug\n\t *            If true informations are output for each message received.\n\t */\n\tpublic NetStreamReceiver(String hostname, int port, boolean debug)\n\t\t\tthrows IOException, UnknownHostException {\n\t\tthis.hostname = hostname;\n\t\tthis.port = port;\n\t\tthis.unpacker = new DefaultUnpacker();\n\t\tthis.decoder = new DefaultNetStreamDecoder();\n\t\tsetDebugOn(debug);\n\t\tinit();\n\t\tstart();\n\t}\n\n\t// Access\n\n\t/**\n\t * False as soon as the receiver terminates.\n\t */\n\tpublic synchronized boolean isRunning() {\n\t\treturn loop;\n\t}\n\n\n\t// Commands\n\n\t/**\n\t * Initialize the server socket.\n\t */\n\tprotected void init() throws IOException, UnknownHostException {\n\t\tselector = Selector.open();\n\t\tserver = ServerSocketChannel.open();\n\n\t\tserver.configureBlocking(false);\n\n\t\tInetAddress ia = InetAddress.getByName(hostname);\n\t\tInetSocketAddress isa = new InetSocketAddress(ia, port);\n\n\t\tserver.socket().bind(isa);\n\n\t\tif (debug)\n\t\t\tdebug(\"bound to socket %s:%d\", server.socket().getInetAddress(),\n\t\t\t\t\tserver.socket().getLocalPort());\n\n\t\t// Register a first server socket inside the multiplexer.\n\n\t\tkey = server.register(selector, SelectionKey.OP_ACCEPT);\n\t}\n\n\t/**\n\t * Enable or disable debugging.\n\t */\n\tpublic void setDebugOn(boolean on) {\n\t\tdebug = on;\n\t\tdecoder.setDebugOn(on);\n\t}\n\n\n\t/**\n\t * Stop the receiver.\n\t */\n\tpublic synchronized void quit() {\n\t\tloop = false;\n\t\tkey.selector().wakeup();\n\n\t\tif (debug)\n\t\t\tdebug(\"stopped\");\n\t}\n\n\t/**\n\t * Ask the receiver about its active connections\n\t */\n\tpublic synchronized boolean hasActiveConnections() {\n\t\treturn !incoming.isEmpty();\n\t}\n\n\t/**\n\t * Sets an optional NetStreamUnpaker whose \"unpack\" method will be called on\n\t * each message.\n\t * \n\t * It allows to do extra decoding on the all byte array message. You can\n\t * also decrypt things.\n\t * \n\t * @param unpaker\n\t */\n\tpublic void setUnpacker(NetStreamUnpacker unpaker) {\n\t\tthis.unpacker = unpaker;\n\t}\n\tpublic void removeUnpacker() {\n\t\tunpacker = new DefaultUnpacker();\n\t}\n\n\t/**\n\t * Wait for connections, accept them, demultiplexes them and dispatch\n\t * messages to registered message boxes.\n\t */\n\t@Override\n\tpublic void run() {\n\t\tboolean l;\n\n\t\tsynchronized (this) {\n\t\t\tl = loop;\n\t\t}\n\n\t\twhile (l) {\n\t\t\tpoll();\n\n\t\t\tsynchronized (this) {\n\t\t\t\tl = loop;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tserver.close();\n\t\t} catch (IOException e) {\n\t\t\terror(\"cannot close the server socket: \" + e.getMessage(), e);\n\t\t}\n\n\t\tif (debug) {\n\t\t\tdebug(\"receiver //\" + hostname + \":\" + port + \" finished\");\n\t\t}\n\t}\n\n\t/**\n\t * Wait until one or several chunks of message are acceptable. This method\n\t * should be called in a loop. It can be used to block a program until some\n\t * data is available.\n\t */\n\tpublic void poll() {\n\t\ttry {\n\t\t\t// Wait for incoming messages in a loop.\n\n\t\t\tif (key.selector().select() > 0) {\n\t\t\t\tSet<?> readyKeys = selector.selectedKeys();\n\t\t\t\tIterator<?> i = readyKeys.iterator();\n\n\t\t\t\twhile (i.hasNext()) {\n\t\t\t\t\tSelectionKey akey = (SelectionKey) i.next();\n\n\t\t\t\t\ti.remove();\n\n\t\t\t\t\tif (akey.isAcceptable()) {\n\t\t\t\t\t\t// If a new connection occurs, register the new socket\n\t\t\t\t\t\t// in the multiplexer.\n\n\t\t\t\t\t\tServerSocketChannel ssocket = (ServerSocketChannel) akey\n\t\t\t\t\t\t\t\t.channel();\n\t\t\t\t\t\tSocketChannel socket = ssocket.accept();\n\n\t\t\t\t\t\tif (debug)\n\t\t\t\t\t\t\tdebug(\"accepting socket %s:%d\", socket.socket()\n\t\t\t\t\t\t\t\t\t.getInetAddress(), socket.socket()\n\t\t\t\t\t\t\t\t\t.getPort());\n\n\t\t\t\t\t\tsocket.configureBlocking(false);\n\t\t\t\t\t\tsocket.finishConnect();\n\n\t\t\t\t\t\t// SelectionKey otherKey = socket.register( selector,\n\t\t\t\t\t\t// SelectionKey.OP_READ );\n\t\t\t\t\t\tsocket.register(selector, SelectionKey.OP_READ);\n\t\t\t\t\t} else if (akey.isReadable()) {\n\t\t\t\t\t\t// If a message arrives, read it.\n\n\t\t\t\t\t\treadDataChunk(akey);\n\t\t\t\t\t} else if (akey.isWritable()) {\n\t\t\t\t\t\tthrow new RuntimeException(\"should not happen\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\terror(e, \"I/O error in receiver //%s:%d thread: aborting: %s\",\n\t\t\t\t\thostname, port, e.getMessage());\n\n\t\t\tloop = false;\n\t\t} catch (Throwable e) {\n\t\t\terror(e, \"Unknown error: %s\", e.getMessage());\n\n\t\t\tloop = false;\n\t\t}\n\t}\n\n\t/**\n\t * When data is readable on a socket, send it to the appropriate buffer\n\t * (creating it if needed).\n\t */\n\tprotected void readDataChunk(SelectionKey key) throws IOException {\n\t\tIncomingBuffer buf = incoming.get(key);\n\n\t\tif (buf == null) {\n\t\t\tbuf = new IncomingBuffer();\n\t\t\tincoming.put(key, buf);\n\t\t\tSocketChannel socket = (SocketChannel) key.channel();\n\n\t\t\tif (debug)\n\t\t\t\tdebug(\"creating buffer for new connection from %s:%d\", socket\n\t\t\t\t\t\t.socket().getInetAddress(), socket.socket().getPort());\n\t\t}\n\n\t\ttry {\n\t\t\tbuf.readDataChunk(key);\n\n\t\t} catch (IOException e) {\n\t\t\tincoming.remove(key);\n\t\t\te.printStackTrace();\n\t\t\terror(e,\n\t\t\t\t\t\"receiver //%s:%d cannot read object socket channel (I/O error): %s\",\n\t\t\t\t\thostname, port, e.getMessage());\n\t\t\tloop = false;\n\t\t}\n\n\t\tif (!buf.active) {\n\t\t\tincoming.remove(key);\n\t\t\tif (debug)\n\t\t\t\tdebug(\"removing buffer %s from incoming for geting inactive. %d left\",\n\t\t\t\t\t\tkey.toString(), incoming.size());\n\n\t\t}\n\n\t}\n\n\t// Utilities\n\n\tprotected void error(String message, Object... data) {\n\t\terror(null, message, data);\n\t}\n\n\tprotected static final String LIGHT_YELLOW = \"\u001b[33;1m\";\n\tprotected static final String RESET = \"\u001b[0m\";\n\n\tprotected void error(Throwable e, String message, Object... data) {\n\t\t// System.err.print( LIGHT_YELLOW );\n\t\tSystem.err.print(\"[\");\n\t\t// System.err.print( RESET );\n\t\tSystem.err.printf(message, data);\n\t\t// System.err.print( LIGHT_YELLOW );\n\t\tSystem.err.printf(\"]%n\");\n\t\t// System.err.println( RESET );\n\n\t\tif (e != null)\n\t\t\te.printStackTrace();\n\t}\n\n\tprotected void debug(String message, Object... data) {\n\t\t// System.err.print( LIGHT_YELLOW );\n\t\tSystem.err.printf(\"[//%s:%d | \", hostname, port);\n\t\t// System.err.print( RESET );\n\t\tSystem.err.printf(message, data);\n\t\t// System.err.print( LIGHT_YELLOW );\n\t\tSystem.err.printf(\"]%n\");\n\t\t// System.err.println( RESET );\n\t}\n\n\t// Nested classes\n\n\t/**\n\t * The connection to a sender.\n\t * \n\t * The receiver maintains several incoming connections and demultiplexes\n\t * them.\n\t */\n\tprotected class IncomingBuffer {\n\t\t// Attributes\n\n\t\tprotected static final int BUFFER_INITIAL_SIZE = 8192; // 65535, 4096\n\n\t\t/**\n\t\t * Buffer for reading.\n\t\t */\n\t\tprotected ByteBuffer buf = ByteBuffer.allocate(BUFFER_INITIAL_SIZE);\n\n\t\t/**\n\t\t * Index in the buffer past the last byte that forms the current\n\t\t * message. End can be out of the buffer or out of the data read\n\t\t * actually.\n\t\t */\n\t\tprotected int end = -1;\n\n\t\t/**\n\t\t * Index in the buffer of the first byte that forms the currents\n\t\t * message. Beg does not count the 4 bytes that give the size of the\n\t\t * message. While the header is being read, beg is the first byte of the\n\t\t * header.\n\t\t */\n\t\tprotected int beg = 0;\n\n\t\t/**\n\t\t * Position inside beg and end past the last byte read. All bytes at and\n\t\t * after pos have unspecified contents. Pos always verifies pos&gt;=beg\n\t\t * and pos&lt;end. While the header is being read, pos is past the last\n\t\t * byte of the header that has been read.\n\t\t */\n\t\tprotected int pos = 0;\n\n\t\t/**\n\t\t * Object input stream for reading the buffer. This input stream reads\n\t\t * data from the \"bin\" positionable byte array input stream, itself\n\t\t * mapped on the current message to decode.\n\t\t */\n\t\tPositionableByteArrayInputStream in;\n\n\t\t/**\n\t\t * Input stream filter on the buffer. This descendant of\n\t\t * ByteArrayInputStream is able to change its offset and length so that\n\t\t * we can map exactly the message to decode inside the buffer.\n\t\t */\n\t\tPositionableByteArrayInputStream bin;\n\n\t\t/**\n\t\t * When false the socket is closed and this buffer must be removed from\n\t\t * the active connections.\n\t\t */\n\t\tprotected boolean active = true;\n\n\t\t// Constructors\n\n\t\tpublic IncomingBuffer() {\n\t\t}\n\n\t\t// Commands\n\n\t\t/**\n\t\t * Read the available bytes and buffers them. If one or more complete\n\t\t * serialised objects are available, send them to their respective\n\t\t * MBoxes.\n\t\t * \n\t\t * Here is the junk...\n\t\t */\n\t\tpublic void readDataChunk(SelectionKey key) throws IOException {\n\t\t\tint limit = 0; // Index past the last byte read during the current\n\t\t\t\t\t\t\t// invocation.\n\t\t\tint nbytes = 0; // Number of bytes read.\n\t\t\tSocketChannel socket = (SocketChannel) key.channel();\n\n\t\t\tint sizeOfInt = unpacker.sizeOfInt();\n\t\t\t// Buffers the data.\n\n\t\t\tnbytes = bufferize(pos, socket);\n\t\t\tlimit = pos + nbytes;\n\n\t\t\tif (nbytes <= 0)\n\t\t\t\treturn;\n\n\t\t\tif (debug) {\n\t\t\t\tdebug(\"<chunk (%d bytes) from \"\n\t\t\t\t\t\t+ socket.socket().getInetAddress() + \":\"\n\t\t\t\t\t\t+ socket.socket().getPort() + \">\", nbytes);\n\t\t\t\tint at = buf.position();\n\t\t\t\tfor (int i = 0; i < nbytes; i++) {\n\t\t\t\t\tSystem.err.printf(\"%d \", buf.get(at + i));\n\t\t\t\t}\n\t\t\t\tSystem.err.println();\n\t\t\t\tbuf.position(at);\n\t\t\t}\n\t\t\t// Read the first header.\n\n\t\t\tif (end < 0) {\n\t\t\t\tif ((limit - beg) >= sizeOfInt) {\n\t\t\t\t\t// If no data has been read yet in the buffer or if the\n\t\t\t\t\t// buffer\n\t\t\t\t\t// was emptied completely at previous call: prepare to read\n\t\t\t\t\t// a\n\t\t\t\t\t// new message by decoding its header.\n\n\t\t\t\t\tbuf.position(0);\n\t\t\t\t\tint size = unpacker.unpackMessageSize(buf);\n\t\t\t\t\tend = size + sizeOfInt;\n\t\t\t\t\tbeg = sizeOfInt;\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\tdebug(\"start to bufferize a %d byte long messsage\",\n\t\t\t\t\t\t\t\tsize);\n\t\t\t\t} else {\n\t\t\t\t\t// The header is incomplete, wait next call to complete it.\n\n\t\t\t\t\tpos = limit;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Read one or more messages or wait next call to buffers more.\n\n\t\t\tif (end > 0) {\n\t\t\t\twhile (end < limit) {\n\t\t\t\t\t// While the end of the message is in the limit of what was\n\t\t\t\t\t// read, there are one or more complete messages. Decode\n\t\t\t\t\t// them\n\t\t\t\t\t// and read the header of the next message, until a message\n\t\t\t\t\t// is\n\t\t\t\t\t// incomplete or there are no more messages or a header is\n\t\t\t\t\t// incomplete.\n\n\t\t\t\t\tByteBuffer unpackedBuffer = unpacker.unpackMessage(buf, beg, end);\n\t\t\t\t\tif (unpackedBuffer == buf) {\n\t\t\t\t\t\tin = new PositionableByteArrayInputStream(buf.array(), beg, end - beg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tin = new PositionableByteArrayInputStream(\n\t\t\t\t\t\t\t\tunpackedBuffer.array(), 0, unpackedBuffer.capacity());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdecoder.decodeMessage(in);\n\t\t\t\t\tbuf.position(end);\n\n\t\t\t\t\tif (end + sizeOfInt <= limit) {\n\t\t\t\t\t\t// There is a following message.\n\n\t\t\t\t\t\tbeg = end + sizeOfInt;\n\t\t\t\t\t\tend = end + unpacker.unpackMessageSize(buf) + sizeOfInt;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// There is the beginning of a following message\n\t\t\t\t\t\t// but the header is incomplete. Compact the buffer\n\t\t\t\t\t\t// and stop here.\n\t\t\t\t\t\tassert (beg >= sizeOfInt);\n\n\t\t\t\t\t\tbeg = end;\n\t\t\t\t\t\tint p = sizeOfInt - ((end + sizeOfInt) - limit);\n\t\t\t\t\t\tcompactBuffer();\n\t\t\t\t\t\tpos = p;\n\t\t\t\t\t\tbeg = 0;\n\t\t\t\t\t\tend = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (end == limit) {\n\t\t\t\t\t// If the end of the message coincides with the limit of\n\t\t\t\t\t// what\n\t\t\t\t\t// was read we have one last complete message. We decode it\n\t\t\t\t\t// and\n\t\t\t\t\t// clear the buffer for the next call.\n\n\t\t\t\t\tByteBuffer unpackedBuffer = unpacker.unpackMessage(buf, beg, end);\n\t\t\t\t\tif (unpackedBuffer == buf) {\n\t\t\t\t\t\tin = new PositionableByteArrayInputStream(buf.array(), beg, end - beg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tin = new PositionableByteArrayInputStream(\n\t\t\t\t\t\t\t\tunpackedBuffer.array(), 0, unpackedBuffer.capacity());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdecoder.decodeMessage(in);\n\t\t\t\t\t\n\t\t\t\t\tbuf.clear();\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbeg = 0;\n\t\t\t\t\tend = -1;\n\t\t\t\t} else if (end > limit) {\n\t\t\t\t\t// If the end of the message if after what was read, prepare\n\t\t\t\t\t// to\n\t\t\t\t\t// read more at next call when we will have buffered more\n\t\t\t\t\t// data. If we are at the end of the buffer compact it (else\n\t\t\t\t\t// no\n\t\t\t\t\t// more space will be available for buffering).\n\n\t\t\t\t\tpos = limit;\n\n\t\t\t\t\tif (end > buf.capacity())\n\t\t\t\t\t\tcompactBuffer();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Read more data from the <code>socket</code> and put it in the buffer\n\t\t * at <code>at</code>. If the read returns -1 bytes (meaning the\n\t\t * connection ended), the socket is closed and this buffer will be made\n\t\t * inactive (and therefore removed from the active connections by the\n\t\t * Receiver that called it).\n\t\t * \n\t\t * @return the number of bytes read.\n\t\t * @throws IOException\n\t\t *             if an I/O error occurs, in between the socket is closed\n\t\t *             and the connection is made inactive, then the exception\n\t\t *             is thrown.\n\t\t */\n\t\tprotected int bufferize(int at, SocketChannel socket)\n\t\t\t\tthrows IOException {\n\t\t\tint nbytes = 0;\n\t\t\t// int limit = 0;\n\n\t\t\ttry {\n\t\t\t\tbuf.position(at);\n\n\t\t\t\tnbytes = socket.read(buf);\n\n\t\t\t\tif (nbytes < 0) {\n\t\t\t\t\tactive = false;\n\t\t\t\t\tif (in != null)\n\t\t\t\t\t\tin.close();\n\t\t\t\t\tsocket.close();\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\tdebug(\"socket from %s:%d closed\", socket.socket()\n\t\t\t\t\t\t\t\t.getInetAddress(), socket.socket().getPort());\n\t\t\t\t\treturn nbytes;\n\t\t\t\t} else if (nbytes == 0) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"should not happen: buffer to small, 0 bytes read: compact does not function? messages is larger than \"\n\t\t\t\t\t\t\t\t\t+ buf.capacity() + \"?\");\n\t\t\t\t\t// This means that there are no bytes remaining in the\n\t\t\t\t\t// buffer... it is full.\n\t\t\t\t\t// compactBuffer();\n\t\t\t\t\t// return nbytes;\n\t\t\t\t}\n\n\t\t\t\tbuf.position(at);\n\n\t\t\t\treturn nbytes;\n\t\t\t} catch (IOException e) {\n\t\t\t\tif (debug)\n\t\t\t\t\tdebug(\"socket from %s:%d I/O error: %s\", socket.socket()\n\t\t\t\t\t\t\t.getInetAddress(), socket.socket().getPort(),\n\t\t\t\t\t\t\te.getMessage());\n\t\t\t\tactive = false;\n\t\t\t\tif (in != null)\n\t\t\t\t\tin.close();\n\t\t\t\tsocket.close();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t/**\n\t\t * Compact the buffer by removing all read data before <code>beg</code>.\n\t\t * The <code>beg</code>, <code>end</code> and <code>pos</code> markers\n\t\t * are updated accordingly. Compact works only if beg is larger than\n\t\t * four (the size of a header).\n\t\t * \n\t\t * @return the offset.\n\t\t */\n\t\tprotected int compactBuffer() {\n\t\t\tif (beg > unpacker.sizeOfInt()) {\n\t\t\t\tint off = beg;\n\n\t\t\t\tbuf.position(beg);\n\t\t\t\tbuf.limit(buf.capacity());\n\t\t\t\tbuf.compact();\n\n\t\t\t\tpos -= beg;\n\t\t\t\tend -= beg;\n\t\t\t\tbeg = 0;\n\n\t\t\t\treturn off;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/**\n\t\t * Not used in the current implementation, we assumes that no message\n\t\t * will be larger than the size of the buffer.\n\t\t */\n\t\tprotected void enlargeBuffer() {\n\t\t\tByteBuffer tmp = ByteBuffer.allocate(buf.capacity() * 2);\n\n\t\t\tbuf.position(0);\n\t\t\tbuf.limit(buf.capacity());\n\t\t\ttmp.put(buf);\n\t\t\ttmp.position(pos);\n\n\t\t\tbuf = tmp;\n\n\t\t\tif (bin != null)\n\t\t\t\tbin.changeBuffer(buf.array());\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getStream(java.lang.String)\n\t */\n\tpublic ThreadProxyPipe getStream(String name) {\n\t\treturn decoder.getStream(name);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getDefaultStream()\n\t */\n\tpublic ThreadProxyPipe getDefaultStream() {\n\t\treturn decoder.getDefaultStream();\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#register(java.lang.String, org.graphstream.stream.thread.ThreadProxyPipe)\n\t */\n\tpublic void register(String name, ThreadProxyPipe stream) throws Exception {\n\t\tdecoder.register(name, stream);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#decodeMessage(java.io.InputStream)\n\t */\n\tpublic void decodeMessage(InputStream in) throws IOException {\n\t\tdecoder.decodeMessage(in);\n\t\t\n\t}\n\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "hostname",
                "java.lang",
                "String"
            ],
            [
                "port",
                "",
                "int"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getName",
                "java.lang",
                "Thread",
                "public final String getName()"
            ],
            [
                "getId",
                "java.lang",
                "Thread",
                "public long getId()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "hasActiveConnections",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Ask the receiver about its active connections\n */\npublic synchronized boolean hasActiveConnections() {\n    return !incoming.isEmpty();\n}"
            ],
            [
                "getDefaultStream",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getDefaultStream()\n\t */\npublic ThreadProxyPipe getDefaultStream() {\n    return decoder.getDefaultStream();\n}"
            ],
            [
                "getState",
                "java.lang",
                "Thread",
                "public Thread.State getState()"
            ],
            [
                "isAlive",
                "java.lang",
                "Thread",
                "public final boolean isAlive()"
            ],
            [
                "countStackFrames",
                "java.lang",
                "Thread",
                "public int countStackFrames()"
            ],
            [
                "isDaemon",
                "java.lang",
                "Thread",
                "public final boolean isDaemon()"
            ],
            [
                "getThreadGroup",
                "java.lang",
                "Thread",
                "public final ThreadGroup getThreadGroup()"
            ],
            [
                "getStackTrace",
                "java.lang",
                "Thread",
                "public StackTraceElement[] getStackTrace()"
            ],
            [
                "getUncaughtExceptionHandler",
                "java.lang",
                "Thread",
                "public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()"
            ],
            [
                "isRunning",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Access\n/**\n * False as soon as the receiver terminates.\n */\npublic synchronized boolean isRunning() {\n    return loop;\n}"
            ],
            [
                "isInterrupted",
                "java.lang",
                "Thread",
                "public boolean isInterrupted()"
            ],
            [
                "getContextClassLoader",
                "java.lang",
                "Thread",
                "public ClassLoader getContextClassLoader()"
            ],
            [
                "getPriority",
                "java.lang",
                "Thread",
                "public final int getPriority()"
            ],
            [
                "clone",
                "java.lang",
                "Thread",
                "protected Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getStream",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getStream(java.lang.String)\n\t */\npublic ThreadProxyPipe getStream(String name) {\n    return decoder.getStream(name);\n}"
            ],
            [
                "toString",
                "java.lang",
                "Thread",
                "public String toString()"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "server",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Receiver socket.\n */\nprotected ServerSocketChannel server;"
            ],
            [
                "selector",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Multiplexor.\n */\nprotected Selector selector;"
            ],
            [
                "key",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Key for the selector.\n */\nprotected SelectionKey key;"
            ],
            [
                "loop",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * While true, the received is running.\n */\nprotected boolean loop = true;"
            ],
            [
                "debug",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Show debugging messages.\n */\nprotected boolean debug = true;"
            ],
            [
                "lastError",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Last encountered error.\n */\nprotected String lastError = null;"
            ],
            [
                "currentStream",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * The current pipe commands are being written to.\n */\nprotected ThreadProxyPipe currentStream;"
            ],
            [
                "decoder",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Utility class that decodes messages according to the NetStream Protocol\n */\nprotected NetStreamDecoder decoder;"
            ],
            [
                "incoming",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "/**\n * Current active incoming connections.\n */\nprotected HashMap<SelectionKey, IncomingBuffer> incoming = new HashMap<SelectionKey, IncomingBuffer>();"
            ],
            [
                "threadLocals",
                "java.lang",
                "Thread",
                "ThreadLocal.ThreadLocalMap threadLocals;"
            ],
            [
                "inheritableThreadLocals",
                "java.lang",
                "Thread",
                "ThreadLocal.ThreadLocalMap inheritableThreadLocals;"
            ],
            [
                "parkBlocker",
                "java.lang",
                "Thread",
                "Object parkBlocker;"
            ],
            [
                "threadLocalRandomSeed",
                "java.lang",
                "Thread",
                "long threadLocalRandomSeed;"
            ],
            [
                "threadLocalRandomProbe",
                "java.lang",
                "Thread",
                "int threadLocalRandomProbe;"
            ],
            [
                "threadLocalRandomSecondarySeed",
                "java.lang",
                "Thread",
                "int threadLocalRandomSecondarySeed;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3823,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream.netstream",
        "className": "NetStreamSender",
        "javadocTag": "@return",
        "methodJavadoc": "    /**\n\t * @param in\n\t * @return\n\t */",
        "methodSourceCode": "protected ByteBuffer encodeArray(Object in){\n    // TODO...\n    return null;\n}",
        "classJavadoc": "/**\n * <p>\n * This class implements a sender according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamReceiver\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamSender.java\n * @since Aug 10, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\nimport org.graphstream.stream.Sink;\nimport org.graphstream.stream.netstream.packing.NetStreamPacker;\n\n/**\n * <p>\n * This class implements a sender according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamReceiver\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamSender.java\n * @since Aug 10, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */\npublic class NetStreamSender implements Sink {\n\tprivate static ByteBuffer NULL_BUFFER = ByteBuffer.allocate(0);\n\t\n\tprotected String stream;\n\tprotected ByteBuffer streamBuffer;\n\tbyte[] streamIdArray;\n\tprotected String host;\n\tprotected int port;\n\tprotected Socket socket;\n\tprotected BufferedOutputStream out;\n\n\tprotected String sourceId = \"\";\n\tprotected ByteBuffer sourceIdBuff;\n\n\tclass DefaultPacker extends NetStreamPacker {\n\t\tByteBuffer sizeBuffer = ByteBuffer.allocate(4);\n\n\t\t@Override\n\t\tpublic ByteBuffer packMessage(ByteBuffer buffer, int startIndex,\n\t\t\t\tint endIndex) {\n\t\t\treturn buffer;\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBuffer packMessageSize(int capacity) {\n\t\t\tsizeBuffer.rewind();\n\t\t\tsizeBuffer.putInt(capacity);\n\t\t\treturn sizeBuffer;\n\t\t}\n\n\t};\n\n\tprotected NetStreamPacker packer = new DefaultPacker();\n\n\tpublic NetStreamSender(String host, int port) throws UnknownHostException,\n\t\t\tIOException {\n\t\tthis(\"default\", host, port);\n\t}\n\tpublic NetStreamSender(int port) throws UnknownHostException, IOException {\n\t\tthis(\"default\", \"localhost\", port);\n\t}\n\n\tpublic NetStreamSender(String stream, String host, int port)\n\t\t\tthrows UnknownHostException, IOException {\n\t\tthis.stream = stream;\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tsetStream(stream);\n\t\t\n\t\tconnect();\n\t\t\n\t}\n\t\n\t/**\n\t * @param stream2\n\t */\n\tpublic void setStream(String stream) {\n\t\tstreamIdArray = stream.getBytes(Charset.forName(\"UTF-8\"));\n\t\tstreamBuffer = encodeString(stream);\n\t\t\n\t\t\n\t}\n\tpublic NetStreamSender(Socket socket) throws IOException {\n\t\tthis(\"default\", socket);\n\t}\n\t\n\tpublic NetStreamSender(String stream, Socket socket) throws IOException {\n\t\tthis.host = socket.getInetAddress().getHostName();\n\t\tthis.port = socket.getPort();\n\t\tthis.socket = socket;\n\t\tthis.out = new BufferedOutputStream(socket.getOutputStream());\n\t\tthis.streamIdArray = stream.getBytes(Charset.forName(\"UTF-8\"));\n\t}\n\n\t/**\n\t * Sets an optional NetStreamPaker whose \"pack\" method will be called on\n\t * each message.\n\t * \n\t * a Packer can do extra encoding on the all byte array message, it may also\n\t * crypt things.\n\t * \n\t * @param paker\n\t *            The packer object\n\t */\n\tpublic void setPacker(NetStreamPacker paker) {\n\t\tthis.packer = paker;\n\t}\n\tpublic void removePacker() {\n\t\tpacker = new DefaultPacker();\n\t}\n\n\tprotected void connect() throws UnknownHostException, IOException {\n\n\t\tsocket = new Socket(host, port);\n\t\tout = new BufferedOutputStream(socket.getOutputStream());\n\n\t}\n\n\tprotected int getType(Object value) {\n\t\tint valueType = NetStreamConstants.TYPE_UNKNOWN;\n\t\t\n\t\tif (value == null)\n\t\t\treturn NetStreamConstants.TYPE_NULL;\n\t\t\n\t\tClass<?> valueClass = value.getClass();\n\t\tboolean isArray = valueClass.isArray();\n\t\tif (isArray) {\n\t\t\tvalueClass = ((Object[]) value)[0].getClass();\n\t\t}\n\t\tif (valueClass.equals(Boolean.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BOOLEAN_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BOOLEAN;\n\t\t\t}\n\t\t} else if (valueClass.equals(Byte.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BYTE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BYTE;\n\t\t\t}\n\t\t} else if (valueClass.equals(Short.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_SHORT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_SHORT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Integer.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_INT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_INT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Long.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_LONG_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_LONG;\n\t\t\t}\n\t\t} else if (valueClass.equals(Float.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_FLOAT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_FLOAT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Double.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_DOUBLE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_DOUBLE;\n\t\t\t}\n\t\t} else if (valueClass.equals(String.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_STRING;\n\t\t\t}\n\t\t} else \n\t\t\tSystem.err.printf(\"[warning] can not find type of %s\\n\", valueClass);\n\t\t// System.out.println(\"ValueType=\"+valueType+\" \"+value.getClass());\n\t\treturn valueType;\n\t}\n\t\n\tprotected ByteBuffer encodeValue(Object in, int valueType) {\n\n\t\tif (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n\t\t\treturn encodeBoolean(in);\n\t\t} else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n\t\t\treturn encodeBooleanArray(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE == valueType) {\n\t\t\treturn encodeByte(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n\t\t\treturn encodeByteArray(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT == valueType) {\n\t\t\treturn encodeShort(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n\t\t\treturn encodeShortArray(in);\n\t\t} else if (NetStreamConstants.TYPE_INT == valueType) {\n\t\t\treturn encodeInt(in);\n\t\t} else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n\t\t\treturn encodeIntArray(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG == valueType) {\n\t\t\treturn encodeLong(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n\t\t\treturn encodeLongArray(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n\t\t\treturn encodeFloat(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n\t\t\treturn encodeFloatArray(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n\t\t\treturn encodeDouble(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n\t\t\treturn encodeDoubleArray(in);\n\t\t} else if (NetStreamConstants.TYPE_STRING == valueType) {\n\t\t\treturn encodeString(in);\n\t\t} else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n\t\t\treturn encodeArray(in);\n\t\t} else if (NetStreamConstants.TYPE_NULL == valueType) {\n\t\t\treturn NULL_BUFFER;\n\t\t}\n\t\t\n\t\tSystem.err.printf(\"[warning] unknown value type %d\\n\", valueType);\n\t\t\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeArray(Object in) {\n\t\t// TODO...\n\t\treturn null;\n\t}\n\n\t/*\n\tprivate void outBuffer(ByteBuffer buf){\n\t\tSystem.out.println(buf.toString());\n\t\tint nbytes = buf.capacity();\n\t\tint at = buf.position();\n\t\tfor(int i=0; i< nbytes; i++){\n\t\t\tint bt = buf.get(at+i);\n\t\t\tif (bt < 0) bt = (bt & 127) + (bt & 128); \n\t\t\tSystem.out.printf(\"%d \", bt);\n\t\t}\n\t\tSystem.out.println();\n\t}*/\n\t\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeString(Object in) {\n\t\t//System.out.println(\"They want me to encode this string: \"+in);\n\t\tString s = (String) in;\n\t\tbyte[] data = s.getBytes(Charset.forName(\"UTF-8\"));\n\t\t\n\t\tByteBuffer lenBuff = encodeUnsignedVarint(data.length);\n\t\t//outBuffer(lenBuff);\n\t\tByteBuffer bb = ByteBuffer.allocate(lenBuff.capacity() + data.length);\n\t\tbb.put(lenBuff).put(data);\n\t\tbb.rewind();\n\t\t//outBuffer(bb);\n\t\t\n\t\treturn bb;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeDoubleArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length * 8);\n\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.putDouble((Double) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The double to encode\n\t * @return ByteBuffer with encoded double in it\n\t */\n\tprotected ByteBuffer encodeDouble(Object in) {\n\t\tByteBuffer bb = ByteBuffer.allocate(8).putDouble((Double) in);\n\t\tbb.rewind();\n\t\treturn bb;\n\t}\n\n\t/**\n\t * @param in The float array to encode\n\t * @return ByteBuffer with encoded float array in it\n\t */\n\tprotected ByteBuffer encodeFloatArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\t\t\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length * 4);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.putFloat((Float) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The float to encode\n\t * @return ByteBuffer with encoded float in it\n\t */\n\tprotected ByteBuffer encodeFloat(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(4);\n\t\tb.putFloat(((Float) in));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The long array to encode\n\t * @return ByteBuffer with encoded long array in it\n\t */\n\tprotected ByteBuffer encodeLongArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in The long to encode\n\t * @return ByteBuffer with encoded long in it\n\t */\n\tprotected ByteBuffer encodeLong(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in The integer array to encode\n\t * @return ByteBuffer with encoded integer array in it\n\t */\n\tprotected ByteBuffer encodeIntArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in The integer to encode\n\t * @return ByteBuffer with encoded integer in it\n\t */\n\tprotected ByteBuffer encodeInt(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeShortArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeShort(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeByteArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.put((Byte) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeByte(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(1);\n\t\tb.put(((Byte) in));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeBooleanArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.put((byte) ((Boolean) data[i] == false ? 0 : 1));\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeBoolean(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(1);\n\t\tb.put((byte) (((Boolean) in) == false ? 0 : 1));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\tprivate int varintSize(long data){\n\t\t\n\t\t// 7 bits -> 127\n\t\tif(data < (1L << 7)){\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t// 14 bits -> 16383\n\t\tif(data < (1L << 14)){\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t\t// 21 bits -> 2097151\n\t\tif(data < (1L << 21)){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\t// 28 bits -> 268435455\n\t\tif(data < (1L << 28)){\n\t\t\treturn 4;\n\t\t}\n\n\t\t// 35 bits -> 34359738367\n\t\tif(data < (1L << 35)){\n\t\t\treturn 5;\n\t\t}\n\n\t\t// 42 bits -> 4398046511103\n\t\tif(data < (1L << 42)){\n\t\t\treturn 6;\n\t\t}\n\t\t\n\t\t// 49 bits -> 562949953421311\n\t\tif(data < (1L << 49)){\n\t\t\treturn 7;\n\t\t}\n\t\t\n\t\t// 56 bits -> 72057594037927935\n\t\tif(data < (1L << 56)){\n\t\t\treturn 8;\n\t\t}\t\n\t\t\n\t\treturn 9;\n\t}\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeVarint(Object in) {\n\t\tlong data = ((Number)in).longValue();\n\t\t\n\t\t// signed integers encoding\n\t\t// (n << 1) ^ (n >> 31)\n\t\t// OK but java's negative values are two's complements...\n\t\t\n\t\treturn encodeUnsignedVarint(data>=0?(data<<1):((Math.abs(data) << 1) ^ 1));\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeVarintArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\t\tint[] sizes = new int[data.length];\n\t\tlong[] zigzags = new long[data.length];\n\t\tint sumsizes=0;\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tlong datum = ((Number)data[i]).longValue();\n\t\t\t// signed integers encoding\n\t\t\t// (n << 1) ^ (n >> 31)\n\t\t\t// OK but java's negative values are two's complements...\n\t\t\tzigzags[i] = datum>0?(datum<<1):((Math.abs(datum) << 1) ^ 1);\n\t\t\t\n\t\t\tsizes[i] = varintSize(zigzags[i]);\n\t\t\tsumsizes+=sizes[i];\n\t\t\t//System.out.printf(\"i=%d, zigzag=%d, size=%d\\n\",i, zigzags[i], sizes[i]);\n\t\t}\t\t\n\t\t\n\t\t// the size of the size!\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + sumsizes);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\t\t\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tputVarint(b, zigzags[i], sizes[i]);\n\t\t}\n\t\tb.rewind();\n\t\t//outBuffer(b);\n\t\treturn b;\n\t}\n\t\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeUnsignedVarint(Object in) {\n\t\tlong data = ((Number)in).longValue();\n\t\t\n\t\tint size = varintSize(data);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(size);\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tint head=128;\n\t\t\tif(i==size-1) head = 0;\n\t\t\tlong b = ((data >> (7*i)) & 127) ^ head;\n\t\t\tbuff.put((byte)(b & 255 ));\n\t\t}\n\t\tbuff.rewind();\n\t\treturn  buff;\n\t}\n\n\t\n\t/**\n\t * @param b\n\t * @param sumsizes\n\t * @param ssize\n\t */\n\tprivate void putVarint(ByteBuffer buffer, long number, int byteSize) {\n\t\tfor(int i = 0; i < byteSize; i++){\n\t\t\tint head=128;\n\t\t\tif(i==byteSize-1) head = 0;\n\t\t\tlong b = ((number >> (7*i)) & 127) ^ head;\n\t\t\tbuffer.put((byte)(b & 255 ));\n\t\t}\n\t}\n\t\n\t/**\n\t * @param buff\n\t */\n\tprivate void doSend(ByteBuffer buff) {\n\n\t\tif (socket.isClosed()) {\n\t\t\tSystem.err\n\t\t\t\t\t.println(\"NetStreamSender : can't send. The socket is closed.\");\n\t\t} else {\n\t\t\tbuff.rewind();\n\t\t\t//outBuffer(buff);\n\t\t\tByteBuffer buffer = packer.packMessage(buff);\n\t\t\tByteBuffer sizeBuffer = packer.packMessageSize(buffer.capacity());\n\t\n\t\t\t// real sending\n\t\t\ttry {\n\t\t\t\tout.write(sizeBuffer.array(), 0, sizeBuffer.capacity());\n\t\t\t\tout.write(buffer.array(), 0, buffer.capacity());\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\ttry {\n\t\t\t\t\tsocket.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.err.printf(\"socket error : %s\\n\", e.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeAdded(java.lang.String\n\t * , long, java.lang.String, java.lang.Object)\n\t */\n\tpublic void graphAttributeAdded(String sourceId, long timeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t\t\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint valueType = getType(value);\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity() + // attribute id\n\t\t\t\t1 + // attr type\n\t\t\t\tvalueBuff.capacity()); // attr value\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\tbuff\n\t\t\t.put(streamBuffer)\n\t\t\t.put((byte) NetStreamConstants.EVENT_ADD_GRAPH_ATTR)\n\t\t\t.put(sourceIdBuff)\n\t\t\t.put(encodeUnsignedVarint(timeId))\n\t\t\t.put(attrBuff)\n\t\t\t.put((byte) valueType)\n\t\t\t.put(valueBuff);\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeChanged(java.lang.\n\t * String, long, java.lang.String, java.lang.Object, java.lang.Object)\n\t */\n\tpublic void graphAttributeChanged(String sourceId, long timeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\t\t\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity() + // attribute id\n\t\t\t\t1 + // attr type\n\t\t\t\toldValueBuff.capacity() + // attr value\n\t\t\t\t1 + // attr type\n\t\t\t\tnewValueBuff.capacity()); // attr value\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\tbuff\n\t\t\t.put(streamBuffer)\n\t\t\t.put((byte) NetStreamConstants.EVENT_CHG_GRAPH_ATTR)\n\t\t\t.put(sourceIdBuff)\n\t\t\t.put(encodeUnsignedVarint(timeId))\n\t\t\t.put(attrBuff)\n\t\t\t.put((byte) oldValueType)\n\t\t\t.put(oldValueBuff)\n\t\t\t.put((byte) newValueType)\n\t\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeRemoved(java.lang.\n\t * String, long, java.lang.String)\n\t */\n\tpublic void graphAttributeRemoved(String sourceId, long timeId,\n\t\t\tString attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity()\n\t\t\t\t); // attribute id\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\t\t\t\t\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_GRAPH_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(attrBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeAdded(java.lang.String,\n\t * long, java.lang.String, java.lang.String, java.lang.Object)\n\t */\n\tpublic void nodeAttributeAdded(String sourceId, long timeId, String nodeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint valueType = getType(value);\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\tvalueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) valueType)\n\t\t.put(valueBuff);\n\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeChanged(java.lang.String\n\t * , long, java.lang.String, java.lang.String, java.lang.Object,\n\t * java.lang.Object)\n\t */\n\tpublic void nodeAttributeChanged(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object oldValue, Object newValue) {\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\t\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\t\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\t\t\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\toldValueBuff.capacity() + // value\n\t\t\t\t1 + // value type\n\t\t\t\tnewValueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CHG_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) oldValueType)\n\t\t.put(oldValueBuff)\n\t\t.put((byte) newValueType)\n\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeRemoved(java.lang.String\n\t * , long, java.lang.String, java.lang.String)\n\t */\n\tpublic void nodeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() // attribute\n\t\t);\n\t\t\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff);\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeAdded(java.lang.String,\n\t * long, java.lang.String, java.lang.String, java.lang.Object)\n\t */\n\tpublic void edgeAttributeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tint valueType = getType(value);\n\t\t\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\tvalueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) valueType) // value type\n\t\t.put(valueBuff);\n\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeChanged(java.lang.String\n\t * , long, java.lang.String, java.lang.String, java.lang.Object,\n\t * java.lang.Object)\n\t */\n\tpublic void edgeAttributeChanged(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object oldValue, Object newValue) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\toldValueBuff.capacity() + // value\n\t\t\t\t1 + // value type\n\t\t\t\tnewValueBuff.capacity()  // value\n\t\t);\n\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CHG_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) oldValueType)\n\t\t.put(oldValueBuff)\n\t\t.put((byte) newValueType)\n\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeRemoved(java.lang.String\n\t * , long, java.lang.String, java.lang.String)\n\t */\n\tpublic void edgeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() // attribute\n\t\t);\n\t\t\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff);\n\t\t\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#nodeAdded(java.lang.String, long,\n\t * java.lang.String)\n\t */\n\tpublic void nodeAdded(String sourceId, long timeId, String nodeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\t\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() // nodeId \n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_NODE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff);\n\t\t\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#nodeRemoved(java.lang.String,\n\t * long, java.lang.String)\n\t */\n\tpublic void nodeRemoved(String sourceId, long timeId, String nodeId) {\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() // nodeId \n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_NODE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff);\n\t\t\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#edgeAdded(java.lang.String, long,\n\t * java.lang.String, java.lang.String, java.lang.String, boolean)\n\t */\n\tpublic void edgeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer fromNodeBuff = encodeString(fromNodeId);\n\t\tByteBuffer toNodeBuff = encodeString(toNodeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // edge\n\t\t\t\tfromNodeBuff.capacity() + // from nodeId\n\t\t\t\ttoNodeBuff.capacity() + // to nodeId \n\t\t\t\t1 // direction\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_EDGE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(fromNodeBuff)\n\t\t.put(toNodeBuff)\n\t\t.put((byte) (!directed ? 0 : 1));\n\t\t\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#edgeRemoved(java.lang.String,\n\t * long, java.lang.String)\n\t */\n\tpublic void edgeRemoved(String sourceId, long timeId, String edgeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity()  // edge\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_EDGE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#graphCleared(java.lang.String,\n\t * long)\n\t */\n\tpublic void graphCleared(String sourceId, long timeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId)\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CLEARED)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId));\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#stepBegins(java.lang.String,\n\t * long, double)\n\t */\n\tpublic void stepBegins(String sourceId, long timeId, double step) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) +\n\t\t\t\t8 // time\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_STEP)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.putDouble(step);\n\t\t\n\t\t\n\t\tdoSend(buff);\n\t}\n\n\t/**\n\t * Force the connection to close (properly) with the server\n\t * \n\t * @throws IOException\n\t */\n\tpublic void close() throws IOException {\n\t\tsocket.close();\n\t}\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "in",
                "java.lang",
                "Object"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "encodeDouble",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The double to encode\n * @return ByteBuffer with encoded double in it\n */\nprotected ByteBuffer encodeDouble(Object in) {\n    ByteBuffer bb = ByteBuffer.allocate(8).putDouble((Double) in);\n    bb.rewind();\n    return bb;\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "encodeDoubleArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeDoubleArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length * 8);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.putDouble((Double) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeFloatArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The float array to encode\n * @return ByteBuffer with encoded float array in it\n */\nprotected ByteBuffer encodeFloatArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length * 4);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.putFloat((Float) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeUnsignedVarint",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeUnsignedVarint(Object in) {\n    long data = ((Number) in).longValue();\n    int size = varintSize(data);\n    ByteBuffer buff = ByteBuffer.allocate(size);\n    for (int i = 0; i < size; i++) {\n        int head = 128;\n        if (i == size - 1)\n            head = 0;\n        long b = ((data >> (7 * i)) & 127) ^ head;\n        buff.put((byte) (b & 255));\n    }\n    buff.rewind();\n    return buff;\n}"
            ],
            [
                "encodeFloat",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The float to encode\n * @return ByteBuffer with encoded float in it\n */\nprotected ByteBuffer encodeFloat(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(4);\n    b.putFloat(((Float) in));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeShort",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeShort(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeShortArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeShortArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "encodeBooleanArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeBooleanArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.put((byte) ((Boolean) data[i] == false ? 0 : 1));\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "encodeInt",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The integer to encode\n * @return ByteBuffer with encoded integer in it\n */\nprotected ByteBuffer encodeInt(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "encodeLongArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The long array to encode\n * @return ByteBuffer with encoded long array in it\n */\nprotected ByteBuffer encodeLongArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "encodeVarint",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeVarint(Object in) {\n    long data = ((Number) in).longValue();\n    // signed integers encoding\n    // (n << 1) ^ (n >> 31)\n    // OK but java's negative values are two's complements...\n    return encodeUnsignedVarint(data >= 0 ? (data << 1) : ((Math.abs(data) << 1) ^ 1));\n}"
            ],
            [
                "encodeByteArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeByteArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.put((Byte) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeVarintArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeVarintArray(Object in) {\n    Object[] data = (Object[]) in;\n    int[] sizes = new int[data.length];\n    long[] zigzags = new long[data.length];\n    int sumsizes = 0;\n    for (int i = 0; i < data.length; i++) {\n        long datum = ((Number) data[i]).longValue();\n        // signed integers encoding\n        // (n << 1) ^ (n >> 31)\n        // OK but java's negative values are two's complements...\n        zigzags[i] = datum > 0 ? (datum << 1) : ((Math.abs(datum) << 1) ^ 1);\n        sizes[i] = varintSize(zigzags[i]);\n        sumsizes += sizes[i];\n        //System.out.printf(\"i=%d, zigzag=%d, size=%d\\n\",i, zigzags[i], sizes[i]);\n    }\n    // the size of the size!\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + sumsizes);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        putVarint(b, zigzags[i], sizes[i]);\n    }\n    b.rewind();\n    //outBuffer(b);\n    return b;\n}"
            ],
            [
                "encodeValue",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer encodeValue(Object in, int valueType) {\n    if (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n        return encodeBoolean(in);\n    } else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n        return encodeBooleanArray(in);\n    } else if (NetStreamConstants.TYPE_BYTE == valueType) {\n        return encodeByte(in);\n    } else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n        return encodeByteArray(in);\n    } else if (NetStreamConstants.TYPE_SHORT == valueType) {\n        return encodeShort(in);\n    } else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n        return encodeShortArray(in);\n    } else if (NetStreamConstants.TYPE_INT == valueType) {\n        return encodeInt(in);\n    } else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n        return encodeIntArray(in);\n    } else if (NetStreamConstants.TYPE_LONG == valueType) {\n        return encodeLong(in);\n    } else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n        return encodeLongArray(in);\n    } else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n        return encodeFloat(in);\n    } else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n        return encodeFloatArray(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n        return encodeDouble(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n        return encodeDoubleArray(in);\n    } else if (NetStreamConstants.TYPE_STRING == valueType) {\n        return encodeString(in);\n    } else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n        return encodeArray(in);\n    } else if (NetStreamConstants.TYPE_NULL == valueType) {\n        return NULL_BUFFER;\n    }\n    System.err.printf(\"[warning] unknown value type %d\\n\", valueType);\n    return null;\n}"
            ],
            [
                "encodeArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeArray(Object in) {\n    // TODO...\n    return null;\n}"
            ],
            [
                "encodeString",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/*\n\tprivate void outBuffer(ByteBuffer buf){\n\t\tSystem.out.println(buf.toString());\n\t\tint nbytes = buf.capacity();\n\t\tint at = buf.position();\n\t\tfor(int i=0; i< nbytes; i++){\n\t\t\tint bt = buf.get(at+i);\n\t\t\tif (bt < 0) bt = (bt & 127) + (bt & 128); \n\t\t\tSystem.out.printf(\"%d \", bt);\n\t\t}\n\t\tSystem.out.println();\n\t}*/\n/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeString(Object in) {\n    //System.out.println(\"They want me to encode this string: \"+in);\n    String s = (String) in;\n    byte[] data = s.getBytes(Charset.forName(\"UTF-8\"));\n    ByteBuffer lenBuff = encodeUnsignedVarint(data.length);\n    //outBuffer(lenBuff);\n    ByteBuffer bb = ByteBuffer.allocate(lenBuff.capacity() + data.length);\n    bb.put(lenBuff).put(data);\n    bb.rewind();\n    //outBuffer(bb);\n    return bb;\n}"
            ],
            [
                "encodeLong",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The long to encode\n * @return ByteBuffer with encoded long in it\n */\nprotected ByteBuffer encodeLong(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeIntArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The integer array to encode\n * @return ByteBuffer with encoded integer array in it\n */\nprotected ByteBuffer encodeIntArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "encodeByte",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeByte(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(1);\n    b.put(((Byte) in));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeBoolean",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeBoolean(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(1);\n    b.put((byte) (((Boolean) in) == false ? 0 : 1));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getType",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected int getType(Object value) {\n    int valueType = NetStreamConstants.TYPE_UNKNOWN;\n    if (value == null)\n        return NetStreamConstants.TYPE_NULL;\n    Class<?> valueClass = value.getClass();\n    boolean isArray = valueClass.isArray();\n    if (isArray) {\n        valueClass = ((Object[]) value)[0].getClass();\n    }\n    if (valueClass.equals(Boolean.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_BOOLEAN_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_BOOLEAN;\n        }\n    } else if (valueClass.equals(Byte.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_BYTE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_BYTE;\n        }\n    } else if (valueClass.equals(Short.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_SHORT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_SHORT;\n        }\n    } else if (valueClass.equals(Integer.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_INT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_INT;\n        }\n    } else if (valueClass.equals(Long.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_LONG_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_LONG;\n        }\n    } else if (valueClass.equals(Float.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_FLOAT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_FLOAT;\n        }\n    } else if (valueClass.equals(Double.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_DOUBLE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_DOUBLE;\n        }\n    } else if (valueClass.equals(String.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_STRING;\n        }\n    } else\n        System.err.printf(\"[warning] can not find type of %s\\n\", valueClass);\n    // System.out.println(\"ValueType=\"+valueType+\" \"+value.getClass());\n    return valueType;\n}"
            ],
            [
                "putDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putDouble(int arg0, double arg1)"
            ],
            [
                "slice",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer slice()"
            ],
            [
                "asLongBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract LongBuffer asLongBuffer()"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer put(byte arg0)"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(byte[] arg0, int arg1, int arg2)"
            ],
            [
                "position",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer position(int arg0)"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public abstract byte get(int arg0)"
            ],
            [
                "getInt",
                "java.nio",
                "ByteBuffer",
                "public abstract int getInt(int arg0)"
            ],
            [
                "toString",
                "java.nio",
                "ByteBuffer",
                "public String toString()"
            ],
            [
                "arrayOffset",
                "java.nio",
                "ByteBuffer",
                "public final int arrayOffset()"
            ],
            [
                "compact",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer compact()"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public final ByteBuffer put(byte[] arg0)"
            ],
            [
                "flip",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer flip()"
            ],
            [
                "hasArray",
                "java.nio",
                "ByteBuffer",
                "public final boolean hasArray()"
            ],
            [
                "mark",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer mark()"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(int arg0, byte[] arg1)"
            ],
            [
                "getShort",
                "java.nio",
                "ByteBuffer",
                "public abstract short getShort()"
            ],
            [
                "clear",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer clear()"
            ],
            [
                "asIntBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract IntBuffer asIntBuffer()"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(byte[] arg0)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(int arg0, ByteBuffer arg1, int arg2, int arg3)"
            ],
            [
                "putChar",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putChar(char arg0)"
            ],
            [
                "asReadOnlyBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer asReadOnlyBuffer()"
            ],
            [
                "putFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putFloat(int arg0, float arg1)"
            ],
            [
                "order",
                "java.nio",
                "ByteBuffer",
                "public final ByteOrder order()"
            ],
            [
                "getChar",
                "java.nio",
                "ByteBuffer",
                "public abstract char getChar()"
            ],
            [
                "slice",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer slice(int arg0, int arg1)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(byte[] arg0, int arg1, int arg2)"
            ],
            [
                "base",
                "java.nio",
                "ByteBuffer",
                "Object base()"
            ],
            [
                "alignmentOffset",
                "java.nio",
                "ByteBuffer",
                "public final int alignmentOffset(int arg0, int arg1)"
            ],
            [
                "putInt",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putInt(int arg0)"
            ],
            [
                "limit",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer limit(int arg0)"
            ],
            [
                "reset",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer reset()"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public abstract byte get()"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(int arg0, byte[] arg1, int arg2, int arg3)"
            ],
            [
                "rewind",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer rewind()"
            ],
            [
                "putChar",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putChar(int arg0, char arg1)"
            ],
            [
                "array",
                "java.nio",
                "ByteBuffer",
                "public final byte[] array()"
            ],
            [
                "putShort",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putShort(short arg0)"
            ],
            [
                "duplicate",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer duplicate()"
            ],
            [
                "getFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract float getFloat(int arg0)"
            ],
            [
                "putLong",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putLong(int arg0, long arg1)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(ByteBuffer arg0)"
            ],
            [
                "asCharBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract CharBuffer asCharBuffer()"
            ],
            [
                "compareTo",
                "java.nio",
                "ByteBuffer",
                "public int compareTo(ByteBuffer arg0)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer put(int arg0, byte arg1)"
            ],
            [
                "getDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract double getDouble()"
            ],
            [
                "alignedSlice",
                "java.nio",
                "ByteBuffer",
                "public final ByteBuffer alignedSlice(int arg0)"
            ],
            [
                "getShort",
                "java.nio",
                "ByteBuffer",
                "public abstract short getShort(int arg0)"
            ],
            [
                "getLong",
                "java.nio",
                "ByteBuffer",
                "public abstract long getLong()"
            ],
            [
                "putDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putDouble(double arg0)"
            ],
            [
                "asFloatBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract FloatBuffer asFloatBuffer()"
            ],
            [
                "putLong",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putLong(long arg0)"
            ],
            [
                "mismatch",
                "java.nio",
                "ByteBuffer",
                "public int mismatch(ByteBuffer arg0)"
            ],
            [
                "getLong",
                "java.nio",
                "ByteBuffer",
                "public abstract long getLong(int arg0)"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(int arg0, byte[] arg1)"
            ],
            [
                "putShort",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putShort(int arg0, short arg1)"
            ],
            [
                "putFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putFloat(float arg0)"
            ],
            [
                "getFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract float getFloat()"
            ],
            [
                "asDoubleBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract DoubleBuffer asDoubleBuffer()"
            ],
            [
                "putInt",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putInt(int arg0, int arg1)"
            ],
            [
                "getDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract double getDouble(int arg0)"
            ],
            [
                "hashCode",
                "java.nio",
                "ByteBuffer",
                "public int hashCode()"
            ],
            [
                "equals",
                "java.nio",
                "ByteBuffer",
                "public boolean equals(Object arg0)"
            ],
            [
                "order",
                "java.nio",
                "ByteBuffer",
                "public final ByteBuffer order(ByteOrder arg0)"
            ],
            [
                "getChar",
                "java.nio",
                "ByteBuffer",
                "public abstract char getChar(int arg0)"
            ],
            [
                "getInt",
                "java.nio",
                "ByteBuffer",
                "public abstract int getInt()"
            ],
            [
                "asShortBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract ShortBuffer asShortBuffer()"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(int arg0, byte[] arg1, int arg2, int arg3)"
            ],
            [
                "isDirect",
                "java.nio",
                "ByteBuffer",
                "public abstract boolean isDirect()"
            ],
            [
                "flip",
                "java.nio",
                "Buffer",
                "public Buffer flip()"
            ],
            [
                "remaining",
                "java.nio",
                "Buffer",
                "public final int remaining()"
            ],
            [
                "position",
                "java.nio",
                "Buffer",
                "public final int position()"
            ],
            [
                "duplicate",
                "java.nio",
                "Buffer",
                "public abstract Buffer duplicate()"
            ],
            [
                "nextPutIndex",
                "java.nio",
                "Buffer",
                "final int nextPutIndex()"
            ],
            [
                "markValue",
                "java.nio",
                "Buffer",
                "final int markValue()"
            ],
            [
                "checkIndex",
                "java.nio",
                "Buffer",
                "final int checkIndex(int arg0)"
            ],
            [
                "rewind",
                "java.nio",
                "Buffer",
                "public Buffer rewind()"
            ],
            [
                "arrayOffset",
                "java.nio",
                "Buffer",
                "public abstract int arrayOffset()"
            ],
            [
                "limit",
                "java.nio",
                "Buffer",
                "public Buffer limit(int arg0)"
            ],
            [
                "base",
                "java.nio",
                "Buffer",
                "abstract Object base()"
            ],
            [
                "scope",
                "java.nio",
                "Buffer",
                "final ScopedMemoryAccess.Scope scope()"
            ],
            [
                "clear",
                "java.nio",
                "Buffer",
                "public Buffer clear()"
            ],
            [
                "mark",
                "java.nio",
                "Buffer",
                "public Buffer mark()"
            ],
            [
                "limit",
                "java.nio",
                "Buffer",
                "public final int limit()"
            ],
            [
                "nextGetIndex",
                "java.nio",
                "Buffer",
                "final int nextGetIndex()"
            ],
            [
                "hasRemaining",
                "java.nio",
                "Buffer",
                "public final boolean hasRemaining()"
            ],
            [
                "position",
                "java.nio",
                "Buffer",
                "public Buffer position(int arg0)"
            ],
            [
                "slice",
                "java.nio",
                "Buffer",
                "public abstract Buffer slice(int arg0, int arg1)"
            ],
            [
                "isReadOnly",
                "java.nio",
                "Buffer",
                "public abstract boolean isReadOnly()"
            ],
            [
                "reset",
                "java.nio",
                "Buffer",
                "public Buffer reset()"
            ],
            [
                "checkIndex",
                "java.nio",
                "Buffer",
                "final int checkIndex(int arg0, int arg1)"
            ],
            [
                "isDirect",
                "java.nio",
                "Buffer",
                "public abstract boolean isDirect()"
            ],
            [
                "nextPutIndex",
                "java.nio",
                "Buffer",
                "final int nextPutIndex(int arg0)"
            ],
            [
                "capacity",
                "java.nio",
                "Buffer",
                "public final int capacity()"
            ],
            [
                "hasArray",
                "java.nio",
                "Buffer",
                "public abstract boolean hasArray()"
            ],
            [
                "array",
                "java.nio",
                "Buffer",
                "public abstract Object array()"
            ],
            [
                "slice",
                "java.nio",
                "Buffer",
                "public abstract Buffer slice()"
            ],
            [
                "nextGetIndex",
                "java.nio",
                "Buffer",
                "final int nextGetIndex(int arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "stream",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String stream;"
            ],
            [
                "streamBuffer",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer streamBuffer;"
            ],
            [
                "streamIdArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "byte[] streamIdArray;"
            ],
            [
                "host",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String host;"
            ],
            [
                "port",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected int port;"
            ],
            [
                "socket",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected Socket socket;"
            ],
            [
                "out",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected BufferedOutputStream out;"
            ],
            [
                "sourceId",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String sourceId = \"\";"
            ],
            [
                "sourceIdBuff",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer sourceIdBuff;"
            ],
            [
                "packer",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected NetStreamPacker packer = new DefaultPacker();"
            ],
            [
                "hb",
                "java.nio",
                "ByteBuffer",
                "final byte[] hb;"
            ],
            [
                "offset",
                "java.nio",
                "ByteBuffer",
                "final int offset;"
            ],
            [
                "isReadOnly",
                "java.nio",
                "ByteBuffer",
                "boolean isReadOnly;"
            ],
            [
                "bigEndian",
                "java.nio",
                "ByteBuffer",
                "boolean bigEndian;"
            ],
            [
                "nativeByteOrder",
                "java.nio",
                "ByteBuffer",
                "boolean nativeByteOrder;"
            ],
            [
                "address",
                "java.nio",
                "Buffer",
                "long address;"
            ],
            [
                "segment",
                "java.nio",
                "Buffer",
                "final MemorySegmentProxy segment;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3863,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream.netstream",
        "className": "NetStreamSender",
        "javadocTag": "@param buff",
        "methodJavadoc": "    /**\n\t * @param buff\n\t */",
        "methodSourceCode": "private void doSend(ByteBuffer buff){\n    if (socket.isClosed()) {\n        System.err.println(\"NetStreamSender : can't send. The socket is closed.\");\n    } else {\n        buff.rewind();\n        //outBuffer(buff);\n        ByteBuffer buffer = packer.packMessage(buff);\n        ByteBuffer sizeBuffer = packer.packMessageSize(buffer.capacity());\n        // real sending\n        try {\n            out.write(sizeBuffer.array(), 0, sizeBuffer.capacity());\n            out.write(buffer.array(), 0, buffer.capacity());\n            out.flush();\n        } catch (IOException e) {\n            try {\n                socket.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            System.err.printf(\"socket error : %s\\n\", e.getMessage());\n        }\n    }\n}",
        "classJavadoc": "/**\n * <p>\n * This class implements a sender according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamReceiver\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamSender.java\n * @since Aug 10, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\nimport org.graphstream.stream.Sink;\nimport org.graphstream.stream.netstream.packing.NetStreamPacker;\n\n/**\n * <p>\n * This class implements a sender according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamReceiver\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamSender.java\n * @since Aug 10, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */\npublic class NetStreamSender implements Sink {\n\tprivate static ByteBuffer NULL_BUFFER = ByteBuffer.allocate(0);\n\t\n\tprotected String stream;\n\tprotected ByteBuffer streamBuffer;\n\tbyte[] streamIdArray;\n\tprotected String host;\n\tprotected int port;\n\tprotected Socket socket;\n\tprotected BufferedOutputStream out;\n\n\tprotected String sourceId = \"\";\n\tprotected ByteBuffer sourceIdBuff;\n\n\tclass DefaultPacker extends NetStreamPacker {\n\t\tByteBuffer sizeBuffer = ByteBuffer.allocate(4);\n\n\t\t@Override\n\t\tpublic ByteBuffer packMessage(ByteBuffer buffer, int startIndex,\n\t\t\t\tint endIndex) {\n\t\t\treturn buffer;\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBuffer packMessageSize(int capacity) {\n\t\t\tsizeBuffer.rewind();\n\t\t\tsizeBuffer.putInt(capacity);\n\t\t\treturn sizeBuffer;\n\t\t}\n\n\t};\n\n\tprotected NetStreamPacker packer = new DefaultPacker();\n\n\tpublic NetStreamSender(String host, int port) throws UnknownHostException,\n\t\t\tIOException {\n\t\tthis(\"default\", host, port);\n\t}\n\tpublic NetStreamSender(int port) throws UnknownHostException, IOException {\n\t\tthis(\"default\", \"localhost\", port);\n\t}\n\n\tpublic NetStreamSender(String stream, String host, int port)\n\t\t\tthrows UnknownHostException, IOException {\n\t\tthis.stream = stream;\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tsetStream(stream);\n\t\t\n\t\tconnect();\n\t\t\n\t}\n\t\n\t/**\n\t * @param stream2\n\t */\n\tpublic void setStream(String stream) {\n\t\tstreamIdArray = stream.getBytes(Charset.forName(\"UTF-8\"));\n\t\tstreamBuffer = encodeString(stream);\n\t\t\n\t\t\n\t}\n\tpublic NetStreamSender(Socket socket) throws IOException {\n\t\tthis(\"default\", socket);\n\t}\n\t\n\tpublic NetStreamSender(String stream, Socket socket) throws IOException {\n\t\tthis.host = socket.getInetAddress().getHostName();\n\t\tthis.port = socket.getPort();\n\t\tthis.socket = socket;\n\t\tthis.out = new BufferedOutputStream(socket.getOutputStream());\n\t\tthis.streamIdArray = stream.getBytes(Charset.forName(\"UTF-8\"));\n\t}\n\n\t/**\n\t * Sets an optional NetStreamPaker whose \"pack\" method will be called on\n\t * each message.\n\t * \n\t * a Packer can do extra encoding on the all byte array message, it may also\n\t * crypt things.\n\t * \n\t * @param paker\n\t *            The packer object\n\t */\n\tpublic void setPacker(NetStreamPacker paker) {\n\t\tthis.packer = paker;\n\t}\n\tpublic void removePacker() {\n\t\tpacker = new DefaultPacker();\n\t}\n\n\tprotected void connect() throws UnknownHostException, IOException {\n\n\t\tsocket = new Socket(host, port);\n\t\tout = new BufferedOutputStream(socket.getOutputStream());\n\n\t}\n\n\tprotected int getType(Object value) {\n\t\tint valueType = NetStreamConstants.TYPE_UNKNOWN;\n\t\t\n\t\tif (value == null)\n\t\t\treturn NetStreamConstants.TYPE_NULL;\n\t\t\n\t\tClass<?> valueClass = value.getClass();\n\t\tboolean isArray = valueClass.isArray();\n\t\tif (isArray) {\n\t\t\tvalueClass = ((Object[]) value)[0].getClass();\n\t\t}\n\t\tif (valueClass.equals(Boolean.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BOOLEAN_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BOOLEAN;\n\t\t\t}\n\t\t} else if (valueClass.equals(Byte.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BYTE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BYTE;\n\t\t\t}\n\t\t} else if (valueClass.equals(Short.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_SHORT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_SHORT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Integer.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_INT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_INT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Long.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_LONG_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_LONG;\n\t\t\t}\n\t\t} else if (valueClass.equals(Float.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_FLOAT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_FLOAT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Double.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_DOUBLE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_DOUBLE;\n\t\t\t}\n\t\t} else if (valueClass.equals(String.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_STRING;\n\t\t\t}\n\t\t} else \n\t\t\tSystem.err.printf(\"[warning] can not find type of %s\\n\", valueClass);\n\t\t// System.out.println(\"ValueType=\"+valueType+\" \"+value.getClass());\n\t\treturn valueType;\n\t}\n\t\n\tprotected ByteBuffer encodeValue(Object in, int valueType) {\n\n\t\tif (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n\t\t\treturn encodeBoolean(in);\n\t\t} else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n\t\t\treturn encodeBooleanArray(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE == valueType) {\n\t\t\treturn encodeByte(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n\t\t\treturn encodeByteArray(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT == valueType) {\n\t\t\treturn encodeShort(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n\t\t\treturn encodeShortArray(in);\n\t\t} else if (NetStreamConstants.TYPE_INT == valueType) {\n\t\t\treturn encodeInt(in);\n\t\t} else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n\t\t\treturn encodeIntArray(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG == valueType) {\n\t\t\treturn encodeLong(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n\t\t\treturn encodeLongArray(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n\t\t\treturn encodeFloat(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n\t\t\treturn encodeFloatArray(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n\t\t\treturn encodeDouble(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n\t\t\treturn encodeDoubleArray(in);\n\t\t} else if (NetStreamConstants.TYPE_STRING == valueType) {\n\t\t\treturn encodeString(in);\n\t\t} else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n\t\t\treturn encodeArray(in);\n\t\t} else if (NetStreamConstants.TYPE_NULL == valueType) {\n\t\t\treturn NULL_BUFFER;\n\t\t}\n\t\t\n\t\tSystem.err.printf(\"[warning] unknown value type %d\\n\", valueType);\n\t\t\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeArray(Object in) {\n\t\t// TODO...\n\t\treturn null;\n\t}\n\n\t/*\n\tprivate void outBuffer(ByteBuffer buf){\n\t\tSystem.out.println(buf.toString());\n\t\tint nbytes = buf.capacity();\n\t\tint at = buf.position();\n\t\tfor(int i=0; i< nbytes; i++){\n\t\t\tint bt = buf.get(at+i);\n\t\t\tif (bt < 0) bt = (bt & 127) + (bt & 128); \n\t\t\tSystem.out.printf(\"%d \", bt);\n\t\t}\n\t\tSystem.out.println();\n\t}*/\n\t\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeString(Object in) {\n\t\t//System.out.println(\"They want me to encode this string: \"+in);\n\t\tString s = (String) in;\n\t\tbyte[] data = s.getBytes(Charset.forName(\"UTF-8\"));\n\t\t\n\t\tByteBuffer lenBuff = encodeUnsignedVarint(data.length);\n\t\t//outBuffer(lenBuff);\n\t\tByteBuffer bb = ByteBuffer.allocate(lenBuff.capacity() + data.length);\n\t\tbb.put(lenBuff).put(data);\n\t\tbb.rewind();\n\t\t//outBuffer(bb);\n\t\t\n\t\treturn bb;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeDoubleArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length * 8);\n\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.putDouble((Double) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The double to encode\n\t * @return ByteBuffer with encoded double in it\n\t */\n\tprotected ByteBuffer encodeDouble(Object in) {\n\t\tByteBuffer bb = ByteBuffer.allocate(8).putDouble((Double) in);\n\t\tbb.rewind();\n\t\treturn bb;\n\t}\n\n\t/**\n\t * @param in The float array to encode\n\t * @return ByteBuffer with encoded float array in it\n\t */\n\tprotected ByteBuffer encodeFloatArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\t\t\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length * 4);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.putFloat((Float) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The float to encode\n\t * @return ByteBuffer with encoded float in it\n\t */\n\tprotected ByteBuffer encodeFloat(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(4);\n\t\tb.putFloat(((Float) in));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The long array to encode\n\t * @return ByteBuffer with encoded long array in it\n\t */\n\tprotected ByteBuffer encodeLongArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in The long to encode\n\t * @return ByteBuffer with encoded long in it\n\t */\n\tprotected ByteBuffer encodeLong(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in The integer array to encode\n\t * @return ByteBuffer with encoded integer array in it\n\t */\n\tprotected ByteBuffer encodeIntArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in The integer to encode\n\t * @return ByteBuffer with encoded integer in it\n\t */\n\tprotected ByteBuffer encodeInt(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeShortArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeShort(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeByteArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.put((Byte) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeByte(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(1);\n\t\tb.put(((Byte) in));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeBooleanArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.put((byte) ((Boolean) data[i] == false ? 0 : 1));\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeBoolean(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(1);\n\t\tb.put((byte) (((Boolean) in) == false ? 0 : 1));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\tprivate int varintSize(long data){\n\t\t\n\t\t// 7 bits -> 127\n\t\tif(data < (1L << 7)){\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t// 14 bits -> 16383\n\t\tif(data < (1L << 14)){\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t\t// 21 bits -> 2097151\n\t\tif(data < (1L << 21)){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\t// 28 bits -> 268435455\n\t\tif(data < (1L << 28)){\n\t\t\treturn 4;\n\t\t}\n\n\t\t// 35 bits -> 34359738367\n\t\tif(data < (1L << 35)){\n\t\t\treturn 5;\n\t\t}\n\n\t\t// 42 bits -> 4398046511103\n\t\tif(data < (1L << 42)){\n\t\t\treturn 6;\n\t\t}\n\t\t\n\t\t// 49 bits -> 562949953421311\n\t\tif(data < (1L << 49)){\n\t\t\treturn 7;\n\t\t}\n\t\t\n\t\t// 56 bits -> 72057594037927935\n\t\tif(data < (1L << 56)){\n\t\t\treturn 8;\n\t\t}\t\n\t\t\n\t\treturn 9;\n\t}\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeVarint(Object in) {\n\t\tlong data = ((Number)in).longValue();\n\t\t\n\t\t// signed integers encoding\n\t\t// (n << 1) ^ (n >> 31)\n\t\t// OK but java's negative values are two's complements...\n\t\t\n\t\treturn encodeUnsignedVarint(data>=0?(data<<1):((Math.abs(data) << 1) ^ 1));\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeVarintArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\t\tint[] sizes = new int[data.length];\n\t\tlong[] zigzags = new long[data.length];\n\t\tint sumsizes=0;\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tlong datum = ((Number)data[i]).longValue();\n\t\t\t// signed integers encoding\n\t\t\t// (n << 1) ^ (n >> 31)\n\t\t\t// OK but java's negative values are two's complements...\n\t\t\tzigzags[i] = datum>0?(datum<<1):((Math.abs(datum) << 1) ^ 1);\n\t\t\t\n\t\t\tsizes[i] = varintSize(zigzags[i]);\n\t\t\tsumsizes+=sizes[i];\n\t\t\t//System.out.printf(\"i=%d, zigzag=%d, size=%d\\n\",i, zigzags[i], sizes[i]);\n\t\t}\t\t\n\t\t\n\t\t// the size of the size!\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + sumsizes);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\t\t\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tputVarint(b, zigzags[i], sizes[i]);\n\t\t}\n\t\tb.rewind();\n\t\t//outBuffer(b);\n\t\treturn b;\n\t}\n\t\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeUnsignedVarint(Object in) {\n\t\tlong data = ((Number)in).longValue();\n\t\t\n\t\tint size = varintSize(data);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(size);\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tint head=128;\n\t\t\tif(i==size-1) head = 0;\n\t\t\tlong b = ((data >> (7*i)) & 127) ^ head;\n\t\t\tbuff.put((byte)(b & 255 ));\n\t\t}\n\t\tbuff.rewind();\n\t\treturn  buff;\n\t}\n\n\t\n\t/**\n\t * @param b\n\t * @param sumsizes\n\t * @param ssize\n\t */\n\tprivate void putVarint(ByteBuffer buffer, long number, int byteSize) {\n\t\tfor(int i = 0; i < byteSize; i++){\n\t\t\tint head=128;\n\t\t\tif(i==byteSize-1) head = 0;\n\t\t\tlong b = ((number >> (7*i)) & 127) ^ head;\n\t\t\tbuffer.put((byte)(b & 255 ));\n\t\t}\n\t}\n\t\n\t/**\n\t * @param buff\n\t */\n\tprivate void doSend(ByteBuffer buff) {\n\n\t\tif (socket.isClosed()) {\n\t\t\tSystem.err\n\t\t\t\t\t.println(\"NetStreamSender : can't send. The socket is closed.\");\n\t\t} else {\n\t\t\tbuff.rewind();\n\t\t\t//outBuffer(buff);\n\t\t\tByteBuffer buffer = packer.packMessage(buff);\n\t\t\tByteBuffer sizeBuffer = packer.packMessageSize(buffer.capacity());\n\t\n\t\t\t// real sending\n\t\t\ttry {\n\t\t\t\tout.write(sizeBuffer.array(), 0, sizeBuffer.capacity());\n\t\t\t\tout.write(buffer.array(), 0, buffer.capacity());\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\ttry {\n\t\t\t\t\tsocket.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.err.printf(\"socket error : %s\\n\", e.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeAdded(java.lang.String\n\t * , long, java.lang.String, java.lang.Object)\n\t */\n\tpublic void graphAttributeAdded(String sourceId, long timeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t\t\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint valueType = getType(value);\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity() + // attribute id\n\t\t\t\t1 + // attr type\n\t\t\t\tvalueBuff.capacity()); // attr value\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\tbuff\n\t\t\t.put(streamBuffer)\n\t\t\t.put((byte) NetStreamConstants.EVENT_ADD_GRAPH_ATTR)\n\t\t\t.put(sourceIdBuff)\n\t\t\t.put(encodeUnsignedVarint(timeId))\n\t\t\t.put(attrBuff)\n\t\t\t.put((byte) valueType)\n\t\t\t.put(valueBuff);\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeChanged(java.lang.\n\t * String, long, java.lang.String, java.lang.Object, java.lang.Object)\n\t */\n\tpublic void graphAttributeChanged(String sourceId, long timeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\t\t\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity() + // attribute id\n\t\t\t\t1 + // attr type\n\t\t\t\toldValueBuff.capacity() + // attr value\n\t\t\t\t1 + // attr type\n\t\t\t\tnewValueBuff.capacity()); // attr value\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\tbuff\n\t\t\t.put(streamBuffer)\n\t\t\t.put((byte) NetStreamConstants.EVENT_CHG_GRAPH_ATTR)\n\t\t\t.put(sourceIdBuff)\n\t\t\t.put(encodeUnsignedVarint(timeId))\n\t\t\t.put(attrBuff)\n\t\t\t.put((byte) oldValueType)\n\t\t\t.put(oldValueBuff)\n\t\t\t.put((byte) newValueType)\n\t\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeRemoved(java.lang.\n\t * String, long, java.lang.String)\n\t */\n\tpublic void graphAttributeRemoved(String sourceId, long timeId,\n\t\t\tString attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity()\n\t\t\t\t); // attribute id\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\t\t\t\t\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_GRAPH_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(attrBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeAdded(java.lang.String,\n\t * long, java.lang.String, java.lang.String, java.lang.Object)\n\t */\n\tpublic void nodeAttributeAdded(String sourceId, long timeId, String nodeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint valueType = getType(value);\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\tvalueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) valueType)\n\t\t.put(valueBuff);\n\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeChanged(java.lang.String\n\t * , long, java.lang.String, java.lang.String, java.lang.Object,\n\t * java.lang.Object)\n\t */\n\tpublic void nodeAttributeChanged(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object oldValue, Object newValue) {\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\t\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\t\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\t\t\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\toldValueBuff.capacity() + // value\n\t\t\t\t1 + // value type\n\t\t\t\tnewValueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CHG_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) oldValueType)\n\t\t.put(oldValueBuff)\n\t\t.put((byte) newValueType)\n\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeRemoved(java.lang.String\n\t * , long, java.lang.String, java.lang.String)\n\t */\n\tpublic void nodeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() // attribute\n\t\t);\n\t\t\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff);\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeAdded(java.lang.String,\n\t * long, java.lang.String, java.lang.String, java.lang.Object)\n\t */\n\tpublic void edgeAttributeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tint valueType = getType(value);\n\t\t\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\tvalueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) valueType) // value type\n\t\t.put(valueBuff);\n\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeChanged(java.lang.String\n\t * , long, java.lang.String, java.lang.String, java.lang.Object,\n\t * java.lang.Object)\n\t */\n\tpublic void edgeAttributeChanged(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object oldValue, Object newValue) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\toldValueBuff.capacity() + // value\n\t\t\t\t1 + // value type\n\t\t\t\tnewValueBuff.capacity()  // value\n\t\t);\n\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CHG_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) oldValueType)\n\t\t.put(oldValueBuff)\n\t\t.put((byte) newValueType)\n\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeRemoved(java.lang.String\n\t * , long, java.lang.String, java.lang.String)\n\t */\n\tpublic void edgeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() // attribute\n\t\t);\n\t\t\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff);\n\t\t\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#nodeAdded(java.lang.String, long,\n\t * java.lang.String)\n\t */\n\tpublic void nodeAdded(String sourceId, long timeId, String nodeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\t\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() // nodeId \n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_NODE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff);\n\t\t\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#nodeRemoved(java.lang.String,\n\t * long, java.lang.String)\n\t */\n\tpublic void nodeRemoved(String sourceId, long timeId, String nodeId) {\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() // nodeId \n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_NODE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff);\n\t\t\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#edgeAdded(java.lang.String, long,\n\t * java.lang.String, java.lang.String, java.lang.String, boolean)\n\t */\n\tpublic void edgeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer fromNodeBuff = encodeString(fromNodeId);\n\t\tByteBuffer toNodeBuff = encodeString(toNodeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // edge\n\t\t\t\tfromNodeBuff.capacity() + // from nodeId\n\t\t\t\ttoNodeBuff.capacity() + // to nodeId \n\t\t\t\t1 // direction\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_EDGE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(fromNodeBuff)\n\t\t.put(toNodeBuff)\n\t\t.put((byte) (!directed ? 0 : 1));\n\t\t\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#edgeRemoved(java.lang.String,\n\t * long, java.lang.String)\n\t */\n\tpublic void edgeRemoved(String sourceId, long timeId, String edgeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity()  // edge\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_EDGE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#graphCleared(java.lang.String,\n\t * long)\n\t */\n\tpublic void graphCleared(String sourceId, long timeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId)\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CLEARED)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId));\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#stepBegins(java.lang.String,\n\t * long, double)\n\t */\n\tpublic void stepBegins(String sourceId, long timeId, double step) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) +\n\t\t\t\t8 // time\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_STEP)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.putDouble(step);\n\t\t\n\t\t\n\t\tdoSend(buff);\n\t}\n\n\t/**\n\t * Force the connection to close (properly) with the server\n\t * \n\t * @throws IOException\n\t */\n\tpublic void close() throws IOException {\n\t\tsocket.close();\n\t}\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "buff",
                "java.nio",
                "ByteBuffer"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "encodeString",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/*\n\tprivate void outBuffer(ByteBuffer buf){\n\t\tSystem.out.println(buf.toString());\n\t\tint nbytes = buf.capacity();\n\t\tint at = buf.position();\n\t\tfor(int i=0; i< nbytes; i++){\n\t\t\tint bt = buf.get(at+i);\n\t\t\tif (bt < 0) bt = (bt & 127) + (bt & 128); \n\t\t\tSystem.out.printf(\"%d \", bt);\n\t\t}\n\t\tSystem.out.println();\n\t}*/\n/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeString(Object in) {\n    //System.out.println(\"They want me to encode this string: \"+in);\n    String s = (String) in;\n    byte[] data = s.getBytes(Charset.forName(\"UTF-8\"));\n    ByteBuffer lenBuff = encodeUnsignedVarint(data.length);\n    //outBuffer(lenBuff);\n    ByteBuffer bb = ByteBuffer.allocate(lenBuff.capacity() + data.length);\n    bb.put(lenBuff).put(data);\n    bb.rewind();\n    //outBuffer(bb);\n    return bb;\n}"
            ],
            [
                "encodeByteArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeByteArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.put((Byte) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeValue",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer encodeValue(Object in, int valueType) {\n    if (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n        return encodeBoolean(in);\n    } else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n        return encodeBooleanArray(in);\n    } else if (NetStreamConstants.TYPE_BYTE == valueType) {\n        return encodeByte(in);\n    } else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n        return encodeByteArray(in);\n    } else if (NetStreamConstants.TYPE_SHORT == valueType) {\n        return encodeShort(in);\n    } else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n        return encodeShortArray(in);\n    } else if (NetStreamConstants.TYPE_INT == valueType) {\n        return encodeInt(in);\n    } else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n        return encodeIntArray(in);\n    } else if (NetStreamConstants.TYPE_LONG == valueType) {\n        return encodeLong(in);\n    } else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n        return encodeLongArray(in);\n    } else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n        return encodeFloat(in);\n    } else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n        return encodeFloatArray(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n        return encodeDouble(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n        return encodeDoubleArray(in);\n    } else if (NetStreamConstants.TYPE_STRING == valueType) {\n        return encodeString(in);\n    } else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n        return encodeArray(in);\n    } else if (NetStreamConstants.TYPE_NULL == valueType) {\n        return NULL_BUFFER;\n    }\n    System.err.printf(\"[warning] unknown value type %d\\n\", valueType);\n    return null;\n}"
            ],
            [
                "encodeArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeArray(Object in) {\n    // TODO...\n    return null;\n}"
            ],
            [
                "encodeBooleanArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeBooleanArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.put((byte) ((Boolean) data[i] == false ? 0 : 1));\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeShortArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeShortArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "encodeLong",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The long to encode\n * @return ByteBuffer with encoded long in it\n */\nprotected ByteBuffer encodeLong(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeBoolean",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeBoolean(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(1);\n    b.put((byte) (((Boolean) in) == false ? 0 : 1));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeFloatArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The float array to encode\n * @return ByteBuffer with encoded float array in it\n */\nprotected ByteBuffer encodeFloatArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length * 4);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.putFloat((Float) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "encodeFloat",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The float to encode\n * @return ByteBuffer with encoded float in it\n */\nprotected ByteBuffer encodeFloat(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(4);\n    b.putFloat(((Float) in));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeInt",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The integer to encode\n * @return ByteBuffer with encoded integer in it\n */\nprotected ByteBuffer encodeInt(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeUnsignedVarint",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeUnsignedVarint(Object in) {\n    long data = ((Number) in).longValue();\n    int size = varintSize(data);\n    ByteBuffer buff = ByteBuffer.allocate(size);\n    for (int i = 0; i < size; i++) {\n        int head = 128;\n        if (i == size - 1)\n            head = 0;\n        long b = ((data >> (7 * i)) & 127) ^ head;\n        buff.put((byte) (b & 255));\n    }\n    buff.rewind();\n    return buff;\n}"
            ],
            [
                "encodeVarintArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeVarintArray(Object in) {\n    Object[] data = (Object[]) in;\n    int[] sizes = new int[data.length];\n    long[] zigzags = new long[data.length];\n    int sumsizes = 0;\n    for (int i = 0; i < data.length; i++) {\n        long datum = ((Number) data[i]).longValue();\n        // signed integers encoding\n        // (n << 1) ^ (n >> 31)\n        // OK but java's negative values are two's complements...\n        zigzags[i] = datum > 0 ? (datum << 1) : ((Math.abs(datum) << 1) ^ 1);\n        sizes[i] = varintSize(zigzags[i]);\n        sumsizes += sizes[i];\n        //System.out.printf(\"i=%d, zigzag=%d, size=%d\\n\",i, zigzags[i], sizes[i]);\n    }\n    // the size of the size!\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + sumsizes);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        putVarint(b, zigzags[i], sizes[i]);\n    }\n    b.rewind();\n    //outBuffer(b);\n    return b;\n}"
            ],
            [
                "getType",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected int getType(Object value) {\n    int valueType = NetStreamConstants.TYPE_UNKNOWN;\n    if (value == null)\n        return NetStreamConstants.TYPE_NULL;\n    Class<?> valueClass = value.getClass();\n    boolean isArray = valueClass.isArray();\n    if (isArray) {\n        valueClass = ((Object[]) value)[0].getClass();\n    }\n    if (valueClass.equals(Boolean.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_BOOLEAN_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_BOOLEAN;\n        }\n    } else if (valueClass.equals(Byte.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_BYTE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_BYTE;\n        }\n    } else if (valueClass.equals(Short.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_SHORT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_SHORT;\n        }\n    } else if (valueClass.equals(Integer.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_INT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_INT;\n        }\n    } else if (valueClass.equals(Long.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_LONG_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_LONG;\n        }\n    } else if (valueClass.equals(Float.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_FLOAT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_FLOAT;\n        }\n    } else if (valueClass.equals(Double.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_DOUBLE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_DOUBLE;\n        }\n    } else if (valueClass.equals(String.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_STRING;\n        }\n    } else\n        System.err.printf(\"[warning] can not find type of %s\\n\", valueClass);\n    // System.out.println(\"ValueType=\"+valueType+\" \"+value.getClass());\n    return valueType;\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "encodeByte",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeByte(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(1);\n    b.put(((Byte) in));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeDoubleArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeDoubleArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length * 8);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.putDouble((Double) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeLongArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The long array to encode\n * @return ByteBuffer with encoded long array in it\n */\nprotected ByteBuffer encodeLongArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "encodeShort",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeShort(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeVarint",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeVarint(Object in) {\n    long data = ((Number) in).longValue();\n    // signed integers encoding\n    // (n << 1) ^ (n >> 31)\n    // OK but java's negative values are two's complements...\n    return encodeUnsignedVarint(data >= 0 ? (data << 1) : ((Math.abs(data) << 1) ^ 1));\n}"
            ],
            [
                "encodeIntArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The integer array to encode\n * @return ByteBuffer with encoded integer array in it\n */\nprotected ByteBuffer encodeIntArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "encodeDouble",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The double to encode\n * @return ByteBuffer with encoded double in it\n */\nprotected ByteBuffer encodeDouble(Object in) {\n    ByteBuffer bb = ByteBuffer.allocate(8).putDouble((Double) in);\n    bb.rewind();\n    return bb;\n}"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public final ByteBuffer put(byte[] arg0)"
            ],
            [
                "order",
                "java.nio",
                "ByteBuffer",
                "public final ByteOrder order()"
            ],
            [
                "compact",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer compact()"
            ],
            [
                "base",
                "java.nio",
                "ByteBuffer",
                "Object base()"
            ],
            [
                "asFloatBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract FloatBuffer asFloatBuffer()"
            ],
            [
                "getShort",
                "java.nio",
                "ByteBuffer",
                "public abstract short getShort()"
            ],
            [
                "rewind",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer rewind()"
            ],
            [
                "asLongBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract LongBuffer asLongBuffer()"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(int arg0, byte[] arg1, int arg2, int arg3)"
            ],
            [
                "getInt",
                "java.nio",
                "ByteBuffer",
                "public abstract int getInt()"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer put(int arg0, byte arg1)"
            ],
            [
                "getShort",
                "java.nio",
                "ByteBuffer",
                "public abstract short getShort(int arg0)"
            ],
            [
                "putFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putFloat(float arg0)"
            ],
            [
                "arrayOffset",
                "java.nio",
                "ByteBuffer",
                "public final int arrayOffset()"
            ],
            [
                "hashCode",
                "java.nio",
                "ByteBuffer",
                "public int hashCode()"
            ],
            [
                "getFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract float getFloat(int arg0)"
            ],
            [
                "putInt",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putInt(int arg0, int arg1)"
            ],
            [
                "getChar",
                "java.nio",
                "ByteBuffer",
                "public abstract char getChar(int arg0)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer put(byte arg0)"
            ],
            [
                "clear",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer clear()"
            ],
            [
                "putLong",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putLong(long arg0)"
            ],
            [
                "array",
                "java.nio",
                "ByteBuffer",
                "public final byte[] array()"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(byte[] arg0, int arg1, int arg2)"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(int arg0, byte[] arg1)"
            ],
            [
                "asIntBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract IntBuffer asIntBuffer()"
            ],
            [
                "slice",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer slice()"
            ],
            [
                "mismatch",
                "java.nio",
                "ByteBuffer",
                "public int mismatch(ByteBuffer arg0)"
            ],
            [
                "putFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putFloat(int arg0, float arg1)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(byte[] arg0, int arg1, int arg2)"
            ],
            [
                "getChar",
                "java.nio",
                "ByteBuffer",
                "public abstract char getChar()"
            ],
            [
                "isDirect",
                "java.nio",
                "ByteBuffer",
                "public abstract boolean isDirect()"
            ],
            [
                "alignedSlice",
                "java.nio",
                "ByteBuffer",
                "public final ByteBuffer alignedSlice(int arg0)"
            ],
            [
                "asCharBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract CharBuffer asCharBuffer()"
            ],
            [
                "position",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer position(int arg0)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(ByteBuffer arg0)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(int arg0, ByteBuffer arg1, int arg2, int arg3)"
            ],
            [
                "getLong",
                "java.nio",
                "ByteBuffer",
                "public abstract long getLong()"
            ],
            [
                "limit",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer limit(int arg0)"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(int arg0, byte[] arg1, int arg2, int arg3)"
            ],
            [
                "getFloat",
                "java.nio",
                "ByteBuffer",
                "public abstract float getFloat()"
            ],
            [
                "toString",
                "java.nio",
                "ByteBuffer",
                "public String toString()"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public abstract byte get()"
            ],
            [
                "put",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer put(int arg0, byte[] arg1)"
            ],
            [
                "asReadOnlyBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer asReadOnlyBuffer()"
            ],
            [
                "flip",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer flip()"
            ],
            [
                "asShortBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract ShortBuffer asShortBuffer()"
            ],
            [
                "putChar",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putChar(char arg0)"
            ],
            [
                "reset",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer reset()"
            ],
            [
                "putDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putDouble(int arg0, double arg1)"
            ],
            [
                "equals",
                "java.nio",
                "ByteBuffer",
                "public boolean equals(Object arg0)"
            ],
            [
                "hasArray",
                "java.nio",
                "ByteBuffer",
                "public final boolean hasArray()"
            ],
            [
                "getDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract double getDouble(int arg0)"
            ],
            [
                "mark",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer mark()"
            ],
            [
                "putDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putDouble(double arg0)"
            ],
            [
                "getInt",
                "java.nio",
                "ByteBuffer",
                "public abstract int getInt(int arg0)"
            ],
            [
                "compareTo",
                "java.nio",
                "ByteBuffer",
                "public int compareTo(ByteBuffer arg0)"
            ],
            [
                "putShort",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putShort(short arg0)"
            ],
            [
                "getDouble",
                "java.nio",
                "ByteBuffer",
                "public abstract double getDouble()"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public ByteBuffer get(byte[] arg0)"
            ],
            [
                "get",
                "java.nio",
                "ByteBuffer",
                "public abstract byte get(int arg0)"
            ],
            [
                "getLong",
                "java.nio",
                "ByteBuffer",
                "public abstract long getLong(int arg0)"
            ],
            [
                "duplicate",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer duplicate()"
            ],
            [
                "putChar",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putChar(int arg0, char arg1)"
            ],
            [
                "slice",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer slice(int arg0, int arg1)"
            ],
            [
                "asDoubleBuffer",
                "java.nio",
                "ByteBuffer",
                "public abstract DoubleBuffer asDoubleBuffer()"
            ],
            [
                "putLong",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putLong(int arg0, long arg1)"
            ],
            [
                "putShort",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putShort(int arg0, short arg1)"
            ],
            [
                "alignmentOffset",
                "java.nio",
                "ByteBuffer",
                "public final int alignmentOffset(int arg0, int arg1)"
            ],
            [
                "putInt",
                "java.nio",
                "ByteBuffer",
                "public abstract ByteBuffer putInt(int arg0)"
            ],
            [
                "order",
                "java.nio",
                "ByteBuffer",
                "public final ByteBuffer order(ByteOrder arg0)"
            ],
            [
                "checkIndex",
                "java.nio",
                "Buffer",
                "final int checkIndex(int arg0)"
            ],
            [
                "limit",
                "java.nio",
                "Buffer",
                "public Buffer limit(int arg0)"
            ],
            [
                "nextGetIndex",
                "java.nio",
                "Buffer",
                "final int nextGetIndex()"
            ],
            [
                "nextGetIndex",
                "java.nio",
                "Buffer",
                "final int nextGetIndex(int arg0)"
            ],
            [
                "arrayOffset",
                "java.nio",
                "Buffer",
                "public abstract int arrayOffset()"
            ],
            [
                "duplicate",
                "java.nio",
                "Buffer",
                "public abstract Buffer duplicate()"
            ],
            [
                "hasRemaining",
                "java.nio",
                "Buffer",
                "public final boolean hasRemaining()"
            ],
            [
                "isDirect",
                "java.nio",
                "Buffer",
                "public abstract boolean isDirect()"
            ],
            [
                "nextPutIndex",
                "java.nio",
                "Buffer",
                "final int nextPutIndex()"
            ],
            [
                "base",
                "java.nio",
                "Buffer",
                "abstract Object base()"
            ],
            [
                "capacity",
                "java.nio",
                "Buffer",
                "public final int capacity()"
            ],
            [
                "position",
                "java.nio",
                "Buffer",
                "public Buffer position(int arg0)"
            ],
            [
                "slice",
                "java.nio",
                "Buffer",
                "public abstract Buffer slice(int arg0, int arg1)"
            ],
            [
                "position",
                "java.nio",
                "Buffer",
                "public final int position()"
            ],
            [
                "reset",
                "java.nio",
                "Buffer",
                "public Buffer reset()"
            ],
            [
                "remaining",
                "java.nio",
                "Buffer",
                "public final int remaining()"
            ],
            [
                "clear",
                "java.nio",
                "Buffer",
                "public Buffer clear()"
            ],
            [
                "isReadOnly",
                "java.nio",
                "Buffer",
                "public abstract boolean isReadOnly()"
            ],
            [
                "mark",
                "java.nio",
                "Buffer",
                "public Buffer mark()"
            ],
            [
                "nextPutIndex",
                "java.nio",
                "Buffer",
                "final int nextPutIndex(int arg0)"
            ],
            [
                "limit",
                "java.nio",
                "Buffer",
                "public final int limit()"
            ],
            [
                "hasArray",
                "java.nio",
                "Buffer",
                "public abstract boolean hasArray()"
            ],
            [
                "scope",
                "java.nio",
                "Buffer",
                "final ScopedMemoryAccess.Scope scope()"
            ],
            [
                "flip",
                "java.nio",
                "Buffer",
                "public Buffer flip()"
            ],
            [
                "rewind",
                "java.nio",
                "Buffer",
                "public Buffer rewind()"
            ],
            [
                "checkIndex",
                "java.nio",
                "Buffer",
                "final int checkIndex(int arg0, int arg1)"
            ],
            [
                "array",
                "java.nio",
                "Buffer",
                "public abstract Object array()"
            ],
            [
                "slice",
                "java.nio",
                "Buffer",
                "public abstract Buffer slice()"
            ],
            [
                "markValue",
                "java.nio",
                "Buffer",
                "final int markValue()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "stream",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String stream;"
            ],
            [
                "streamBuffer",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer streamBuffer;"
            ],
            [
                "streamIdArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "byte[] streamIdArray;"
            ],
            [
                "host",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String host;"
            ],
            [
                "port",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected int port;"
            ],
            [
                "socket",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected Socket socket;"
            ],
            [
                "out",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected BufferedOutputStream out;"
            ],
            [
                "sourceId",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String sourceId = \"\";"
            ],
            [
                "sourceIdBuff",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer sourceIdBuff;"
            ],
            [
                "packer",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected NetStreamPacker packer = new DefaultPacker();"
            ],
            [
                "hb",
                "java.nio",
                "ByteBuffer",
                "final byte[] hb;"
            ],
            [
                "offset",
                "java.nio",
                "ByteBuffer",
                "final int offset;"
            ],
            [
                "isReadOnly",
                "java.nio",
                "ByteBuffer",
                "boolean isReadOnly;"
            ],
            [
                "bigEndian",
                "java.nio",
                "ByteBuffer",
                "boolean bigEndian;"
            ],
            [
                "nativeByteOrder",
                "java.nio",
                "ByteBuffer",
                "boolean nativeByteOrder;"
            ],
            [
                "address",
                "java.nio",
                "Buffer",
                "long address;"
            ],
            [
                "segment",
                "java.nio",
                "Buffer",
                "final MemorySegmentProxy segment;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3864,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream.netstream",
        "className": "NetStreamSender",
        "javadocTag": "@throws IOException",
        "methodJavadoc": "    /**\n\t * Force the connection to close (properly) with the server\n\t * \n\t * @throws IOException\n\t */",
        "methodSourceCode": "public void close() throws IOException{\n    socket.close();\n}",
        "classJavadoc": "/**\n * <p>\n * This class implements a sender according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamReceiver\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamSender.java\n * @since Aug 10, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n\nimport org.graphstream.stream.Sink;\nimport org.graphstream.stream.netstream.packing.NetStreamPacker;\n\n/**\n * <p>\n * This class implements a sender according to specifications the NetStream\n * protocol.\n * </p>\n * \n * <p>\n * See {@link NetStreamConstants} for a full description of the protocol, the\n * sender and the receiver.\n * </p>\n * \n * @see NetStreamConstants\n * @see NetStreamReceiver\n * \n * \n *      Copyright (c) 2010 University of Luxembourg\n * \n *      NetStreamSender.java\n * @since Aug 10, 2011\n * \n * @author Yoann Pign\u00e9\n * \n */\npublic class NetStreamSender implements Sink {\n\tprivate static ByteBuffer NULL_BUFFER = ByteBuffer.allocate(0);\n\t\n\tprotected String stream;\n\tprotected ByteBuffer streamBuffer;\n\tbyte[] streamIdArray;\n\tprotected String host;\n\tprotected int port;\n\tprotected Socket socket;\n\tprotected BufferedOutputStream out;\n\n\tprotected String sourceId = \"\";\n\tprotected ByteBuffer sourceIdBuff;\n\n\tclass DefaultPacker extends NetStreamPacker {\n\t\tByteBuffer sizeBuffer = ByteBuffer.allocate(4);\n\n\t\t@Override\n\t\tpublic ByteBuffer packMessage(ByteBuffer buffer, int startIndex,\n\t\t\t\tint endIndex) {\n\t\t\treturn buffer;\n\t\t}\n\n\t\t@Override\n\t\tpublic ByteBuffer packMessageSize(int capacity) {\n\t\t\tsizeBuffer.rewind();\n\t\t\tsizeBuffer.putInt(capacity);\n\t\t\treturn sizeBuffer;\n\t\t}\n\n\t};\n\n\tprotected NetStreamPacker packer = new DefaultPacker();\n\n\tpublic NetStreamSender(String host, int port) throws UnknownHostException,\n\t\t\tIOException {\n\t\tthis(\"default\", host, port);\n\t}\n\tpublic NetStreamSender(int port) throws UnknownHostException, IOException {\n\t\tthis(\"default\", \"localhost\", port);\n\t}\n\n\tpublic NetStreamSender(String stream, String host, int port)\n\t\t\tthrows UnknownHostException, IOException {\n\t\tthis.stream = stream;\n\t\tthis.host = host;\n\t\tthis.port = port;\n\t\tsetStream(stream);\n\t\t\n\t\tconnect();\n\t\t\n\t}\n\t\n\t/**\n\t * @param stream2\n\t */\n\tpublic void setStream(String stream) {\n\t\tstreamIdArray = stream.getBytes(Charset.forName(\"UTF-8\"));\n\t\tstreamBuffer = encodeString(stream);\n\t\t\n\t\t\n\t}\n\tpublic NetStreamSender(Socket socket) throws IOException {\n\t\tthis(\"default\", socket);\n\t}\n\t\n\tpublic NetStreamSender(String stream, Socket socket) throws IOException {\n\t\tthis.host = socket.getInetAddress().getHostName();\n\t\tthis.port = socket.getPort();\n\t\tthis.socket = socket;\n\t\tthis.out = new BufferedOutputStream(socket.getOutputStream());\n\t\tthis.streamIdArray = stream.getBytes(Charset.forName(\"UTF-8\"));\n\t}\n\n\t/**\n\t * Sets an optional NetStreamPaker whose \"pack\" method will be called on\n\t * each message.\n\t * \n\t * a Packer can do extra encoding on the all byte array message, it may also\n\t * crypt things.\n\t * \n\t * @param paker\n\t *            The packer object\n\t */\n\tpublic void setPacker(NetStreamPacker paker) {\n\t\tthis.packer = paker;\n\t}\n\tpublic void removePacker() {\n\t\tpacker = new DefaultPacker();\n\t}\n\n\tprotected void connect() throws UnknownHostException, IOException {\n\n\t\tsocket = new Socket(host, port);\n\t\tout = new BufferedOutputStream(socket.getOutputStream());\n\n\t}\n\n\tprotected int getType(Object value) {\n\t\tint valueType = NetStreamConstants.TYPE_UNKNOWN;\n\t\t\n\t\tif (value == null)\n\t\t\treturn NetStreamConstants.TYPE_NULL;\n\t\t\n\t\tClass<?> valueClass = value.getClass();\n\t\tboolean isArray = valueClass.isArray();\n\t\tif (isArray) {\n\t\t\tvalueClass = ((Object[]) value)[0].getClass();\n\t\t}\n\t\tif (valueClass.equals(Boolean.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BOOLEAN_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BOOLEAN;\n\t\t\t}\n\t\t} else if (valueClass.equals(Byte.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BYTE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_BYTE;\n\t\t\t}\n\t\t} else if (valueClass.equals(Short.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_SHORT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_SHORT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Integer.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_INT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_INT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Long.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_LONG_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_LONG;\n\t\t\t}\n\t\t} else if (valueClass.equals(Float.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_FLOAT_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_FLOAT;\n\t\t\t}\n\t\t} else if (valueClass.equals(Double.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_DOUBLE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_DOUBLE;\n\t\t\t}\n\t\t} else if (valueClass.equals(String.class)) {\n\t\t\tif (isArray) {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_ARRAY;\n\t\t\t} else {\n\t\t\t\tvalueType = NetStreamConstants.TYPE_STRING;\n\t\t\t}\n\t\t} else \n\t\t\tSystem.err.printf(\"[warning] can not find type of %s\\n\", valueClass);\n\t\t// System.out.println(\"ValueType=\"+valueType+\" \"+value.getClass());\n\t\treturn valueType;\n\t}\n\t\n\tprotected ByteBuffer encodeValue(Object in, int valueType) {\n\n\t\tif (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n\t\t\treturn encodeBoolean(in);\n\t\t} else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n\t\t\treturn encodeBooleanArray(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE == valueType) {\n\t\t\treturn encodeByte(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n\t\t\treturn encodeByteArray(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT == valueType) {\n\t\t\treturn encodeShort(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n\t\t\treturn encodeShortArray(in);\n\t\t} else if (NetStreamConstants.TYPE_INT == valueType) {\n\t\t\treturn encodeInt(in);\n\t\t} else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n\t\t\treturn encodeIntArray(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG == valueType) {\n\t\t\treturn encodeLong(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n\t\t\treturn encodeLongArray(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n\t\t\treturn encodeFloat(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n\t\t\treturn encodeFloatArray(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n\t\t\treturn encodeDouble(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n\t\t\treturn encodeDoubleArray(in);\n\t\t} else if (NetStreamConstants.TYPE_STRING == valueType) {\n\t\t\treturn encodeString(in);\n\t\t} else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n\t\t\treturn encodeArray(in);\n\t\t} else if (NetStreamConstants.TYPE_NULL == valueType) {\n\t\t\treturn NULL_BUFFER;\n\t\t}\n\t\t\n\t\tSystem.err.printf(\"[warning] unknown value type %d\\n\", valueType);\n\t\t\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeArray(Object in) {\n\t\t// TODO...\n\t\treturn null;\n\t}\n\n\t/*\n\tprivate void outBuffer(ByteBuffer buf){\n\t\tSystem.out.println(buf.toString());\n\t\tint nbytes = buf.capacity();\n\t\tint at = buf.position();\n\t\tfor(int i=0; i< nbytes; i++){\n\t\t\tint bt = buf.get(at+i);\n\t\t\tif (bt < 0) bt = (bt & 127) + (bt & 128); \n\t\t\tSystem.out.printf(\"%d \", bt);\n\t\t}\n\t\tSystem.out.println();\n\t}*/\n\t\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeString(Object in) {\n\t\t//System.out.println(\"They want me to encode this string: \"+in);\n\t\tString s = (String) in;\n\t\tbyte[] data = s.getBytes(Charset.forName(\"UTF-8\"));\n\t\t\n\t\tByteBuffer lenBuff = encodeUnsignedVarint(data.length);\n\t\t//outBuffer(lenBuff);\n\t\tByteBuffer bb = ByteBuffer.allocate(lenBuff.capacity() + data.length);\n\t\tbb.put(lenBuff).put(data);\n\t\tbb.rewind();\n\t\t//outBuffer(bb);\n\t\t\n\t\treturn bb;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeDoubleArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length * 8);\n\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.putDouble((Double) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The double to encode\n\t * @return ByteBuffer with encoded double in it\n\t */\n\tprotected ByteBuffer encodeDouble(Object in) {\n\t\tByteBuffer bb = ByteBuffer.allocate(8).putDouble((Double) in);\n\t\tbb.rewind();\n\t\treturn bb;\n\t}\n\n\t/**\n\t * @param in The float array to encode\n\t * @return ByteBuffer with encoded float array in it\n\t */\n\tprotected ByteBuffer encodeFloatArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\t\t\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length * 4);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.putFloat((Float) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The float to encode\n\t * @return ByteBuffer with encoded float in it\n\t */\n\tprotected ByteBuffer encodeFloat(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(4);\n\t\tb.putFloat(((Float) in));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in The long array to encode\n\t * @return ByteBuffer with encoded long array in it\n\t */\n\tprotected ByteBuffer encodeLongArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in The long to encode\n\t * @return ByteBuffer with encoded long in it\n\t */\n\tprotected ByteBuffer encodeLong(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in The integer array to encode\n\t * @return ByteBuffer with encoded integer array in it\n\t */\n\tprotected ByteBuffer encodeIntArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in The integer to encode\n\t * @return ByteBuffer with encoded integer in it\n\t */\n\tprotected ByteBuffer encodeInt(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeShortArray(Object in) {\n\t\treturn encodeVarintArray(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeShort(Object in) {\n\t\treturn encodeVarint(in);\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeByteArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.put((Byte) data[i]);\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeByte(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(1);\n\t\tb.put(((Byte) in));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeBooleanArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tb.put((byte) ((Boolean) data[i] == false ? 0 : 1));\n\t\t}\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeBoolean(Object in) {\n\t\tByteBuffer b = ByteBuffer.allocate(1);\n\t\tb.put((byte) (((Boolean) in) == false ? 0 : 1));\n\t\tb.rewind();\n\t\treturn b;\n\t}\n\n\tprivate int varintSize(long data){\n\t\t\n\t\t// 7 bits -> 127\n\t\tif(data < (1L << 7)){\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t// 14 bits -> 16383\n\t\tif(data < (1L << 14)){\n\t\t\treturn 2;\n\t\t}\n\t\t\n\t\t// 21 bits -> 2097151\n\t\tif(data < (1L << 21)){\n\t\t\treturn 3;\n\t\t}\n\t\t\n\t\t// 28 bits -> 268435455\n\t\tif(data < (1L << 28)){\n\t\t\treturn 4;\n\t\t}\n\n\t\t// 35 bits -> 34359738367\n\t\tif(data < (1L << 35)){\n\t\t\treturn 5;\n\t\t}\n\n\t\t// 42 bits -> 4398046511103\n\t\tif(data < (1L << 42)){\n\t\t\treturn 6;\n\t\t}\n\t\t\n\t\t// 49 bits -> 562949953421311\n\t\tif(data < (1L << 49)){\n\t\t\treturn 7;\n\t\t}\n\t\t\n\t\t// 56 bits -> 72057594037927935\n\t\tif(data < (1L << 56)){\n\t\t\treturn 8;\n\t\t}\t\n\t\t\n\t\treturn 9;\n\t}\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeVarint(Object in) {\n\t\tlong data = ((Number)in).longValue();\n\t\t\n\t\t// signed integers encoding\n\t\t// (n << 1) ^ (n >> 31)\n\t\t// OK but java's negative values are two's complements...\n\t\t\n\t\treturn encodeUnsignedVarint(data>=0?(data<<1):((Math.abs(data) << 1) ^ 1));\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeVarintArray(Object in) {\n\t\tObject[] data = (Object[]) in;\n\t\tint[] sizes = new int[data.length];\n\t\tlong[] zigzags = new long[data.length];\n\t\tint sumsizes=0;\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tlong datum = ((Number)data[i]).longValue();\n\t\t\t// signed integers encoding\n\t\t\t// (n << 1) ^ (n >> 31)\n\t\t\t// OK but java's negative values are two's complements...\n\t\t\tzigzags[i] = datum>0?(datum<<1):((Math.abs(datum) << 1) ^ 1);\n\t\t\t\n\t\t\tsizes[i] = varintSize(zigzags[i]);\n\t\t\tsumsizes+=sizes[i];\n\t\t\t//System.out.printf(\"i=%d, zigzag=%d, size=%d\\n\",i, zigzags[i], sizes[i]);\n\t\t}\t\t\n\t\t\n\t\t// the size of the size!\n\t\tint ssize = varintSize(data.length);\n\t\t\n\t\tByteBuffer b = ByteBuffer.allocate(ssize + sumsizes);\n\t\t\n\t\tputVarint(b, data.length, ssize);\n\t\t\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tputVarint(b, zigzags[i], sizes[i]);\n\t\t}\n\t\tb.rewind();\n\t\t//outBuffer(b);\n\t\treturn b;\n\t}\n\t\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected ByteBuffer encodeUnsignedVarint(Object in) {\n\t\tlong data = ((Number)in).longValue();\n\t\t\n\t\tint size = varintSize(data);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(size);\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tint head=128;\n\t\t\tif(i==size-1) head = 0;\n\t\t\tlong b = ((data >> (7*i)) & 127) ^ head;\n\t\t\tbuff.put((byte)(b & 255 ));\n\t\t}\n\t\tbuff.rewind();\n\t\treturn  buff;\n\t}\n\n\t\n\t/**\n\t * @param b\n\t * @param sumsizes\n\t * @param ssize\n\t */\n\tprivate void putVarint(ByteBuffer buffer, long number, int byteSize) {\n\t\tfor(int i = 0; i < byteSize; i++){\n\t\t\tint head=128;\n\t\t\tif(i==byteSize-1) head = 0;\n\t\t\tlong b = ((number >> (7*i)) & 127) ^ head;\n\t\t\tbuffer.put((byte)(b & 255 ));\n\t\t}\n\t}\n\t\n\t/**\n\t * @param buff\n\t */\n\tprivate void doSend(ByteBuffer buff) {\n\n\t\tif (socket.isClosed()) {\n\t\t\tSystem.err\n\t\t\t\t\t.println(\"NetStreamSender : can't send. The socket is closed.\");\n\t\t} else {\n\t\t\tbuff.rewind();\n\t\t\t//outBuffer(buff);\n\t\t\tByteBuffer buffer = packer.packMessage(buff);\n\t\t\tByteBuffer sizeBuffer = packer.packMessageSize(buffer.capacity());\n\t\n\t\t\t// real sending\n\t\t\ttry {\n\t\t\t\tout.write(sizeBuffer.array(), 0, sizeBuffer.capacity());\n\t\t\t\tout.write(buffer.array(), 0, buffer.capacity());\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\ttry {\n\t\t\t\t\tsocket.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.err.printf(\"socket error : %s\\n\", e.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeAdded(java.lang.String\n\t * , long, java.lang.String, java.lang.Object)\n\t */\n\tpublic void graphAttributeAdded(String sourceId, long timeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t\t\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint valueType = getType(value);\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity() + // attribute id\n\t\t\t\t1 + // attr type\n\t\t\t\tvalueBuff.capacity()); // attr value\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\tbuff\n\t\t\t.put(streamBuffer)\n\t\t\t.put((byte) NetStreamConstants.EVENT_ADD_GRAPH_ATTR)\n\t\t\t.put(sourceIdBuff)\n\t\t\t.put(encodeUnsignedVarint(timeId))\n\t\t\t.put(attrBuff)\n\t\t\t.put((byte) valueType)\n\t\t\t.put(valueBuff);\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeChanged(java.lang.\n\t * String, long, java.lang.String, java.lang.Object, java.lang.Object)\n\t */\n\tpublic void graphAttributeChanged(String sourceId, long timeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\t\t\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity() + // attribute id\n\t\t\t\t1 + // attr type\n\t\t\t\toldValueBuff.capacity() + // attr value\n\t\t\t\t1 + // attr type\n\t\t\t\tnewValueBuff.capacity()); // attr value\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\tbuff\n\t\t\t.put(streamBuffer)\n\t\t\t.put((byte) NetStreamConstants.EVENT_CHG_GRAPH_ATTR)\n\t\t\t.put(sourceIdBuff)\n\t\t\t.put(encodeUnsignedVarint(timeId))\n\t\t\t.put(attrBuff)\n\t\t\t.put((byte) oldValueType)\n\t\t\t.put(oldValueBuff)\n\t\t\t.put((byte) newValueType)\n\t\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#graphAttributeRemoved(java.lang.\n\t * String, long, java.lang.String)\n\t */\n\tpublic void graphAttributeRemoved(String sourceId, long timeId,\n\t\t\tString attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tattrBuff.capacity()\n\t\t\t\t); // attribute id\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\t\t\t\t\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_GRAPH_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(attrBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeAdded(java.lang.String,\n\t * long, java.lang.String, java.lang.String, java.lang.Object)\n\t */\n\tpublic void nodeAttributeAdded(String sourceId, long timeId, String nodeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint valueType = getType(value);\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\tvalueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) valueType)\n\t\t.put(valueBuff);\n\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeChanged(java.lang.String\n\t * , long, java.lang.String, java.lang.String, java.lang.Object,\n\t * java.lang.Object)\n\t */\n\tpublic void nodeAttributeChanged(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object oldValue, Object newValue) {\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\t\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\t\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\t\t\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\toldValueBuff.capacity() + // value\n\t\t\t\t1 + // value type\n\t\t\t\tnewValueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CHG_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) oldValueType)\n\t\t.put(oldValueBuff)\n\t\t.put((byte) newValueType)\n\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#nodeAttributeRemoved(java.lang.String\n\t * , long, java.lang.String, java.lang.String)\n\t */\n\tpublic void nodeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() // attribute\n\t\t);\n\t\t\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_NODE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff)\n\t\t.put(attrBuff);\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeAdded(java.lang.String,\n\t * long, java.lang.String, java.lang.String, java.lang.Object)\n\t */\n\tpublic void edgeAttributeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString attribute, Object value) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\n\t\tint valueType = getType(value);\n\t\t\n\t\tByteBuffer valueBuff = encodeValue(value, valueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\tvalueBuff.capacity() // value\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) valueType) // value type\n\t\t.put(valueBuff);\n\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeChanged(java.lang.String\n\t * , long, java.lang.String, java.lang.String, java.lang.Object,\n\t * java.lang.Object)\n\t */\n\tpublic void edgeAttributeChanged(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object oldValue, Object newValue) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\tint oldValueType = getType(oldValue);\n\t\tint newValueType = getType(newValue);\n\n\t\tByteBuffer oldValueBuff = encodeValue(oldValue, oldValueType);\n\t\tByteBuffer newValueBuff = encodeValue(newValue, newValueType);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() + // attribute\n\t\t\t\t1 + // value type\n\t\t\t\toldValueBuff.capacity() + // value\n\t\t\t\t1 + // value type\n\t\t\t\tnewValueBuff.capacity()  // value\n\t\t);\n\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CHG_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff)\n\t\t.put((byte) oldValueType)\n\t\t.put(oldValueBuff)\n\t\t.put((byte) newValueType)\n\t\t.put(newValueBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.AttributeSink#edgeAttributeRemoved(java.lang.String\n\t * , long, java.lang.String, java.lang.String)\n\t */\n\tpublic void edgeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer attrBuff = encodeString(attribute);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // nodeId \n\t\t\t\tattrBuff.capacity() // attribute\n\t\t);\n\t\t\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_EDGE_ATTR)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(attrBuff);\n\t\t\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#nodeAdded(java.lang.String, long,\n\t * java.lang.String)\n\t */\n\tpublic void nodeAdded(String sourceId, long timeId, String nodeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\t\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() // nodeId \n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_NODE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff);\n\t\t\n\t\t\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#nodeRemoved(java.lang.String,\n\t * long, java.lang.String)\n\t */\n\tpublic void nodeRemoved(String sourceId, long timeId, String nodeId) {\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer nodeBuff = encodeString(nodeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tnodeBuff.capacity() // nodeId \n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_NODE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(nodeBuff);\n\t\t\n\t\tdoSend(buff);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#edgeAdded(java.lang.String, long,\n\t * java.lang.String, java.lang.String, java.lang.String, boolean)\n\t */\n\tpublic void edgeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\tByteBuffer fromNodeBuff = encodeString(fromNodeId);\n\t\tByteBuffer toNodeBuff = encodeString(toNodeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity() + // edge\n\t\t\t\tfromNodeBuff.capacity() + // from nodeId\n\t\t\t\ttoNodeBuff.capacity() + // to nodeId \n\t\t\t\t1 // direction\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_ADD_EDGE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff)\n\t\t.put(fromNodeBuff)\n\t\t.put(toNodeBuff)\n\t\t.put((byte) (!directed ? 0 : 1));\n\t\t\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#edgeRemoved(java.lang.String,\n\t * long, java.lang.String)\n\t */\n\tpublic void edgeRemoved(String sourceId, long timeId, String edgeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer edgeBuff = encodeString(edgeId);\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) + // timeId\n\t\t\t\tedgeBuff.capacity()  // edge\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_DEL_EDGE)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.put(edgeBuff);\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#graphCleared(java.lang.String,\n\t * long)\n\t */\n\tpublic void graphCleared(String sourceId, long timeId) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId)\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\n\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_CLEARED)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId));\n\n\t\tdoSend(buff);\n\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.ElementSink#stepBegins(java.lang.String,\n\t * long, double)\n\t */\n\tpublic void stepBegins(String sourceId, long timeId, double step) {\n\n\t\tif (!sourceId.equals(this.sourceId)) {\n\t\t\tthis.sourceId = sourceId;\n\t\t\tsourceIdBuff = encodeString(sourceId);\n\t\t}\n\t\t\n\t\tByteBuffer buff = ByteBuffer.allocate(\n\t\t\t\tstreamBuffer.capacity() + // stream\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t1 + // CMD\n\t\t\t\tsourceIdBuff.capacity() + // source id\n\t\t\t\tvarintSize(timeId) +\n\t\t\t\t8 // time\n\t\t);\n\t\t\n\t\tstreamBuffer.rewind();\n\t\tsourceIdBuff.rewind();\n\t\t\t\t\n\t\tbuff\n\t\t.put(streamBuffer)\n\t\t.put((byte) NetStreamConstants.EVENT_STEP)\n\t\t.put(sourceIdBuff)\n\t\t.put(encodeUnsignedVarint(timeId))\n\t\t.putDouble(step);\n\t\t\n\t\t\n\t\tdoSend(buff);\n\t}\n\n\t/**\n\t * Force the connection to close (properly) with the server\n\t * \n\t * @throws IOException\n\t */\n\tpublic void close() throws IOException {\n\t\tsocket.close();\n\t}\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "encodeDouble",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The double to encode\n * @return ByteBuffer with encoded double in it\n */\nprotected ByteBuffer encodeDouble(Object in) {\n    ByteBuffer bb = ByteBuffer.allocate(8).putDouble((Double) in);\n    bb.rewind();\n    return bb;\n}"
            ],
            [
                "encodeBoolean",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeBoolean(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(1);\n    b.put((byte) (((Boolean) in) == false ? 0 : 1));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeDoubleArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeDoubleArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length * 8);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.putDouble((Double) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "encodeString",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/*\n\tprivate void outBuffer(ByteBuffer buf){\n\t\tSystem.out.println(buf.toString());\n\t\tint nbytes = buf.capacity();\n\t\tint at = buf.position();\n\t\tfor(int i=0; i< nbytes; i++){\n\t\t\tint bt = buf.get(at+i);\n\t\t\tif (bt < 0) bt = (bt & 127) + (bt & 128); \n\t\t\tSystem.out.printf(\"%d \", bt);\n\t\t}\n\t\tSystem.out.println();\n\t}*/\n/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeString(Object in) {\n    //System.out.println(\"They want me to encode this string: \"+in);\n    String s = (String) in;\n    byte[] data = s.getBytes(Charset.forName(\"UTF-8\"));\n    ByteBuffer lenBuff = encodeUnsignedVarint(data.length);\n    //outBuffer(lenBuff);\n    ByteBuffer bb = ByteBuffer.allocate(lenBuff.capacity() + data.length);\n    bb.put(lenBuff).put(data);\n    bb.rewind();\n    //outBuffer(bb);\n    return bb;\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "encodeLong",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The long to encode\n * @return ByteBuffer with encoded long in it\n */\nprotected ByteBuffer encodeLong(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeIntArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The integer array to encode\n * @return ByteBuffer with encoded integer array in it\n */\nprotected ByteBuffer encodeIntArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "encodeFloat",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The float to encode\n * @return ByteBuffer with encoded float in it\n */\nprotected ByteBuffer encodeFloat(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(4);\n    b.putFloat(((Float) in));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeByteArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeByteArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.put((Byte) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeShortArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeShortArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "getType",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected int getType(Object value) {\n    int valueType = NetStreamConstants.TYPE_UNKNOWN;\n    if (value == null)\n        return NetStreamConstants.TYPE_NULL;\n    Class<?> valueClass = value.getClass();\n    boolean isArray = valueClass.isArray();\n    if (isArray) {\n        valueClass = ((Object[]) value)[0].getClass();\n    }\n    if (valueClass.equals(Boolean.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_BOOLEAN_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_BOOLEAN;\n        }\n    } else if (valueClass.equals(Byte.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_BYTE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_BYTE;\n        }\n    } else if (valueClass.equals(Short.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_SHORT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_SHORT;\n        }\n    } else if (valueClass.equals(Integer.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_INT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_INT;\n        }\n    } else if (valueClass.equals(Long.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_LONG_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_LONG;\n        }\n    } else if (valueClass.equals(Float.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_FLOAT_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_FLOAT;\n        }\n    } else if (valueClass.equals(Double.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_DOUBLE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_DOUBLE;\n        }\n    } else if (valueClass.equals(String.class)) {\n        if (isArray) {\n            valueType = NetStreamConstants.TYPE_ARRAY;\n        } else {\n            valueType = NetStreamConstants.TYPE_STRING;\n        }\n    } else\n        System.err.printf(\"[warning] can not find type of %s\\n\", valueClass);\n    // System.out.println(\"ValueType=\"+valueType+\" \"+value.getClass());\n    return valueType;\n}"
            ],
            [
                "encodeByte",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeByte(Object in) {\n    ByteBuffer b = ByteBuffer.allocate(1);\n    b.put(((Byte) in));\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeValue",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer encodeValue(Object in, int valueType) {\n    if (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n        return encodeBoolean(in);\n    } else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n        return encodeBooleanArray(in);\n    } else if (NetStreamConstants.TYPE_BYTE == valueType) {\n        return encodeByte(in);\n    } else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n        return encodeByteArray(in);\n    } else if (NetStreamConstants.TYPE_SHORT == valueType) {\n        return encodeShort(in);\n    } else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n        return encodeShortArray(in);\n    } else if (NetStreamConstants.TYPE_INT == valueType) {\n        return encodeInt(in);\n    } else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n        return encodeIntArray(in);\n    } else if (NetStreamConstants.TYPE_LONG == valueType) {\n        return encodeLong(in);\n    } else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n        return encodeLongArray(in);\n    } else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n        return encodeFloat(in);\n    } else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n        return encodeFloatArray(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n        return encodeDouble(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n        return encodeDoubleArray(in);\n    } else if (NetStreamConstants.TYPE_STRING == valueType) {\n        return encodeString(in);\n    } else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n        return encodeArray(in);\n    } else if (NetStreamConstants.TYPE_NULL == valueType) {\n        return NULL_BUFFER;\n    }\n    System.err.printf(\"[warning] unknown value type %d\\n\", valueType);\n    return null;\n}"
            ],
            [
                "encodeBooleanArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeBooleanArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.put((byte) ((Boolean) data[i] == false ? 0 : 1));\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "encodeVarint",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeVarint(Object in) {\n    long data = ((Number) in).longValue();\n    // signed integers encoding\n    // (n << 1) ^ (n >> 31)\n    // OK but java's negative values are two's complements...\n    return encodeUnsignedVarint(data >= 0 ? (data << 1) : ((Math.abs(data) << 1) ^ 1));\n}"
            ],
            [
                "encodeVarintArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeVarintArray(Object in) {\n    Object[] data = (Object[]) in;\n    int[] sizes = new int[data.length];\n    long[] zigzags = new long[data.length];\n    int sumsizes = 0;\n    for (int i = 0; i < data.length; i++) {\n        long datum = ((Number) data[i]).longValue();\n        // signed integers encoding\n        // (n << 1) ^ (n >> 31)\n        // OK but java's negative values are two's complements...\n        zigzags[i] = datum > 0 ? (datum << 1) : ((Math.abs(datum) << 1) ^ 1);\n        sizes[i] = varintSize(zigzags[i]);\n        sumsizes += sizes[i];\n        //System.out.printf(\"i=%d, zigzag=%d, size=%d\\n\",i, zigzags[i], sizes[i]);\n    }\n    // the size of the size!\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + sumsizes);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        putVarint(b, zigzags[i], sizes[i]);\n    }\n    b.rewind();\n    //outBuffer(b);\n    return b;\n}"
            ],
            [
                "encodeInt",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The integer to encode\n * @return ByteBuffer with encoded integer in it\n */\nprotected ByteBuffer encodeInt(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeLongArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The long array to encode\n * @return ByteBuffer with encoded long array in it\n */\nprotected ByteBuffer encodeLongArray(Object in) {\n    return encodeVarintArray(in);\n}"
            ],
            [
                "encodeFloatArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in The float array to encode\n * @return ByteBuffer with encoded float array in it\n */\nprotected ByteBuffer encodeFloatArray(Object in) {\n    Object[] data = (Object[]) in;\n    int ssize = varintSize(data.length);\n    ByteBuffer b = ByteBuffer.allocate(ssize + data.length * 4);\n    putVarint(b, data.length, ssize);\n    for (int i = 0; i < data.length; i++) {\n        b.putFloat((Float) data[i]);\n    }\n    b.rewind();\n    return b;\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "encodeShort",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeShort(Object in) {\n    return encodeVarint(in);\n}"
            ],
            [
                "encodeArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeArray(Object in) {\n    // TODO...\n    return null;\n}"
            ],
            [
                "encodeUnsignedVarint",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "/**\n * @param in\n * @return\n */\nprotected ByteBuffer encodeUnsignedVarint(Object in) {\n    long data = ((Number) in).longValue();\n    int size = varintSize(data);\n    ByteBuffer buff = ByteBuffer.allocate(size);\n    for (int i = 0; i < size; i++) {\n        int head = 128;\n        if (i == size - 1)\n            head = 0;\n        long b = ((data >> (7 * i)) & 127) ^ head;\n        buff.put((byte) (b & 255));\n    }\n    buff.rewind();\n    return buff;\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "stream",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String stream;"
            ],
            [
                "streamBuffer",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer streamBuffer;"
            ],
            [
                "streamIdArray",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "byte[] streamIdArray;"
            ],
            [
                "host",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String host;"
            ],
            [
                "port",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected int port;"
            ],
            [
                "socket",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected Socket socket;"
            ],
            [
                "out",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected BufferedOutputStream out;"
            ],
            [
                "sourceId",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected String sourceId = \"\";"
            ],
            [
                "sourceIdBuff",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected ByteBuffer sourceIdBuff;"
            ],
            [
                "packer",
                "org.graphstream.stream.netstream",
                "NetStreamSender",
                "protected NetStreamPacker packer = new DefaultPacker();"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3872,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream.netstream",
        "className": "DefaultNetStreamDecoder",
        "javadocTag": "@throws IOException",
        "methodJavadoc": "    /**\n\t * @param in\n\t * @return\n\t * @throws IOException\n\t */",
        "methodSourceCode": "protected Integer[] readIntArray(InputStream in){\n    int len = (int) readUnsignedVarint(in);\n    Integer[] res = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        res[i] = (int) readVarint(in);\n        //System.out.printf(\"array[%d]=%d%n\",i,res[i]);\n    }\n    return res;\n}",
        "classJavadoc": "/**\n * \n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\n\nimport org.graphstream.stream.thread.ThreadProxyPipe;\n\n/**\n * \n */\npublic class DefaultNetStreamDecoder implements NetStreamDecoder {\n\t\n\t/**\n\t * Show debugging messages.\n\t */\n\tprotected boolean debug = true;\n\n\t/**\n\t * The current pipe commands are being written to.\n\t */\n\tprotected ThreadProxyPipe currentStream;\n\n\t/**\n\t * Pairs (key,value) where the key is the listener ID and the value the MBox\n\t * of the listener. This can be modified by other threads and must be\n\t * properly locked.\n\t * \n\t * @see #register(String,ThreadProxyPipe)\n\t */\n\t// protected HashMap<String,MBox> boxes = new HashMap<String,MBox>();\n\tprotected HashMap<String, ThreadProxyPipe> streams = new HashMap<String, ThreadProxyPipe>();\n\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getStream(java.lang.String)\n\t */\n\tpublic synchronized ThreadProxyPipe getStream(String name) {\n\t\tThreadProxyPipe s = streams.get(name);\n\t\tif (s == null) {\n\t\t\ts = new ThreadProxyPipe();\n\t\t\tstreams.put(name, s);\n\t\t}\n\t\treturn s;\n\t}\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getDefaultStream()\n\t */\n\n\tpublic synchronized ThreadProxyPipe getDefaultStream() {\n\t\tThreadProxyPipe s = streams.get(\"default\");\n\t\tif (s == null) {\n\t\t\ts = new ThreadProxyPipe();\n\t\t\tstreams.put(\"default\", s);\n\t\t}\n\t\treturn s;\n\n\t}\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#register(java.lang.String, org.graphstream.stream.thread.ThreadProxyPipe)\n\t */\n\tpublic synchronized void register(String name, ThreadProxyPipe stream)\n\t\t\tthrows Exception {\n\t\tif (streams.containsKey(name))\n\t\t\tthrow new Exception(\"name \" + name + \" already registered\");\n\n\t\tstreams.put(name, stream);\n\n\t\tif (debug)\n\t\t\tdebug(\"registered pipe %s\", name);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#decodeMessage(java.io.InputStream)\n\t */\n\tpublic void decodeMessage(InputStream in) throws IOException {\t\n\n\t\tint cmd = 0;\n\n\t\t// First read the name of the stream that will be addressed.\n\t\tString stream = readString(in);\n\t\tif (debug) {\n\t\t\tdebug(\"Stream \\\"%s\\\" is addressed in this message.\", stream);\n\t\t}\n\t\tcurrentStream = getStream(stream);\n\n\t\tcmd = in.read();\n\t\tif (cmd != -1) {\n\t\t\tif (cmd == NetStreamConstants.EVENT_ADD_NODE) {\n\t\t\t\tserve_EVENT_ADD_NODE(in);\n\t\t\t} else if ((cmd & 0xFF) == (NetStreamConstants.EVENT_DEL_NODE & 0xFF)) {\n\t\t\t\tserve_DEL_NODE(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_ADD_EDGE) {\n\t\t\t\tserve_EVENT_ADD_EDGE(in);\n\t\t\t} else if (NetStreamConstants.EVENT_DEL_EDGE == cmd) {\n\t\t\t\tserve_EVENT_DEL_EDGE(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_STEP) {\n\t\t\t\tserve_EVENT_STEP(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_CLEARED) {\n\t\t\t\tserve_EVENT_CLEARED(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_ADD_GRAPH_ATTR) {\n\t\t\t\tserve_EVENT_ADD_GRAPH_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_CHG_GRAPH_ATTR) {\n\t\t\t\tserve_EVENT_CHG_GRAPH_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_DEL_GRAPH_ATTR) {\n\t\t\t\tserve_EVENT_DEL_GRAPH_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_ADD_NODE_ATTR) {\n\t\t\t\tserve_EVENT_ADD_NODE_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_CHG_NODE_ATTR) {\n\t\t\t\tserve_EVENT_CHG_NODE_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_DEL_NODE_ATTR) {\n\t\t\t\tserve_EVENT_DEL_NODE_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_ADD_EDGE_ATTR) {\n\t\t\t\tserve_EVENT_ADD_EDGE_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_CHG_EDGE_ATTR) {\n\t\t\t\tserve_EVENT_CHG_EDGE_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_DEL_EDGE_ATTR) {\n\t\t\t\tserve_EVENT_DEL_EDGE_ATTR(in);\n\t\t\t} else if (cmd == NetStreamConstants.EVENT_END) {\n\t\t\t\tdebug(\"NetStreamReceiver : Client properly ended the connection.\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tdebug(\"NetStreamReceiver: Don't know this command: \" + cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcmd = in.read();\n\t\t}\n\t}\n\t\n\t\n\t\n\t/**\n\t * @param in\n\t * @see NetStreamConstants.EVENT_DEL_EDGE\n\t */\n\tprotected void serve_EVENT_DEL_EDGE_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received DEL_EDGE_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString edgeId = readString(in);\n\t\tString attrId = readString(in);\n\t\tcurrentStream.edgeAttributeRemoved(sourceId, timeId, edgeId, attrId);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_CHG_EDGE_ATTR\n\t */\n\tprotected void serve_EVENT_CHG_EDGE_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received CHG_EDGE_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString edgeId = readString(in);\n\t\tString attrId = readString(in);\n\t\tint oldValueType = readType(in);\n\t\tObject oldValue = readValue(in, oldValueType);\n\t\tint newValueType = readType(in);\n\t\tObject newValue = readValue(in, newValueType);\n\n\t\tcurrentStream.edgeAttributeChanged(sourceId, timeId, edgeId, attrId,\n\t\t\t\toldValue, newValue);\n\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_ADD_EDGE_ATTR\n\t */\n\tprotected void serve_EVENT_ADD_EDGE_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received ADD_EDGE_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString edgeId = readString(in);\n\t\tString attrId = readString(in);\n\t\tObject value = readValue(in, readType(in));\n\n\t\tcurrentStream.edgeAttributeAdded(sourceId, timeId, edgeId, attrId,\n\t\t\t\tvalue);\n\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_DEL_NODE_ATTR\n\t */\n\tprotected void serve_EVENT_DEL_NODE_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received DEL_NODE_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString nodeId = readString(in);\n\t\tString attrId = readString(in);\n\n\t\tcurrentStream.nodeAttributeRemoved(sourceId, timeId, nodeId, attrId);\n\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_CHG_NODE_ATTR\n\t */\n\tprotected void serve_EVENT_CHG_NODE_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_CHG_NODE_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString nodeId = readString(in);\n\t\tString attrId = readString(in);\n\t\tint oldValueType = readType(in);\n\t\tObject oldValue = readValue(in, oldValueType);\n\t\tint newValueType = readType(in);\n\t\tObject newValue = readValue(in, newValueType);\n\n\t\tcurrentStream.nodeAttributeChanged(sourceId, timeId, nodeId, attrId,\n\t\t\t\toldValue, newValue);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_ADD_NODE_ATTR\n\t */\n\tprotected void serve_EVENT_ADD_NODE_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_ADD_NODE_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString nodeId = readString(in);\n\t\tString attrId = readString(in);\n\t\tObject value = readValue(in, readType(in));\n\n\t\tcurrentStream.nodeAttributeAdded(sourceId, timeId, nodeId, attrId,\n\t\t\t\tvalue);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_DEL_GRAPH_ATTR\n\t */\n\tprotected void serve_EVENT_DEL_GRAPH_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_DEL_GRAPH_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString attrId = readString(in);\n\n\t\tcurrentStream.graphAttributeRemoved(sourceId, timeId, attrId);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_CHG_GRAPH_ATTR\n\t */\n\tprotected void serve_EVENT_CHG_GRAPH_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_CHG_GRAPH_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString attrId = readString(in);\n\t\tint oldValueType = readType(in);\n\t\tObject oldValue = readValue(in, oldValueType);\n\t\tint newValueType = readType(in);\n\t\tObject newValue = readValue(in, newValueType);\n\n\t\tcurrentStream.graphAttributeChanged(sourceId, timeId, attrId, oldValue,\n\t\t\t\tnewValue);\n\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_ADD_GRAPH_ATTR\n\t */\n\tprotected void serve_EVENT_ADD_GRAPH_ATTR(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_ADD_GRAPH_ATTR command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString attrId = readString(in);\n\t\tObject value = readValue(in, readType(in));\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer | EVENT_ADD_GRAPH_ATTR | %s=%s\", attrId,\n\t\t\t\t\tvalue.toString());\n\t\t}\n\t\tcurrentStream.graphAttributeAdded(sourceId, timeId, attrId, value);\n\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_CLEARED\n\t */\n\tprotected void serve_EVENT_CLEARED(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_CLEARED command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tcurrentStream.graphCleared(sourceId, timeId);\n\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_STEP\n\t */\n\tprotected void serve_EVENT_STEP(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_STEP command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tdouble time = readDouble(in);\n\t\tcurrentStream.stepBegins(sourceId, timeId, time);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_DEL_EDGE\n\t */\n\tprotected void serve_EVENT_DEL_EDGE(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_DEL_EDGE command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString edgeId = readString(in);\n\t\tcurrentStream.edgeRemoved(sourceId, timeId, edgeId);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_ADD_EDGE\n\t */\n\tprotected void serve_EVENT_ADD_EDGE(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received ADD_EDGE command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString edgeId = readString(in);\n\t\tString from = readString(in);\n\t\tString to = readString(in);\n\t\tboolean directed = readBoolean(in);\n\t\tcurrentStream.edgeAdded(sourceId, timeId, edgeId, from, to, directed);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.DEL_NODE\n\t */\n\tprotected void serve_DEL_NODE(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received DEL_NODE command.\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString nodeId = readString(in);\n\t\tcurrentStream.nodeRemoved(sourceId, timeId, nodeId);\n\t}\n\n\t/**\n\t * @see NetStreamConstants.EVENT_ADD_NODE\n\t */\n\tprotected void serve_EVENT_ADD_NODE(InputStream in) {\n\t\tif (debug) {\n\t\t\tdebug(\"NetStreamServer: Received EVENT_ADD_NODE command\");\n\t\t}\n\t\tString sourceId = readString(in);\n\t\tlong timeId = readUnsignedVarint(in);\n\t\tString nodeId = readString(in);\n\t\tcurrentStream.nodeAdded(sourceId, timeId, nodeId);\n\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected int readType(InputStream in) {\n\t\ttry {\n\t\t\tint data = 0;\n\t\t\tif ((data = in.read()) == -1) {\n\t\t\t\tdebug(\"readType : could not read type\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (debug) {\n\t\t\t\tdebug(\"NetStreamServer: type \"+data);\n\t\t\t}\n\t\t\treturn data;\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readType: could not read type\");\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tprotected Object readValue(InputStream in, int valueType) {\n\t\tif (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n\t\t\treturn readBoolean(in);\n\t\t} else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n\t\t\treturn readBooleanArray(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE == valueType) {\n\t\t\treturn readByte(in);\n\t\t} else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n\t\t\treturn readByteArray(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT == valueType) {\n\t\t\treturn readShort(in);\n\t\t} else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n\t\t\treturn readShortArray(in);\n\t\t} else if (NetStreamConstants.TYPE_INT == valueType) {\n\t\t\treturn readInt(in);\n\t\t} else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n\t\t\treturn readIntArray(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG == valueType) {\n\t\t\treturn readLong(in);\n\t\t} else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n\t\t\treturn readLongArray(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n\t\t\treturn readFloat(in);\n\t\t} else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n\t\t\treturn readFloatArray(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n\t\t\treturn readDouble(in);\n\t\t} else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n\t\t\treturn readDoubleArray(in);\n\t\t} else if (NetStreamConstants.TYPE_STRING == valueType) {\n\t\t\treturn readString(in);\n\t\t} else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n\t\t\treturn readArray(in);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t */\n\tprotected Object[] readArray(InputStream in) {\n\n\t\tint len = (int) readUnsignedVarint(in);\n\n\t\tObject[] array = new Object[len];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tarray[i] = readValue(in, readType(in));\n\t\t}\n\t\treturn array;\n\n\t}\n\n\tprotected String readString(InputStream in) {\n\t\ttry {\n\n\t\t\tint len = (int) readUnsignedVarint(in);\n\t\t\tbyte[] data = new byte[len];\n\t\t\tif (in.read(data, 0, len) != len) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tString s = new String(data, Charset.forName(\"UTF-8\"));\n\t\t\treturn s;\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readString: could not read string\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected Boolean readBoolean(InputStream in) {\n\t\tint data = 0;\n\t\ttry {\n\t\t\tdata = in.read();\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readByte: could not read\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn data == 0 ? false : true;\n\t}\n\n\tprotected Byte readByte(InputStream in) {\n\t\tbyte data = 0;\n\t\ttry {\n\t\t\tdata = (byte) in.read();\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readByte: could not read\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn data;\n\t}\n\n\tprotected long readUnsignedVarint(InputStream in) {\n\t\ttry {\n\n\t\t\tint size = 0;\n\t\t\tlong[] data = new long[9];\n\t\t\tdo {\n\t\t\t\tdata[size] = in.read();\n\t\t\t\t\n\t\t\t\tsize++;\n\t\t\t\t\n\t\t\t\t//int bt =data[size-1]; \n\t\t\t\t//if (bt < 0) bt = (bt & 127) + (bt & 128);\n\t\t\t\t//System.out.println(\"test \"+bt+\"  -> \"+(data[size - 1]& 128) );\n\t\t\t} while ((data[size - 1] & 128) == 128);\n\t\t\tlong number = 0;\n\t\t\tfor (int i = 0; i < size; i++) {\n\n\t\t\t\tnumber ^= (data[i] & 127L) << (i * 7L);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn number;\n\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readUnsignedVarintFromInteger: could not read\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn 0L;\n\t}\n\t\n\t\n\n\tprotected long readVarint(InputStream in) {\n\t\tlong number = readUnsignedVarint(in);\n\t\treturn ((number & 1) == 0) ? number >> 1 : -(number >> 1);\n\t}\n\n\tprotected Short readShort(InputStream in) {\n\t\treturn (short) readVarint(in);\n\t}\n\n\tprotected Integer readInt(InputStream in) {\n\t\treturn (int) readVarint(in);\n\t}\n\n\tprotected Long readLong(InputStream in) {\n\t\treturn readVarint(in);\n\t}\n\n\tprotected Float readFloat(InputStream in) {\n\t\tbyte[] data = new byte[4];\n\t\ttry {\n\t\t\tif (in.read(data, 0, 4) != 4) {\n\t\t\t\tdebug(\"readFloat: could not read\");\n\t\t\t\treturn 0f;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readFloat: could not read\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tByteBuffer bb = ByteBuffer.allocate(4);\n\t\tbb.put(data);\n\t\tbb.flip();\n\t\treturn bb.getFloat();\n\t}\n\n\tprotected Double readDouble(InputStream in) {\n\t\tbyte[] data = new byte[8];\n\t\ttry {\n\t\t\tif (in.read(data, 0, 8) != 8) {\n\t\t\t\tdebug(\"readDouble: could not read\");\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readDouble: could not read\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tByteBuffer bb = ByteBuffer.allocate(8);\n\t\tbb.put(data);\n\t\tbb.flip();\n\t\treturn bb.getDouble();\n\t}\n\n\t/**\n\t * @param in\n\t * @return\n\t * @throws IOException\n\t */\n\tprotected Integer[] readIntArray(InputStream in) {\n\t\t\n\t\tint len = (int) readUnsignedVarint(in);\n\n\t\tInteger[] res = new Integer[len];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tres[i] = (int) readVarint(in);\n\t\t\t//System.out.printf(\"array[%d]=%d%n\",i,res[i]);\n\t\t}\n\t\treturn res;\n\t}\n\n\tprotected Boolean[] readBooleanArray(InputStream in) {\n\t\tbyte[] data = null;\n\n\t\ttry {\n\t\t\tint len = (int) readUnsignedVarint(in);\n\n\t\t\tdata = new byte[len];\n\t\t\tif (in.read(data, 0, len) != len) {\n\t\t\t\tdebug(\"readBooleanArray: could not read array\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tByteBuffer bb = ByteBuffer.allocate(len);\n\t\t\tbb.put(data);\n\t\t\tbb.flip();\n\t\t\tBoolean[] res = new Boolean[len];\n\t\t\tfor (int i = 0; i < len; i++) {\n\n\t\t\t\tbyte b = bb.get();\n\n\t\t\t\tres[i] = b == 0 ? false : true;\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readBooleanArray: could not read array\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected Byte[] readByteArray(InputStream in) {\n\t\tbyte[] data = null;\n\n\t\ttry {\n\t\t\tint len = (int) readUnsignedVarint(in);\n\n\t\t\tdata = new byte[len];\n\t\t\tif (in.read(data, 0, len) != len) {\n\t\t\t\tdebug(\"readByteArray: could not read array\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tByteBuffer bb = ByteBuffer.allocate(len);\n\t\t\tbb.put(data);\n\t\t\tbb.flip();\n\t\t\tByte[] res = new Byte[len];\n\t\t\tfor (int i = 0; i < len; i++) {\n\n\t\t\t\tres[i] = bb.get();\n\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readBooleanArray: could not read array\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected Double[] readDoubleArray(InputStream in) {\n\t\tbyte[] data = null;\n\n\t\ttry {\n\t\t\tint len = (int) readUnsignedVarint(in);\n\n\t\t\tdata = new byte[len * 8];\n\t\t\tif (in.read(data, 0, len * 8) != len * 8) {\n\t\t\t\tdebug(\"readDoubleArray: could not read array\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tByteBuffer bb = ByteBuffer.allocate(8 * len);\n\t\t\tbb.put(data);\n\t\t\tbb.flip();\n\t\t\tDouble[] res = new Double[len];\n\t\t\tfor (int i = 0; i < len; i++) {\n\n\t\t\t\tres[i] = bb.getDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readDoubleArray: could not read array\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected Float[] readFloatArray(InputStream in) {\n\t\tbyte[] data = null;\n\n\t\ttry {\n\t\t\tint len = (int) readUnsignedVarint(in);\n\n\t\t\tdata = new byte[len * 4];\n\t\t\tif (in.read(data, 0, len * 4) != len * 4) {\n\t\t\t\tdebug(\"readFloatArray: could not read array\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tByteBuffer bb = ByteBuffer.allocate(4 * len);\n\t\t\tbb.put(data);\n\t\t\tbb.flip();\n\t\t\tFloat[] res = new Float[len];\n\t\t\tfor (int i = 0; i < len; i++) {\n\n\t\t\t\tres[i] = bb.getFloat();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\tdebug(\"readFloatArray: could not read array\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected Long[] readLongArray(InputStream in) {\n\t\tint len = (int) readUnsignedVarint(in);\n\n\t\tLong[] res = new Long[len];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tres[i] = readVarint(in);\n\t\t}\n\t\treturn res;\n\t}\n\n\tprotected Short[] readShortArray(InputStream in) {\n\t\tint len = (int) readUnsignedVarint(in);\n\n\t\tShort[] res = new Short[len];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tres[i] = (short) readVarint(in);\n\t\t\t//System.out.printf(\"array[%d]=%d%n\",i,res[i]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\t\n\tprotected void debug(String message, Object... data) {\n\t\t// System.err.print( LIGHT_YELLOW );\n\t\tSystem.err.printf(\"[//NetStreamDecoder | \");\n\t\t// System.err.print( RESET );\n\t\tSystem.err.printf(message, data);\n\t\t// System.err.print( LIGHT_YELLOW );\n\t\tSystem.err.printf(\"]%n\");\n\t\t// System.err.println( RESET );\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#setDebugOn(boolean)\n\t */\n\tpublic void setDebugOn(boolean on) {\n\t\tdebug = on;\n\t}\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "in",
                "java.io",
                "InputStream"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "readShortArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Short[] readShortArray(InputStream in) {\n    int len = (int) readUnsignedVarint(in);\n    Short[] res = new Short[len];\n    for (int i = 0; i < len; i++) {\n        res[i] = (short) readVarint(in);\n        //System.out.printf(\"array[%d]=%d%n\",i,res[i]);\n    }\n    return res;\n}"
            ],
            [
                "readLong",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Long readLong(InputStream in) {\n    return readVarint(in);\n}"
            ],
            [
                "readDoubleArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Double[] readDoubleArray(InputStream in) {\n    byte[] data = null;\n    try {\n        int len = (int) readUnsignedVarint(in);\n        data = new byte[len * 8];\n        if (in.read(data, 0, len * 8) != len * 8) {\n            debug(\"readDoubleArray: could not read array\");\n            return null;\n        }\n        ByteBuffer bb = ByteBuffer.allocate(8 * len);\n        bb.put(data);\n        bb.flip();\n        Double[] res = new Double[len];\n        for (int i = 0; i < len; i++) {\n            res[i] = bb.getDouble();\n        }\n        return res;\n    } catch (IOException e) {\n        debug(\"readDoubleArray: could not read array\");\n        e.printStackTrace();\n    }\n    return null;\n}"
            ],
            [
                "readBooleanArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Boolean[] readBooleanArray(InputStream in) {\n    byte[] data = null;\n    try {\n        int len = (int) readUnsignedVarint(in);\n        data = new byte[len];\n        if (in.read(data, 0, len) != len) {\n            debug(\"readBooleanArray: could not read array\");\n            return null;\n        }\n        ByteBuffer bb = ByteBuffer.allocate(len);\n        bb.put(data);\n        bb.flip();\n        Boolean[] res = new Boolean[len];\n        for (int i = 0; i < len; i++) {\n            byte b = bb.get();\n            res[i] = b == 0 ? false : true;\n        }\n        return res;\n    } catch (IOException e) {\n        debug(\"readBooleanArray: could not read array\");\n        e.printStackTrace();\n    }\n    return null;\n}"
            ],
            [
                "getDefaultStream",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getDefaultStream()\n\t */\npublic synchronized ThreadProxyPipe getDefaultStream() {\n    ThreadProxyPipe s = streams.get(\"default\");\n    if (s == null) {\n        s = new ThreadProxyPipe();\n        streams.put(\"default\", s);\n    }\n    return s;\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "readIntArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/**\n * @param in\n * @return\n * @throws IOException\n */\nprotected Integer[] readIntArray(InputStream in) {\n    int len = (int) readUnsignedVarint(in);\n    Integer[] res = new Integer[len];\n    for (int i = 0; i < len; i++) {\n        res[i] = (int) readVarint(in);\n        //System.out.printf(\"array[%d]=%d%n\",i,res[i]);\n    }\n    return res;\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "readVarint",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected long readVarint(InputStream in) {\n    long number = readUnsignedVarint(in);\n    return ((number & 1) == 0) ? number >> 1 : -(number >> 1);\n}"
            ],
            [
                "readShort",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Short readShort(InputStream in) {\n    return (short) readVarint(in);\n}"
            ],
            [
                "readInt",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Integer readInt(InputStream in) {\n    return (int) readVarint(in);\n}"
            ],
            [
                "readByte",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Byte readByte(InputStream in) {\n    byte data = 0;\n    try {\n        data = (byte) in.read();\n    } catch (IOException e) {\n        debug(\"readByte: could not read\");\n        e.printStackTrace();\n    }\n    return data;\n}"
            ],
            [
                "getStream",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/* (non-Javadoc)\n\t * @see org.graphstream.stream.netstream.NetStreamDecoder#getStream(java.lang.String)\n\t */\npublic synchronized ThreadProxyPipe getStream(String name) {\n    ThreadProxyPipe s = streams.get(name);\n    if (s == null) {\n        s = new ThreadProxyPipe();\n        streams.put(name, s);\n    }\n    return s;\n}"
            ],
            [
                "readDouble",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Double readDouble(InputStream in) {\n    byte[] data = new byte[8];\n    try {\n        if (in.read(data, 0, 8) != 8) {\n            debug(\"readDouble: could not read\");\n            return 0.0;\n        }\n    } catch (IOException e) {\n        debug(\"readDouble: could not read\");\n        e.printStackTrace();\n    }\n    ByteBuffer bb = ByteBuffer.allocate(8);\n    bb.put(data);\n    bb.flip();\n    return bb.getDouble();\n}"
            ],
            [
                "readBoolean",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Boolean readBoolean(InputStream in) {\n    int data = 0;\n    try {\n        data = in.read();\n    } catch (IOException e) {\n        debug(\"readByte: could not read\");\n        e.printStackTrace();\n    }\n    return data == 0 ? false : true;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "readUnsignedVarint",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected long readUnsignedVarint(InputStream in) {\n    try {\n        int size = 0;\n        long[] data = new long[9];\n        do {\n            data[size] = in.read();\n            size++;\n            //int bt =data[size-1];\n            //if (bt < 0) bt = (bt & 127) + (bt & 128);\n            //System.out.println(\"test \"+bt+\"  -> \"+(data[size - 1]& 128) );\n        } while ((data[size - 1] & 128) == 128);\n        long number = 0;\n        for (int i = 0; i < size; i++) {\n            number ^= (data[i] & 127L) << (i * 7L);\n        }\n        return number;\n    } catch (IOException e) {\n        debug(\"readUnsignedVarintFromInteger: could not read\");\n        e.printStackTrace();\n    }\n    return 0L;\n}"
            ],
            [
                "readType",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/**\n * @param in\n * @return\n */\nprotected int readType(InputStream in) {\n    try {\n        int data = 0;\n        if ((data = in.read()) == -1) {\n            debug(\"readType : could not read type\");\n            return 0;\n        }\n        if (debug) {\n            debug(\"NetStreamServer: type \" + data);\n        }\n        return data;\n    } catch (IOException e) {\n        debug(\"readType: could not read type\");\n        e.printStackTrace();\n    }\n    return 0;\n}"
            ],
            [
                "readFloat",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Float readFloat(InputStream in) {\n    byte[] data = new byte[4];\n    try {\n        if (in.read(data, 0, 4) != 4) {\n            debug(\"readFloat: could not read\");\n            return 0f;\n        }\n    } catch (IOException e) {\n        debug(\"readFloat: could not read\");\n        e.printStackTrace();\n    }\n    ByteBuffer bb = ByteBuffer.allocate(4);\n    bb.put(data);\n    bb.flip();\n    return bb.getFloat();\n}"
            ],
            [
                "readValue",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Object readValue(InputStream in, int valueType) {\n    if (NetStreamConstants.TYPE_BOOLEAN == valueType) {\n        return readBoolean(in);\n    } else if (NetStreamConstants.TYPE_BOOLEAN_ARRAY == valueType) {\n        return readBooleanArray(in);\n    } else if (NetStreamConstants.TYPE_BYTE == valueType) {\n        return readByte(in);\n    } else if (NetStreamConstants.TYPE_BYTE_ARRAY == valueType) {\n        return readByteArray(in);\n    } else if (NetStreamConstants.TYPE_SHORT == valueType) {\n        return readShort(in);\n    } else if (NetStreamConstants.TYPE_SHORT_ARRAY == valueType) {\n        return readShortArray(in);\n    } else if (NetStreamConstants.TYPE_INT == valueType) {\n        return readInt(in);\n    } else if (NetStreamConstants.TYPE_INT_ARRAY == valueType) {\n        return readIntArray(in);\n    } else if (NetStreamConstants.TYPE_LONG == valueType) {\n        return readLong(in);\n    } else if (NetStreamConstants.TYPE_LONG_ARRAY == valueType) {\n        return readLongArray(in);\n    } else if (NetStreamConstants.TYPE_FLOAT == valueType) {\n        return readFloat(in);\n    } else if (NetStreamConstants.TYPE_FLOAT_ARRAY == valueType) {\n        return readFloatArray(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE == valueType) {\n        return readDouble(in);\n    } else if (NetStreamConstants.TYPE_DOUBLE_ARRAY == valueType) {\n        return readDoubleArray(in);\n    } else if (NetStreamConstants.TYPE_STRING == valueType) {\n        return readString(in);\n    } else if (NetStreamConstants.TYPE_ARRAY == valueType) {\n        return readArray(in);\n    }\n    return null;\n}"
            ],
            [
                "readArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/**\n * @param in\n * @return\n */\nprotected Object[] readArray(InputStream in) {\n    int len = (int) readUnsignedVarint(in);\n    Object[] array = new Object[len];\n    for (int i = 0; i < len; i++) {\n        array[i] = readValue(in, readType(in));\n    }\n    return array;\n}"
            ],
            [
                "readString",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected String readString(InputStream in) {\n    try {\n        int len = (int) readUnsignedVarint(in);\n        byte[] data = new byte[len];\n        if (in.read(data, 0, len) != len) {\n            return null;\n        }\n        String s = new String(data, Charset.forName(\"UTF-8\"));\n        return s;\n    } catch (IOException e) {\n        debug(\"readString: could not read string\");\n        e.printStackTrace();\n    }\n    return null;\n}"
            ],
            [
                "readByteArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Byte[] readByteArray(InputStream in) {\n    byte[] data = null;\n    try {\n        int len = (int) readUnsignedVarint(in);\n        data = new byte[len];\n        if (in.read(data, 0, len) != len) {\n            debug(\"readByteArray: could not read array\");\n            return null;\n        }\n        ByteBuffer bb = ByteBuffer.allocate(len);\n        bb.put(data);\n        bb.flip();\n        Byte[] res = new Byte[len];\n        for (int i = 0; i < len; i++) {\n            res[i] = bb.get();\n        }\n        return res;\n    } catch (IOException e) {\n        debug(\"readBooleanArray: could not read array\");\n        e.printStackTrace();\n    }\n    return null;\n}"
            ],
            [
                "readFloatArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Float[] readFloatArray(InputStream in) {\n    byte[] data = null;\n    try {\n        int len = (int) readUnsignedVarint(in);\n        data = new byte[len * 4];\n        if (in.read(data, 0, len * 4) != len * 4) {\n            debug(\"readFloatArray: could not read array\");\n            return null;\n        }\n        ByteBuffer bb = ByteBuffer.allocate(4 * len);\n        bb.put(data);\n        bb.flip();\n        Float[] res = new Float[len];\n        for (int i = 0; i < len; i++) {\n            res[i] = bb.getFloat();\n        }\n        return res;\n    } catch (IOException e) {\n        debug(\"readFloatArray: could not read array\");\n        e.printStackTrace();\n    }\n    return null;\n}"
            ],
            [
                "readLongArray",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "protected Long[] readLongArray(InputStream in) {\n    int len = (int) readUnsignedVarint(in);\n    Long[] res = new Long[len];\n    for (int i = 0; i < len; i++) {\n        res[i] = readVarint(in);\n    }\n    return res;\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "skip",
                "java.io",
                "InputStream",
                "public long skip(long arg0) throws IOException"
            ],
            [
                "available",
                "java.io",
                "InputStream",
                "public int available() throws IOException"
            ],
            [
                "read",
                "java.io",
                "InputStream",
                "public abstract int read() throws IOException"
            ],
            [
                "read",
                "java.io",
                "InputStream",
                "public int read(byte[] arg0, int arg1, int arg2) throws IOException"
            ],
            [
                "transferTo",
                "java.io",
                "InputStream",
                "public long transferTo(OutputStream arg0) throws IOException"
            ],
            [
                "markSupported",
                "java.io",
                "InputStream",
                "public boolean markSupported()"
            ],
            [
                "readAllBytes",
                "java.io",
                "InputStream",
                "public byte[] readAllBytes() throws IOException"
            ],
            [
                "readNBytes",
                "java.io",
                "InputStream",
                "public byte[] readNBytes(int arg0) throws IOException"
            ],
            [
                "read",
                "java.io",
                "InputStream",
                "public int read(byte[] arg0) throws IOException"
            ],
            [
                "readNBytes",
                "java.io",
                "InputStream",
                "public int readNBytes(byte[] arg0, int arg1, int arg2) throws IOException"
            ],
            [
                "equals",
                "",
                "java.lang.Integer[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "java.lang.Integer[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "java.lang.Integer[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "java.lang.Integer[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "java.lang.Integer[]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "debug",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/**\n * Show debugging messages.\n */\nprotected boolean debug = true;"
            ],
            [
                "currentStream",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/**\n * The current pipe commands are being written to.\n */\nprotected ThreadProxyPipe currentStream;"
            ],
            [
                "streams",
                "org.graphstream.stream.netstream",
                "DefaultNetStreamDecoder",
                "/**\n * Pairs (key,value) where the key is the listener ID and the value the MBox\n * of the listener. This can be modified by other threads and must be\n * properly locked.\n *\n * @see #register(String,ThreadProxyPipe)\n */\n// protected HashMap<String,MBox> boxes = new HashMap<String,MBox>();\nprotected HashMap<String, ThreadProxyPipe> streams = new HashMap<String, ThreadProxyPipe>();"
            ],
            [
                "length",
                "java.lang",
                "Integer[]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 3879,
        "oracle": "numSigBytes >= 0 && numSigBytes <= 3;",
        "oracleType": "PRE",
        "projectName": "gs-core-1.3",
        "packageName": "org.graphstream.stream.netstream.packing",
        "className": "Base64",
        "javadocTag": "@param numSigBytes the number of significant bytes in your array",
        "methodJavadoc": "    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */",
        "methodSourceCode": "private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset, int options){\n    byte[] ALPHABET = getAlphabet(options);\n    //           1         2         3\n    // 01234567890123456789012345678901 Bit position\n    // --------000000001111111122222222 Array position from threeBytes\n    // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n    //          >>18  >>12  >> 6  >> 0  Right shift necessary\n    //                0x3f  0x3f  0x3f  Additional AND\n    // Create buffer with zero-padding if there are only one or two\n    // significant bytes passed in the array.\n    // We have to shift left 24 in order to flush out the 1's that appear\n    // when Java treats a value as negative that is cast from a byte to an int.\n    int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);\n    switch(numSigBytes) {\n        case 3:\n            destination[destOffset] = ALPHABET[(inBuff >>> 18)];\n            destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];\n            destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];\n            destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];\n            return destination;\n        case 2:\n            destination[destOffset] = ALPHABET[(inBuff >>> 18)];\n            destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];\n            destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];\n            destination[destOffset + 3] = EQUALS_SIGN;\n            return destination;\n        case 1:\n            destination[destOffset] = ALPHABET[(inBuff >>> 18)];\n            destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];\n            destination[destOffset + 2] = EQUALS_SIGN;\n            destination[destOffset + 3] = EQUALS_SIGN;\n            return destination;\n        default:\n            return destination;\n    }\n    // end switch\n}",
        "classJavadoc": "/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */",
        "classSourceCode": "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign\u00e9      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.netstream.packing;\n/**\n * <p>Encodes and decodes to and from Base64 notation.</p>\n * <p>Homepage: <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>.</p>\n * \n * <p>Example:</p>\n * \n * <code>String encoded = Base64.encode( myByteArray );</code>\n * <br />\n * <code>byte[] myByteArray = Base64.decode( encoded );</code>\n *\n * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass \n * several pieces of information to the encoder. In the \"higher level\" methods such as \n * encodeBytes( bytes, options ) the options parameter can be used to indicate such \n * things as first gzipping the bytes before encoding them, not inserting linefeeds,\n * and encoding using the URL-safe and Ordered dialects.</p>\n *\n * <p>Note, according to <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>,\n * Section 2.1, implementations should not add line feeds unless explicitly told\n * to do so. I've got Base64 set to this behavior now, although earlier versions\n * broke lines by default.</p>\n *\n * <p>The constants defined in Base64 can be OR-ed together to combine options, so you \n * might make a call like this:</p>\n *\n * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>\n * <p>to compress the data before encoding it and then making the output have newline characters.</p>\n * <p>Also...</p>\n * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>\n *\n *\n *\n * <p>\n * Change Log:\n * </p>\n * <ul>\n *  <li>v2.3.7 - Fixed subtle bug when base 64 input stream contained the\n *   value 01111111, which is an invalid base 64 character but should not\n *   throw an ArrayIndexOutOfBoundsException either. Led to discovery of\n *   mishandling (or potential for better handling) of other bad input\n *   characters. You should now get an IOException if you try decoding\n *   something that has bad characters in it.</li>\n *  <li>v2.3.6 - Fixed bug when breaking lines and the final byte of the encoded\n *   string ended in the last column; the buffer was not properly shrunk and\n *   contained an extra (null) byte that made it into the string.</li>\n *  <li>v2.3.5 - Fixed bug in {@link #encodeFromFile} where estimated buffer size\n *   was wrong for files of size 31, 34, and 37 bytes.</li>\n *  <li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing\n *   the Base64.OutputStream closed the Base64 encoding (by padding with equals\n *   signs) too soon. Also added an option to suppress the automatic decoding\n *   of gzipped streams. Also added experimental support for specifying a\n *   class loader when using the\n *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}\n *   method.</li>\n *  <li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java\n *   footprint with its CharEncoders and so forth. Fixed some javadocs that were\n *   inconsistent. Removed imports and specified things like java.io.IOException\n *   explicitly inline.</li>\n *  <li>v2.3.2 - Reduced memory footprint! Finally refined the \"guessing\" of how big the\n *   final encoded data will be so that the code doesn't have to create two output\n *   arrays: an oversized initial one and then a final, exact-sized one. Big win\n *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not\n *   using the gzip options which uses a different mechanism with streams and stuff).</li>\n *  <li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some\n *   similar helper methods to be more efficient with memory by not returning a\n *   String but just a byte array.</li>\n *  <li>v2.3 - <strong>This is not a drop-in replacement!</strong> This is two years of comments\n *   and bug fixes queued up and finally executed. Thanks to everyone who sent\n *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.\n *   Much bad coding was cleaned up including throwing exceptions where necessary \n *   instead of returning null values or something similar. Here are some changes\n *   that may affect you:\n *   <ul>\n *    <li><em>Does not break lines, by default.</em> This is to keep in compliance with\n *      <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">RFC3548</a>.</li>\n *    <li><em>Throws exceptions instead of returning null values.</em> Because some operations\n *      (especially those that may permit the GZIP option) use IO streams, there\n *      is a possiblity of an java.io.IOException being thrown. After some discussion and\n *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions\n *      rather than return null if ever there's an error. I think this is more\n *      appropriate, though it will require some changes to your code. Sorry,\n *      it should have been done this way to begin with.</li>\n *    <li><em>Removed all references to System.out, System.err, and the like.</em>\n *      Shame on me. All I can say is sorry they were ever there.</li>\n *    <li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed\n *      such as when passed arrays are null or offsets are invalid.</li>\n *    <li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.\n *      This was especially annoying before for people who were thorough in their\n *      own projects and then had gobs of javadoc warnings on this file.</li>\n *   </ul>\n *  <li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug\n *   when using very small files (~&lt; 40 bytes).</li>\n *  <li>v2.2 - Added some helper methods for encoding/decoding directly from\n *   one file to the next. Also added a main() method to support command line\n *   encoding/decoding from one file to the next. Also added these Base64 dialects:\n *   <ol>\n *   <li>The default is RFC3548 format.</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates\n *   URL and file name friendly format as described in Section 4 of RFC3548.\n *   http://www.faqs.org/rfcs/rfc3548.html</li>\n *   <li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates\n *   URL and file name friendly format that preserves lexical ordering as described\n *   in http://www.faqs.org/qa/rfcc-1940.html</li>\n *   </ol>\n *   Special thanks to Jim Kellerman at <a href=\"http://www.powerset.com/\">http://www.powerset.com/</a>\n *   for contributing the new Base64 dialects.\n *  </li>\n * \n *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added\n *   some convenience methods for reading and writing to and from files.</li>\n *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems\n *   with other encodings (like EBCDIC).</li>\n *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the\n *   encoded data was a single byte.</li>\n *  <li>v2.0 - I got rid of methods that used booleans to set options. \n *   Now everything is more consolidated and cleaner. The code now detects\n *   when data that's being decoded is gzip-compressed and will decompress it\n *   automatically. Generally things are cleaner. You'll probably have to\n *   change some method calls that you were making to support the new\n *   options format (<tt>int</tt>s that you \"OR\" together).</li>\n *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             \n *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      \n *   Added the ability to \"suspend\" encoding in the Output Stream so        \n *   you can turn on and off the encoding if you need to embed base64       \n *   data in an otherwise \"normal\" stream (like an XML file).</li>  \n *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.\n *      This helps when using GZIP streams.\n *      Added the ability to GZip-compress objects before encoding them.</li>\n *  <li>v1.4 - Added helper methods to read/write files.</li>\n *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>\n *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream\n *      where last buffer being read, if not completely full, was not returned.</li>\n *  <li>v1.3.4 - Fixed when \"improperly padded stream\" error was thrown at the wrong time.</li>\n *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>\n * </ul>\n *\n * <p>\n * I am placing this code in the Public Domain. Do with it as you will.\n * This software comes with no guarantees or warranties but with\n * plenty of well-wishing instead!\n * Please visit <a href=\"http://iharder.net/base64\">http://iharder.net/base64</a>\n * periodically to check for updates or to contribute improvements.\n * </p>\n *\n * @author Robert Harder\n * @author rob@iharder.net\n * @version 2.3.7\n */\npublic class Base64\n{\n    \n/* ********  P U B L I C   F I E L D S  ******** */   \n    \n    \n    /** No options specified. Value is zero. */\n    public final static int NO_OPTIONS = 0;\n    \n    /** Specify encoding in first bit. Value is one. */\n    public final static int ENCODE = 1;\n    \n    \n    /** Specify decoding in first bit. Value is zero. */\n    public final static int DECODE = 0;\n    \n\n    /** Specify that data should be gzip-compressed in second bit. Value is two. */\n    public final static int GZIP = 2;\n\n    /** Specify that gzipped data should <em>not</em> be automatically gunzipped. */\n    public final static int DONT_GUNZIP = 4;\n    \n    \n    /** Do break lines when encoding. Value is 8. */\n    public final static int DO_BREAK_LINES = 8;\n\t\n    /** \n     * Encode using Base64-like encoding that is URL- and Filename-safe as described\n     * in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * It is important to note that data encoded this way is <em>not</em> officially valid Base64, \n     * or at the very least should not be called Base64 without also specifying that is\n     * was encoded using the URL- and Filename-safe dialect.\n     */\n     public final static int URL_SAFE = 16;\n\n\n     /**\n      * Encode using the special \"ordered\" dialect of Base64 described here:\n      * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n      */\n     public final static int ORDERED = 32;\n    \n    \n/* ********  P R I V A T E   F I E L D S  ******** */  \n    \n    \n    /** Maximum line length (76) of Base64 output. */\n    private final static int MAX_LINE_LENGTH = 76;\n    \n    \n    /** The equals sign (=) as a byte. */\n    private final static byte EQUALS_SIGN = (byte)'=';\n    \n    \n    /** The new line character (\\n) as a byte. */\n    private final static byte NEW_LINE = (byte)'\\n';\n    \n    \n    /** Preferred encoding. */\n    private final static String PREFERRED_ENCODING = \"US-ASCII\";\n    \n\t\n    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding\n    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding\n\t\n\t\n/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */\t\n    \n    /** The 64 valid Base64 values. */\n    /* Host platform me be something funny like EBCDIC, so we hardcode these values. */\n    private final static byte[] _STANDARD_ALPHABET = {\n        (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n        (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n        (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n        (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n        (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n        (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n        (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n        (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n        (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n        (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'+', (byte)'/'\n    };\n\t\n    \n    /** \n     * Translates a Base64 value to either its 6-bit reconstruction value\n     * or a negative number indicating some other meaning.\n     **/\n    private final static byte[] _STANDARD_DECODABET = {\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n        -5,-5,                                      // Whitespace: Tab and Linefeed\n        -9,-9,                                      // Decimal 11 - 12\n        -5,                                         // Whitespace: Carriage Return\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n        -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n        -5,                                         // Whitespace: Space\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n        62,                                         // Plus sign at decimal 43\n        -9,-9,-9,                                   // Decimal 44 - 46\n        63,                                         // Slash at decimal 47\n        52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n        -9,-9,-9,                                   // Decimal 58 - 60\n        -1,                                         // Equals sign at decimal 61\n        -9,-9,-9,                                      // Decimal 62 - 64\n        0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n        14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n        -9,-9,-9,-9,-9,-9,                          // Decimal 91 - 96\n        26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n        39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n        -9,-9,-9,-9,-9                              // Decimal 123 - 127\n        ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,       // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\t\n\t\n/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */\n\t\n    /**\n     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: \n     * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n     * Notice that the last two bytes become \"hyphen\" and \"underscore\" instead of \"plus\" and \"slash.\"\n     */\n    private final static byte[] _URL_SAFE_ALPHABET = {\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U', \n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u', \n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', \n      (byte)'6', (byte)'7', (byte)'8', (byte)'9', (byte)'-', (byte)'_'\n    };\n\t\n    /**\n     * Used in decoding URL- and Filename-safe dialects of Base64.\n     */\n    private final static byte[] _URL_SAFE_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      62,                                         // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      52,53,54,55,56,57,58,59,60,61,              // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      0,1,2,3,4,5,6,7,8,9,10,11,12,13,            // Letters 'A' through 'N'\n      14,15,16,17,18,19,20,21,22,23,24,25,        // Letters 'O' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      63,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      26,27,28,29,30,31,32,33,34,35,36,37,38,     // Letters 'a' through 'm'\n      39,40,41,42,43,44,45,46,47,48,49,50,51,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                              // Decimal 123 - 127\n      ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\n\n/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */\n\n    /**\n     * I don't get the point of this technique, but someone requested it,\n     * and it is described here:\n     * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n     */\n    private final static byte[] _ORDERED_ALPHABET = {\n      (byte)'-',\n      (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4',\n      (byte)'5', (byte)'6', (byte)'7', (byte)'8', (byte)'9',\n      (byte)'A', (byte)'B', (byte)'C', (byte)'D', (byte)'E', (byte)'F', (byte)'G',\n      (byte)'H', (byte)'I', (byte)'J', (byte)'K', (byte)'L', (byte)'M', (byte)'N',\n      (byte)'O', (byte)'P', (byte)'Q', (byte)'R', (byte)'S', (byte)'T', (byte)'U',\n      (byte)'V', (byte)'W', (byte)'X', (byte)'Y', (byte)'Z',\n      (byte)'_',\n      (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f', (byte)'g',\n      (byte)'h', (byte)'i', (byte)'j', (byte)'k', (byte)'l', (byte)'m', (byte)'n',\n      (byte)'o', (byte)'p', (byte)'q', (byte)'r', (byte)'s', (byte)'t', (byte)'u',\n      (byte)'v', (byte)'w', (byte)'x', (byte)'y', (byte)'z'\n    };\n\t\n    /**\n     * Used in decoding the \"ordered\" dialect of Base64.\n     */\n    private final static byte[] _ORDERED_DECODABET = {\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,                 // Decimal  0 -  8\n      -5,-5,                                      // Whitespace: Tab and Linefeed\n      -9,-9,                                      // Decimal 11 - 12\n      -5,                                         // Whitespace: Carriage Return\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 14 - 26\n      -9,-9,-9,-9,-9,                             // Decimal 27 - 31\n      -5,                                         // Whitespace: Space\n      -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,              // Decimal 33 - 42\n      -9,                                         // Plus sign at decimal 43\n      -9,                                         // Decimal 44\n      0,                                          // Minus sign at decimal 45\n      -9,                                         // Decimal 46\n      -9,                                         // Slash at decimal 47\n      1,2,3,4,5,6,7,8,9,10,                       // Numbers zero through nine\n      -9,-9,-9,                                   // Decimal 58 - 60\n      -1,                                         // Equals sign at decimal 61\n      -9,-9,-9,                                   // Decimal 62 - 64\n      11,12,13,14,15,16,17,18,19,20,21,22,23,     // Letters 'A' through 'M'\n      24,25,26,27,28,29,30,31,32,33,34,35,36,     // Letters 'N' through 'Z'\n      -9,-9,-9,-9,                                // Decimal 91 - 94\n      37,                                         // Underscore at decimal 95\n      -9,                                         // Decimal 96\n      38,39,40,41,42,43,44,45,46,47,48,49,50,     // Letters 'a' through 'm'\n      51,52,53,54,55,56,57,58,59,60,61,62,63,     // Letters 'n' through 'z'\n      -9,-9,-9,-9,-9                                 // Decimal 123 - 127\n       ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243\n        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 \n    };\n\n\t\n/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */\n\n\n    /**\n     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED <b>and</b> URLSAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getAlphabet( int options ) {\n        if ((options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_ALPHABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_ALPHABET;\n        } else {\n            return _STANDARD_ALPHABET;\n        }\n    }\t// end getAlphabet\n\n\n    /**\n     * Returns one of the _SOMETHING_DECODABET byte arrays depending on\n     * the options specified.\n     * It's possible, though silly, to specify ORDERED and URL_SAFE\n     * in which case one of them will be picked, though there is\n     * no guarantee as to which one will be picked.\n     */\n    private final static byte[] getDecodabet( int options ) {\n        if( (options & URL_SAFE) == URL_SAFE) {\n            return _URL_SAFE_DECODABET;\n        } else if ((options & ORDERED) == ORDERED) {\n            return _ORDERED_DECODABET;\n        } else {\n            return _STANDARD_DECODABET;\n        }\n    }\t// end getAlphabet\n\n\n    \n    /** Defeats instantiation. */\n    private Base64(){}\n    \n\n    \n    \n/* ********  E N C O D I N G   M E T H O D S  ******** */    \n    \n    \n    /**\n     * Encodes up to the first three bytes of array <var>threeBytes</var>\n     * and returns a four-byte array in Base64 notation.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.\n     * The array <var>threeBytes</var> needs only be as big as\n     * <var>numSigBytes</var>.\n     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.\n     *\n     * @param b4 A reusable byte array to reduce array instantiation\n     * @param threeBytes the array to convert\n     * @param numSigBytes the number of significant bytes in your array\n     * @return four byte array in Base64 notation.\n     * @since 1.5.1\n     */\n    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes, int options ) {\n        encode3to4( threeBytes, 0, numSigBytes, b4, 0, options );\n        return b4;\n    }   // end encode3to4\n\n    \n    /**\n     * <p>Encodes up to three bytes of the array <var>source</var>\n     * and writes the resulting four Base64 bytes to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 3 for\n     * the <var>source</var> array or <var>destOffset</var> + 4 for\n     * the <var>destination</var> array.\n     * The actual number of significant bytes in your array is\n     * given by <var>numSigBytes</var>.</p>\n\t * <p>This is the lowest level of the encoding methods with\n\t * all possible parameters.</p>\n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param numSigBytes the number of significant bytes in your array\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n     * @return the <var>destination</var> array\n     * @since 1.3\n     */\n    private static byte[] encode3to4( \n    byte[] source, int srcOffset, int numSigBytes,\n    byte[] destination, int destOffset, int options ) {\n        \n\tbyte[] ALPHABET = getAlphabet( options ); \n\t\n        //           1         2         3  \n        // 01234567890123456789012345678901 Bit position\n        // --------000000001111111122222222 Array position from threeBytes\n        // --------|    ||    ||    ||    | Six bit groups to index ALPHABET\n        //          >>18  >>12  >> 6  >> 0  Right shift necessary\n        //                0x3f  0x3f  0x3f  Additional AND\n        \n        // Create buffer with zero-padding if there are only one or two\n        // significant bytes passed in the array.\n        // We have to shift left 24 in order to flush out the 1's that appear\n        // when Java treats a value as negative that is cast from a byte to an int.\n        int inBuff =   ( numSigBytes > 0 ? ((source[ srcOffset     ] << 24) >>>  8) : 0 )\n                     | ( numSigBytes > 1 ? ((source[ srcOffset + 1 ] << 24) >>> 16) : 0 )\n                     | ( numSigBytes > 2 ? ((source[ srcOffset + 2 ] << 24) >>> 24) : 0 );\n\n        switch( numSigBytes )\n        {\n            case 3:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = ALPHABET[ (inBuff       ) & 0x3f ];\n                return destination;\n                \n            case 2:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = ALPHABET[ (inBuff >>>  6) & 0x3f ];\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            case 1:\n                destination[ destOffset     ] = ALPHABET[ (inBuff >>> 18)        ];\n                destination[ destOffset + 1 ] = ALPHABET[ (inBuff >>> 12) & 0x3f ];\n                destination[ destOffset + 2 ] = EQUALS_SIGN;\n                destination[ destOffset + 3 ] = EQUALS_SIGN;\n                return destination;\n                \n            default:\n                return destination;\n        }   // end switch\n    }   // end encode3to4\n\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> ByteBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            encoded.put(enc4);\n        }   // end input remaining\n    }\n\n\n    /**\n     * Performs Base64 encoding on the <code>raw</code> ByteBuffer,\n     * writing it to the <code>encoded</code> CharBuffer.\n     * This is an experimental feature. Currently it does not\n     * pass along any options (such as {@link #DO_BREAK_LINES}\n     * or {@link #GZIP}.\n     *\n     * @param raw input buffer\n     * @param encoded output buffer\n     * @since 2.3\n     */\n    public static void encode( java.nio.ByteBuffer raw, java.nio.CharBuffer encoded ){\n        byte[] raw3 = new byte[3];\n        byte[] enc4 = new byte[4];\n\n        while( raw.hasRemaining() ){\n            int rem = Math.min(3,raw.remaining());\n            raw.get(raw3,0,rem);\n            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS );\n            for( int i = 0; i < 4; i++ ){\n                encoded.put( (char)(enc4[i] & 0xFF) );\n            }\n        }   // end input remaining\n    }\n\n\n    \n    \n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.  \n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     *\n     * @param serializableObject The object to encode\n     * @return The Base64-encoded object\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if serializedObject is null\n     * @since 1.4\n     */\n    public static String encodeObject( java.io.Serializable serializableObject )\n    throws java.io.IOException {\n        return encodeObject( serializableObject, NO_OPTIONS );\n    }   // end encodeObject\n    \n\n\n    /**\n     * Serializes an object and returns the Base64-encoded\n     * version of that serialized object.\n     *  \n     * <p>As of v 2.3, if the object\n     * cannot be serialized or there is another error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * The object is not GZip-compressed before being encoded.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     * </pre>\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     * @param serializableObject The object to encode\n     * @param options Specified options\n     * @return The Base64-encoded object\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @since 2.0\n     */\n    public static String encodeObject( java.io.Serializable serializableObject, int options )\n    throws java.io.IOException {\n\n        if( serializableObject == null ){\n            throw new NullPointerException( \"Cannot serialize a null object.\" );\n        }   // end if: null\n        \n        // Streams\n        java.io.ByteArrayOutputStream  baos  = null; \n        java.io.OutputStream           b64os = null;\n        java.util.zip.GZIPOutputStream gzos  = null;\n        java.io.ObjectOutputStream     oos   = null;\n        \n        \n        try {\n            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n            baos  = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream( baos, ENCODE | options );\n            if( (options & GZIP) != 0 ){\n                // Gzip\n                gzos = new java.util.zip.GZIPOutputStream(b64os);\n                oos = new java.io.ObjectOutputStream( gzos );\n            } else {\n                // Not gzipped\n                oos = new java.io.ObjectOutputStream( b64os );\n            }\n            oos.writeObject( serializableObject );\n        }   // end try\n        catch( java.io.IOException e ) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        }   // end catch\n        finally {\n            try{ oos.close();   } catch( Exception e ){}\n            try{ gzos.close();  } catch( Exception e ){}\n            try{ b64os.close(); } catch( Exception e ){}\n            try{ baos.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        // Return value according to relevant encoding.\n        try {\n            return new String( baos.toByteArray(), PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue){\n            // Fall back to some Java default\n            return new String( baos.toByteArray() );\n        }   // end catch\n        \n    }   // end encode\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * @param source The data to convert\n     * @return The data in Base64-encoded form\n     * @throws NullPointerException if source array is null\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n\n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int options ) throws java.io.IOException {\n        return encodeBytes( source, 0, source.length, options );\n    }   // end encodeBytes\n    \n    \n    /**\n     * Encodes a byte array into Base64 notation.\n     * Does not GZip-compress data.\n     *  \n     * <p>As of v 2.3, if there is an error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @return The Base64-encoded data as a String\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 1.4\n     */\n    public static String encodeBytes( byte[] source, int off, int len ) {\n        // Since we're not going to have the GZIP encoding turned on,\n        // we're not going to have an java.io.IOException thrown, so\n        // we should not force the user to have to catch it.\n        String encoded = null;\n        try {\n            encoded = encodeBytes( source, off, len, NO_OPTIONS );\n        } catch (java.io.IOException ex) {\n            assert false : ex.getMessage();\n        }   // end catch\n        assert encoded != null;\n        return encoded;\n    }   // end encodeBytes\n    \n    \n\n    /**\n     * Encodes a byte array into Base64 notation.\n     * <p>\n     * Example options:<pre>\n     *   GZIP: gzip-compresses object before encoding it.\n     *   DO_BREAK_LINES: break lines at 76 characters\n     *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n     * </pre>\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n     * <p>\n     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n     *\n     *  \n     * <p>As of v 2.3, if there is an error with the GZIP stream,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned a null value, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.0\n     */\n    public static String encodeBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n        byte[] encoded = encodeBytesToBytes( source, off, len, options );\n\n        // Return value according to relevant encoding.\n        try {\n            return new String( encoded, PREFERRED_ENCODING );\n        }   // end try\n        catch (java.io.UnsupportedEncodingException uue) {\n            return new String( encoded );\n        }   // end catch\n        \n    }   // end encodeBytes\n\n\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[])} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @return The Base64-encoded data as a byte[] (of ASCII characters)\n     * @throws NullPointerException if source array is null\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source ) {\n        byte[] encoded = null;\n        try {\n            encoded = encodeBytesToBytes( source, 0, source.length, Base64.NO_OPTIONS );\n        } catch( java.io.IOException ex ) {\n            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n        }\n        return encoded;\n    }\n\n\n    /**\n     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n     * a byte array instead of instantiating a String. This is more efficient\n     * if you're working with I/O streams and have large data sets to encode.\n     *\n     *\n     * @param source The data to convert\n     * @param off Offset in array where conversion should begin\n     * @param len Length of data to convert\n     * @param options Specified options\n     * @return The Base64-encoded data as a String\n     * @see Base64#GZIP\n     * @see Base64#DO_BREAK_LINES\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if source array is null\n     * @throws IllegalArgumentException if source array, offset, or length are invalid\n     * @since 2.3.1\n     */\n    public static byte[] encodeBytesToBytes( byte[] source, int off, int len, int options ) throws java.io.IOException {\n\n        if( source == null ){\n            throw new NullPointerException( \"Cannot serialize a null array.\" );\n        }   // end if: null\n\n        if( off < 0 ){\n            throw new IllegalArgumentException( \"Cannot have negative offset: \" + off );\n        }   // end if: off < 0\n\n        if( len < 0 ){\n            throw new IllegalArgumentException( \"Cannot have length offset: \" + len );\n        }   // end if: len < 0\n\n        if( off + len > source.length  ){\n            throw new IllegalArgumentException(\n            String.format( \"Cannot have offset of %d and length of %d with array of length %d\", off,len,source.length));\n        }   // end if: off < 0\n\n\n\n        // Compress?\n        if( (options & GZIP) != 0 ) {\n            java.io.ByteArrayOutputStream  baos  = null;\n            java.util.zip.GZIPOutputStream gzos  = null;\n            Base64.OutputStream            b64os = null;\n\n            try {\n                // GZip -> Base64 -> ByteArray\n                baos = new java.io.ByteArrayOutputStream();\n                b64os = new Base64.OutputStream( baos, ENCODE | options );\n                gzos  = new java.util.zip.GZIPOutputStream( b64os );\n\n                gzos.write( source, off, len );\n                gzos.close();\n            }   // end try\n            catch( java.io.IOException e ) {\n                // Catch it and then throw it immediately so that\n                // the finally{} block is called for cleanup.\n                throw e;\n            }   // end catch\n            finally {\n                try{ gzos.close();  } catch( Exception e ){}\n                try{ b64os.close(); } catch( Exception e ){}\n                try{ baos.close();  } catch( Exception e ){}\n            }   // end finally\n\n            return baos.toByteArray();\n        }   // end if: compress\n\n        // Else, don't compress. Better not to use streams at all then.\n        else {\n            boolean breakLines = (options & DO_BREAK_LINES) != 0;\n\n            //int    len43   = len * 4 / 3;\n            //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n            //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n            //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n            // Try to determine more precisely how big the array needs to be.\n            // If we get it right, we don't have to do an array copy, and\n            // we save a bunch of memory.\n            int encLen = ( len / 3 ) * 4 + ( len % 3 > 0 ? 4 : 0 ); // Bytes needed for actual encoding\n            if( breakLines ){\n                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline characters\n            }\n            byte[] outBuff = new byte[ encLen ];\n\n\n            int d = 0;\n            int e = 0;\n            int len2 = len - 2;\n            int lineLength = 0;\n            for( ; d < len2; d+=3, e+=4 ) {\n                encode3to4( source, d+off, 3, outBuff, e, options );\n\n                lineLength += 4;\n                if( breakLines && lineLength >= MAX_LINE_LENGTH )\n                {\n                    outBuff[e+4] = NEW_LINE;\n                    e++;\n                    lineLength = 0;\n                }   // end if: end of line\n            }   // en dfor: each piece of array\n\n            if( d < len ) {\n                encode3to4( source, d+off, len - d, outBuff, e, options );\n                e += 4;\n            }   // end if: some padding needed\n\n\n            // Only resize array if we didn't guess it right.\n            if( e <= outBuff.length - 1 ){\n                // If breaking lines and the last byte falls right at\n                // the line length (76 bytes per line), there will be\n                // one extra byte, and the array will need to be resized.\n                // Not too bad of an estimate on array size, I'd say.\n                byte[] finalOut = new byte[e];\n                System.arraycopy(outBuff,0, finalOut,0,e);\n                //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n                return finalOut;\n            } else {\n                //System.err.println(\"No need to resize array.\");\n                return outBuff;\n            }\n        \n        }   // end else: don't compress\n\n    }   // end encodeBytesToBytes\n    \n\n    \n    \n    \n/* ********  D E C O D I N G   M E T H O D S  ******** */\n    \n    \n    /**\n     * Decodes four bytes from array <var>source</var>\n     * and writes the resulting bytes (up to three of them)\n     * to <var>destination</var>.\n     * The source and destination arrays can be manipulated\n     * anywhere along their length by specifying \n     * <var>srcOffset</var> and <var>destOffset</var>.\n     * This method does not check to make sure your arrays\n     * are large enough to accomodate <var>srcOffset</var> + 4 for\n     * the <var>source</var> array or <var>destOffset</var> + 3 for\n     * the <var>destination</var> array.\n     * This method returns the actual number of bytes that \n     * were converted from the Base64 encoding.\n\t * <p>This is the lowest level of the decoding methods with\n\t * all possible parameters.</p>\n     * \n     *\n     * @param source the array to convert\n     * @param srcOffset the index where conversion begins\n     * @param destination the array to hold the conversion\n     * @param destOffset the index where output will be put\n\t * @param options alphabet type is pulled from this (standard, url-safe, ordered)\n     * @return the number of decoded bytes converted\n     * @throws NullPointerException if source or destination arrays are null\n     * @throws IllegalArgumentException if srcOffset or destOffset are invalid\n     *         or there is not enough room in the array.\n     * @since 1.3\n     */\n    private static int decode4to3( \n    byte[] source, int srcOffset, \n    byte[] destination, int destOffset, int options ) {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Source array was null.\" );\n        }   // end if\n        if( destination == null ){\n            throw new NullPointerException( \"Destination array was null.\" );\n        }   // end if\n        if( srcOffset < 0 || srcOffset + 3 >= source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and still process four bytes.\", source.length, srcOffset ) );\n        }   // end if\n        if( destOffset < 0 || destOffset +2 >= destination.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Destination array with length %d cannot have offset of %d and still store three bytes.\", destination.length, destOffset ) );\n        }   // end if\n        \n        \n        byte[] DECODABET = getDecodabet( options ); \n\t\n        // Example: Dk==\n        if( source[ srcOffset + 2] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1] ] & 0xFF ) << 12 );\n            \n            destination[ destOffset ] = (byte)( outBuff >>> 16 );\n            return 1;\n        }\n        \n        // Example: DkL=\n        else if( source[ srcOffset + 3 ] == EQUALS_SIGN ) {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6 );\n            \n            destination[ destOffset     ] = (byte)( outBuff >>> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>>  8 );\n            return 2;\n        }\n        \n        // Example: DkLE\n        else {\n            // Two ways to do the same thing. Don't know which way I like best.\n          //int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )\n          //              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )\n          //              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )\n          //              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );\n            int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] & 0xFF ) << 18 )\n                          | ( ( DECODABET[ source[ srcOffset + 1 ] ] & 0xFF ) << 12 )\n                          | ( ( DECODABET[ source[ srcOffset + 2 ] ] & 0xFF ) <<  6)\n                          | ( ( DECODABET[ source[ srcOffset + 3 ] ] & 0xFF )      );\n\n            \n            destination[ destOffset     ] = (byte)( outBuff >> 16 );\n            destination[ destOffset + 1 ] = (byte)( outBuff >>  8 );\n            destination[ destOffset + 2 ] = (byte)( outBuff       );\n\n            return 3;\n        }\n    }   // end decodeToBytes\n    \n\n\n\n\n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @return decoded data\n     * @since 2.3.1\n     */\n    public static byte[] decode( byte[] source )\n    throws java.io.IOException {\n        byte[] decoded = null;\n//        try {\n            decoded = decode( source, 0, source.length, Base64.NO_OPTIONS );\n//        } catch( java.io.IOException ex ) {\n//            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n//        }\n        return decoded;\n    }\n\n    \n    \n    /**\n     * Low-level access to decoding ASCII characters in\n     * the form of a byte array. <strong>Ignores GUNZIP option, if\n     * it's set.</strong> This is not generally a recommended method,\n     * although it is used internally as part of the decoding process.\n     * Special case: if len = 0, an empty array is returned. Still,\n     * if you need more speed and reduced memory footprint (and aren't\n     * gzipping), consider this method.\n     *\n     * @param source The Base64 encoded data\n     * @param off    The offset of where to begin decoding\n     * @param len    The length of characters to decode\n     * @param options Can specify options such as alphabet type to use\n     * @return decoded data\n     * @throws java.io.IOException If bogus characters exist in source data\n     * @since 1.3\n     */\n    public static byte[] decode( byte[] source, int off, int len, int options )\n    throws java.io.IOException {\n        \n        // Lots of error checking and exception throwing\n        if( source == null ){\n            throw new NullPointerException( \"Cannot decode null source array.\" );\n        }   // end if\n        if( off < 0 || off + len > source.length ){\n            throw new IllegalArgumentException( String.format(\n            \"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len ) );\n        }   // end if\n        \n        if( len == 0 ){\n            return new byte[0];\n        }else if( len < 4 ){\n            throw new IllegalArgumentException( \n            \"Base64-encoded string must have at least four characters, but length specified was \" + len );\n        }   // end if\n        \n        byte[] DECODABET = getDecodabet( options );\n\t\n        int    len34   = len * 3 / 4;       // Estimate on array size\n        byte[] outBuff = new byte[ len34 ]; // Upper limit on size of output\n        int    outBuffPosn = 0;             // Keep track of where we're writing\n        \n        byte[] b4        = new byte[4];     // Four byte buffer from source, eliminating white space\n        int    b4Posn    = 0;               // Keep track of four byte input buffer\n        int    i         = 0;               // Source array counter\n        byte   sbiDecode = 0;               // Special value from DECODABET\n        \n        for( i = off; i < off+len; i++ ) {  // Loop through source\n            \n            sbiDecode = DECODABET[ source[i]&0xFF ];\n            \n            // White space, Equals sign, or legit Base64 character\n            // Note the values such as -5 and -9 in the\n            // DECODABETs at the top of the file.\n            if( sbiDecode >= WHITE_SPACE_ENC )  {\n                if( sbiDecode >= EQUALS_SIGN_ENC ) {\n                    b4[ b4Posn++ ] = source[i];         // Save non-whitespace\n                    if( b4Posn > 3 ) {                  // Time to decode?\n                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn, options );\n                        b4Posn = 0;\n                        \n                        // If that was the equals sign, break out of 'for' loop\n                        if( source[i] == EQUALS_SIGN ) {\n                            break;\n                        }   // end if: equals sign\n                    }   // end if: quartet built\n                }   // end if: equals sign or better\n            }   // end if: white space, equals sign or better\n            else {\n                // There's a bad input character in the Base64 stream.\n                throw new java.io.IOException( String.format(\n                \"Bad Base64 input character decimal %d in array position %d\", ((int)source[i])&0xFF, i ) );\n            }   // end else: \n        }   // each input character\n                                   \n        byte[] out = new byte[ outBuffPosn ];\n        System.arraycopy( outBuff, 0, out, 0, outBuffPosn ); \n        return out;\n    }   // end decode\n    \n    \n\t\n\t\n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @return the decoded data\n     * @throws java.io.IOException If there is a problem\n     * @since 1.4\n     */\n    public static byte[] decode( String s ) throws java.io.IOException {\n        return decode( s, NO_OPTIONS );\n    }\n\n    \n    \n    /**\n     * Decodes data from Base64 notation, automatically\n     * detecting gzip-compressed data and decompressing it.\n     *\n     * @param s the string to decode\n     * @param options encode options such as URL_SAFE\n     * @return the decoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if <tt>s</tt> is null\n     * @since 1.4\n     */\n    public static byte[] decode( String s, int options ) throws java.io.IOException {\n        \n        if( s == null ){\n            throw new NullPointerException( \"Input string was null.\" );\n        }   // end if\n        \n        byte[] bytes;\n        try {\n            bytes = s.getBytes( PREFERRED_ENCODING );\n        }   // end try\n        catch( java.io.UnsupportedEncodingException uee ) {\n            bytes = s.getBytes();\n        }   // end catch\n\t\t//</change>\n        \n        // Decode\n        bytes = decode( bytes, 0, bytes.length, options );\n        \n        // Check to see if it's gzip-compressed\n        // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n        boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n        if( (bytes != null) && (bytes.length >= 4) && (!dontGunzip) ) {\n            \n            int head = ((int)bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n            if( java.util.zip.GZIPInputStream.GZIP_MAGIC == head )  {\n                java.io.ByteArrayInputStream  bais = null;\n                java.util.zip.GZIPInputStream gzis = null;\n                java.io.ByteArrayOutputStream baos = null;\n                byte[] buffer = new byte[2048];\n                int    length = 0;\n\n                try {\n                    baos = new java.io.ByteArrayOutputStream();\n                    bais = new java.io.ByteArrayInputStream( bytes );\n                    gzis = new java.util.zip.GZIPInputStream( bais );\n\n                    while( ( length = gzis.read( buffer ) ) >= 0 ) {\n                        baos.write(buffer,0,length);\n                    }   // end while: reading input\n\n                    // No error? Get new bytes.\n                    bytes = baos.toByteArray();\n\n                }   // end try\n                catch( java.io.IOException e ) {\n                    e.printStackTrace();\n                    // Just return originally-decoded bytes\n                }   // end catch\n                finally {\n                    try{ baos.close(); } catch( Exception e ){}\n                    try{ gzis.close(); } catch( Exception e ){}\n                    try{ bais.close(); } catch( Exception e ){}\n                }   // end finally\n\n            }   // end if: gzipped\n        }   // end if: bytes.length >= 2\n        \n        return bytes;\n    }   // end decode\n\n\n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a\n     *         class that cannot be found by the JVM\n     * @since 1.5\n     */\n    public static Object decodeToObject( String encodedObject )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        return decodeToObject(encodedObject,NO_OPTIONS,null);\n    }\n    \n\n    /**\n     * Attempts to decode Base64 data and deserialize a Java\n     * Object within. Returns <tt>null</tt> if there was an error.\n     * If <tt>loader</tt> is not null, it will be the class loader\n     * used when deserializing.\n     *\n     * @param encodedObject The Base64 data to decode\n     * @param options Various parameters related to decoding\n     * @param loader Optional class loader to use in deserializing classes.\n     * @return The decoded and deserialized object\n     * @throws NullPointerException if encodedObject is null\n     * @throws java.io.IOException if there is a general error\n     * @throws ClassNotFoundException if the decoded object is of a \n     *         class that cannot be found by the JVM\n     * @since 2.3.4\n     */\n    public static Object decodeToObject( \n    String encodedObject, int options, final ClassLoader loader )\n    throws java.io.IOException, java.lang.ClassNotFoundException {\n        \n        // Decode and gunzip if necessary\n        byte[] objBytes = decode( encodedObject, options );\n        \n        java.io.ByteArrayInputStream  bais = null;\n        java.io.ObjectInputStream     ois  = null;\n        Object obj = null;\n        \n        try {\n            bais = new java.io.ByteArrayInputStream( objBytes );\n\n            // If no custom class loader is provided, use Java's builtin OIS.\n            if( loader == null ){\n                ois  = new java.io.ObjectInputStream( bais );\n            }   // end if: no loader provided\n\n            // Else make a customized object input stream that uses\n            // the provided class loader.\n            else {\n                ois = new java.io.ObjectInputStream(bais){\n                    @Override\n                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass)\n                    throws java.io.IOException, ClassNotFoundException {\n                        Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                        if( c == null ){\n                            return super.resolveClass(streamClass);\n                        } else {\n                            return c;   // Class loader knows of this class.\n                        }   // end else: not null\n                    }   // end resolveClass\n                };  // end ois\n            }   // end else: no custom class loader\n        \n            obj = ois.readObject();\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        catch( java.lang.ClassNotFoundException e ) {\n            throw e;    // Catch and throw in order to execute finally{}\n        }   // end catch\n        finally {\n            try{ bais.close(); } catch( Exception e ){}\n            try{ ois.close();  } catch( Exception e ){}\n        }   // end finally\n        \n        return obj;\n    }   // end decodeObject\n    \n    \n    \n    /**\n     * Convenience method for encoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToEncode byte array of data to encode in base64 form\n     * @param filename Filename for saving encoded data\n     * @throws java.io.IOException if there is an error\n     * @throws NullPointerException if dataToEncode is null\n     * @since 2.1\n     */\n    public static void encodeToFile( byte[] dataToEncode, String filename )\n    throws java.io.IOException {\n        \n        if( dataToEncode == null ){\n            throw new NullPointerException( \"Data to encode was null.\" );\n        }   // end iff\n        \n        Base64.OutputStream bos = null;\n        try {\n            bos = new Base64.OutputStream( \n                  new java.io.FileOutputStream( filename ), Base64.ENCODE );\n            bos.write( dataToEncode );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end encodeToFile\n    \n    \n    /**\n     * Convenience method for decoding data to a file.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param dataToDecode Base64-encoded data as a string\n     * @param filename Filename for saving decoded data\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static void decodeToFile( String dataToDecode, String filename )\n    throws java.io.IOException {\n        \n        Base64.OutputStream bos = null;\n        try{\n            bos = new Base64.OutputStream( \n                      new java.io.FileOutputStream( filename ), Base64.DECODE );\n            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and throw to execute finally{} block\n        }   // end catch: java.io.IOException\n        finally {\n                try{ bos.close(); } catch( Exception e ){}\n        }   // end finally\n        \n    }   // end decodeToFile\n    \n    \n    \n    \n    /**\n     * Convenience method for reading a base64-encoded\n     * file and decoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading encoded data\n     * @return decoded byte array\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static byte[] decodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        byte[] decodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = null;\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Check for size of file\n            if( file.length() > Integer.MAX_VALUE )\n            {\n                throw new java.io.IOException( \"File is too big for this convenience method (\" + file.length() + \" bytes).\" );\n            }   // end if: file too big for int index\n            buffer = new byte[ (int)file.length() ];\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.DECODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            decodedData = new byte[ length ];\n            System.arraycopy( buffer, 0, decodedData, 0, length );\n            \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return decodedData;\n    }   // end decodeFromFile\n    \n    \n    \n    /**\n     * Convenience method for reading a binary file\n     * and base64-encoding it.\n     *\n     * <p>As of v 2.3, if there is a error,\n     * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n     * In earlier versions, it just returned false, but\n     * in retrospect that's a pretty poor way to handle it.</p>\n     * \n     * @param filename Filename for reading binary data\n     * @return base64-encoded string\n     * @throws java.io.IOException if there is an error\n     * @since 2.1\n     */\n    public static String encodeFromFile( String filename )\n    throws java.io.IOException {\n        \n        String encodedData = null;\n        Base64.InputStream bis = null;\n        try\n        {\n            // Set up some useful variables\n            java.io.File file = new java.io.File( filename );\n            byte[] buffer = new byte[ Math.max((int)(file.length() * 1.4+1),40) ]; // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n            int length   = 0;\n            int numBytes = 0;\n            \n            // Open a stream\n            bis = new Base64.InputStream( \n                      new java.io.BufferedInputStream( \n                      new java.io.FileInputStream( file ) ), Base64.ENCODE );\n            \n            // Read until done\n            while( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 ) {\n                length += numBytes;\n            }   // end while\n            \n            // Save in a variable to return\n            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );\n                \n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch: java.io.IOException\n        finally {\n            try{ bis.close(); } catch( Exception e) {}\n        }   // end finally\n        \n        return encodedData;\n        }   // end encodeFromFile\n    \n    /**\n     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void encodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        String encoded = Base64.encodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( encoded.getBytes(\"US-ASCII\") ); // Strict, 7-bit output.\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end encodeFileToFile\n\n\n    /**\n     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.\n     *\n     * @param infile Input file\n     * @param outfile Output file\n     * @throws java.io.IOException if there is an error\n     * @since 2.2\n     */\n    public static void decodeFileToFile( String infile, String outfile )\n    throws java.io.IOException {\n        \n        byte[] decoded = Base64.decodeFromFile( infile );\n        java.io.OutputStream out = null;\n        try{\n            out = new java.io.BufferedOutputStream(\n                  new java.io.FileOutputStream( outfile ) );\n            out.write( decoded );\n        }   // end try\n        catch( java.io.IOException e ) {\n            throw e; // Catch and release to execute finally{}\n        }   // end catch\n        finally {\n            try { out.close(); }\n            catch( Exception ex ){}\n        }   // end finally    \n    }   // end decodeFileToFile\n    \n    \n    /* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.InputStream} will read data from another\n     * <tt>java.io.InputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class InputStream extends java.io.FilterInputStream {\n        \n        private boolean encode;         // Encoding or decoding\n        private int     position;       // Current position in the buffer\n        private byte[]  buffer;         // Small buffer holding converted data\n        private int     bufferLength;   // Length of buffer (3 or 4)\n        private int     numSigBytes;    // Number of meaningful bytes in the buffer\n        private int     lineLength;\n        private boolean breakLines;     // Break lines at less than 80 characters\n        private int     options;        // Record options used to create the stream.\n        private byte[]  decodabet;      // Local copies to avoid extra method calls\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in DECODE mode.\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @since 1.3\n         */\n        public InputStream( java.io.InputStream in ) {\n            this( in, DECODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.InputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>\n         *\n         *\n         * @param in the <tt>java.io.InputStream</tt> from which to read data.\n         * @param options Specified options\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 2.0\n         */\n        public InputStream( java.io.InputStream in, int options ) {\n            \n            super( in );\n            this.options      = options; // Record for later\n            this.breakLines   = (options & DO_BREAK_LINES) > 0;\n            this.encode       = (options & ENCODE) > 0;\n            this.bufferLength = encode ? 4 : 3;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = -1;\n            this.lineLength   = 0;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        /**\n         * Reads enough of the input stream to convert\n         * to/from Base64 and returns the next byte.\n         *\n         * @return next byte\n         * @since 1.3\n         */\n        @Override\n        public int read() throws java.io.IOException  {\n            \n            // Do we need to get data?\n            if( position < 0 ) {\n                if( encode ) {\n                    byte[] b3 = new byte[3];\n                    int numBinaryBytes = 0;\n                    for( int i = 0; i < 3; i++ ) {\n                        int b = in.read();\n\n                        // If end of stream, b is -1.\n                        if( b >= 0 ) {\n                            b3[i] = (byte)b;\n                            numBinaryBytes++;\n                        } else {\n                            break; // out of for loop\n                        }   // end else: end of stream\n                            \n                    }   // end for: each needed input byte\n                    \n                    if( numBinaryBytes > 0 ) {\n                        encode3to4( b3, 0, numBinaryBytes, buffer, 0, options );\n                        position = 0;\n                        numSigBytes = 4;\n                    }   // end if: got data\n                    else {\n                        return -1;  // Must be end of stream\n                    }   // end else\n                }   // end if: encoding\n                \n                // Else decoding\n                else {\n                    byte[] b4 = new byte[4];\n                    int i = 0;\n                    for( i = 0; i < 4; i++ ) {\n                        // Read four \"meaningful\" bytes:\n                        int b = 0;\n                        do{ b = in.read(); }\n                        while( b >= 0 && decodabet[ b & 0x7f ] <= WHITE_SPACE_ENC );\n                        \n                        if( b < 0 ) {\n                            break; // Reads a -1 if end of stream\n                        }   // end if: end of stream\n                        \n                        b4[i] = (byte)b;\n                    }   // end for: each needed input byte\n                    \n                    if( i == 4 ) {\n                        numSigBytes = decode4to3( b4, 0, buffer, 0, options );\n                        position = 0;\n                    }   // end if: got four characters\n                    else if( i == 0 ){\n                        return -1;\n                    }   // end else if: also padded correctly\n                    else {\n                        // Must have broken out from above.\n                        throw new java.io.IOException( \"Improperly padded Base64 input.\" );\n                    }   // end \n                    \n                }   // end else: decode\n            }   // end else: get data\n            \n            // Got data?\n            if( position >= 0 ) {\n                // End of relevant data?\n                if( /*!encode &&*/ position >= numSigBytes ){\n                    return -1;\n                }   // end if: got data\n                \n                if( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                    lineLength = 0;\n                    return '\\n';\n                }   // end if\n                else {\n                    lineLength++;   // This isn't important when decoding\n                                    // but throwing an extra \"if\" seems\n                                    // just as wasteful.\n                    \n                    int b = buffer[ position++ ];\n\n                    if( position >= bufferLength ) {\n                        position = -1;\n                    }   // end if: end\n\n                    return b & 0xFF; // This is how you \"cast\" a byte that's\n                                     // intended to be unsigned.\n                }   // end else\n            }   // end if: position >= 0\n            \n            // Else error\n            else {\n                throw new java.io.IOException( \"Error in Base64 code reading stream.\" );\n            }   // end else\n        }   // end read\n        \n        \n        /**\n         * Calls {@link #read()} repeatedly until the end of stream\n         * is reached or <var>len</var> bytes are read.\n         * Returns number of bytes read into array or -1 if\n         * end of stream is encountered.\n         *\n         * @param dest array to hold values\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @return bytes read into array or -1 if end of stream is encountered.\n         * @since 1.3\n         */\n        @Override\n        public int read( byte[] dest, int off, int len ) \n        throws java.io.IOException {\n            int i;\n            int b;\n            for( i = 0; i < len; i++ ) {\n                b = read();\n                \n                if( b >= 0 ) {\n                    dest[off + i] = (byte) b;\n                }\n                else if( i == 0 ) {\n                    return -1;\n                }\n                else {\n                    break; // Out of 'for' loop\n                } // Out of 'for' loop\n            }   // end for: each byte read\n            return i;\n        }   // end read\n        \n    }   // end inner class InputStream\n    \n    \n    \n    \n    \n    \n    /* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */\n    \n    \n    \n    /**\n     * A {@link Base64.OutputStream} will write data to another\n     * <tt>java.io.OutputStream</tt>, given in the constructor,\n     * and encode/decode to/from Base64 notation on the fly.\n     *\n     * @see Base64\n     * @since 1.3\n     */\n    public static class OutputStream extends java.io.FilterOutputStream {\n        \n        private boolean encode;\n        private int     position;\n        private byte[]  buffer;\n        private int     bufferLength;\n        private int     lineLength;\n        private boolean breakLines;\n        private byte[]  b4;         // Scratch used in a few places\n        private boolean suspendEncoding;\n        private int     options;    // Record for later\n        private byte[]  decodabet;  // Local copies to avoid extra method calls\n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in ENCODE mode.\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out ) {\n            this( out, ENCODE );\n        }   // end constructor\n        \n        \n        /**\n         * Constructs a {@link Base64.OutputStream} in\n         * either ENCODE or DECODE mode.\n         * <p>\n         * Valid options:<pre>\n         *   ENCODE or DECODE: Encode or Decode as data is read.\n         *   DO_BREAK_LINES: don't break lines at 76 characters\n         *     (only meaningful when encoding)</i>\n         * </pre>\n         * <p>\n         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>\n         *\n         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.\n         * @param options Specified options.\n         * @see Base64#ENCODE\n         * @see Base64#DECODE\n         * @see Base64#DO_BREAK_LINES\n         * @since 1.3\n         */\n        public OutputStream( java.io.OutputStream out, int options ) {\n            super( out );\n            this.breakLines   = (options & DO_BREAK_LINES) != 0;\n            this.encode       = (options & ENCODE) != 0;\n            this.bufferLength = encode ? 3 : 4;\n            this.buffer       = new byte[ bufferLength ];\n            this.position     = 0;\n            this.lineLength   = 0;\n            this.suspendEncoding = false;\n            this.b4           = new byte[4];\n            this.options      = options;\n            this.decodabet    = getDecodabet(options);\n        }   // end constructor\n        \n        \n        /**\n         * Writes the byte to the output stream after\n         * converting to/from Base64 notation.\n         * When encoding, bytes are buffered three\n         * at a time before the output stream actually\n         * gets a write() call.\n         * When decoding, bytes are buffered four\n         * at a time.\n         *\n         * @param theByte the byte to write\n         * @since 1.3\n         */\n        @Override\n        public void write(int theByte) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theByte );\n                return;\n            }   // end if: supsended\n            \n            // Encode?\n            if( encode ) {\n                buffer[ position++ ] = (byte)theByte;\n                if( position >= bufferLength ) { // Enough to encode.\n                \n                    this.out.write( encode3to4( b4, buffer, bufferLength, options ) );\n\n                    lineLength += 4;\n                    if( breakLines && lineLength >= MAX_LINE_LENGTH ) {\n                        this.out.write( NEW_LINE );\n                        lineLength = 0;\n                    }   // end if: end of line\n\n                    position = 0;\n                }   // end if: enough to output\n            }   // end if: encoding\n\n            // Else, Decoding\n            else {\n                // Meaningful Base64 character?\n                if( decodabet[ theByte & 0x7f ] > WHITE_SPACE_ENC ) {\n                    buffer[ position++ ] = (byte)theByte;\n                    if( position >= bufferLength ) { // Enough to output.\n                    \n                        int len = Base64.decode4to3( buffer, 0, b4, 0, options );\n                        out.write( b4, 0, len );\n                        position = 0;\n                    }   // end if: enough to output\n                }   // end if: meaningful base64 character\n                else if( decodabet[ theByte & 0x7f ] != WHITE_SPACE_ENC ) {\n                    throw new java.io.IOException( \"Invalid character in Base64 data.\" );\n                }   // end else: not white space either\n            }   // end else: decoding\n        }   // end write\n        \n        \n        \n        /**\n         * Calls {@link #write(int)} repeatedly until <var>len</var> \n         * bytes are written.\n         *\n         * @param theBytes array from which to read bytes\n         * @param off offset for array\n         * @param len max number of bytes to read into array\n         * @since 1.3\n         */\n        @Override\n        public void write( byte[] theBytes, int off, int len ) \n        throws java.io.IOException {\n            // Encoding suspended?\n            if( suspendEncoding ) {\n                this.out.write( theBytes, off, len );\n                return;\n            }   // end if: supsended\n            \n            for( int i = 0; i < len; i++ ) {\n                write( theBytes[ off + i ] );\n            }   // end for: each byte written\n            \n        }   // end write\n        \n        \n        \n        /**\n         * Method added by PHIL. [Thanks, PHIL. -Rob]\n         * This pads the buffer without closing the stream.\n         * @throws java.io.IOException  if there's an error.\n         */\n        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n\n        \n        /** \n         * Flushes and closes (I think, in the superclass) the stream. \n         *\n         * @since 1.3\n         */\n        @Override\n        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n            \n            buffer = null;\n            out    = null;\n        }   // end close\n        \n        \n        \n        /**\n         * Suspends encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @throws java.io.IOException  if there's an error flushing\n         * @since 1.5.1\n         */\n        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n        \n        \n        /**\n         * Resumes encoding of the stream.\n         * May be helpful if you need to embed a piece of\n         * base64-encoded data in a stream.\n         *\n         * @since 1.5.1\n         */\n        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n        \n        \n        \n    }   // end inner class OutputStream\n    \n    \n}   // end class Base64\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "DefaultCamera",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GradientFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "GraphMetrics",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "Graphics2DOutput",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "ImageCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "StrokeFactory",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontCache",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "FontSlot",
                "org.graphstream.ui.swingViewer.util"
            ],
            [
                "DefaultView",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "SpriteRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "ElementRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "NodeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "Arrow",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "Shape",
                "org.graphstream.ui.swingViewer.basicRenderer.shapes"
            ],
            [
                "EdgeRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "SwingBasicGraphRenderer",
                "org.graphstream.ui.swingViewer.basicRenderer"
            ],
            [
                "GraphRendererBase",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "GraphRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "LayerRenderer",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "ViewPanel",
                "org.graphstream.ui.swingViewer"
            ],
            [
                "Layouts",
                "org.graphstream.ui.layout"
            ],
            [
                "Layout",
                "org.graphstream.ui.layout"
            ],
            [
                "LayoutRunner",
                "org.graphstream.ui.layout"
            ],
            [
                "NodeParticle",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "GraphCellData",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "EdgeSpring",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "Energies",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "BarnesHutLayout",
                "org.graphstream.ui.layout.springbox"
            ],
            [
                "LinLog",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "LinLogNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBoxNodeParticle",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "SpringBox",
                "org.graphstream.ui.layout.springbox.implementations"
            ],
            [
                "Point2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector2",
                "org.graphstream.ui.geom"
            ],
            [
                "Vector3",
                "org.graphstream.ui.geom"
            ],
            [
                "Point3",
                "org.graphstream.ui.geom"
            ],
            [
                "ViewerListener",
                "org.graphstream.ui.view"
            ],
            [
                "MouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "ShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultShortcutManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "FpsCounter",
                "org.graphstream.ui.view.util"
            ],
            [
                "CubicCurve",
                "org.graphstream.ui.view.util"
            ],
            [
                "DefaultMouseManager",
                "org.graphstream.ui.view.util"
            ],
            [
                "Selection",
                "org.graphstream.ui.view"
            ],
            [
                "ViewerPipe",
                "org.graphstream.ui.view"
            ],
            [
                "Viewer",
                "org.graphstream.ui.view"
            ],
            [
                "View",
                "org.graphstream.ui.view"
            ],
            [
                "Camera",
                "org.graphstream.ui.view"
            ],
            [
                "Sprite",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "InvalidSpriteIDException",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteManager",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "SpriteFactory",
                "org.graphstream.ui.spriteManager"
            ],
            [
                "StyleGroupListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "Colors",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Values",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetListener",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheetParserTokenManager",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParserConstants",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "StyleSheetParser",
                "org.graphstream.ui.graphicGraph.stylesheet.parser"
            ],
            [
                "Style",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleSheet",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "StyleConstants",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Selector",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Value",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "Rule",
                "org.graphstream.ui.graphicGraph.stylesheet"
            ],
            [
                "GraphicNode",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroup",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphPosLengthUtils",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicEdge",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElementChangeListener",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicGraph",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "StyleGroupSet",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicSprite",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "GraphicElement",
                "org.graphstream.ui.graphicGraph"
            ],
            [
                "VerboseSink",
                "org.graphstream.util"
            ],
            [
                "GraphListeners",
                "org.graphstream.util"
            ],
            [
                "Environment",
                "org.graphstream.util"
            ],
            [
                "GraphDiff",
                "org.graphstream.util"
            ],
            [
                "Filters",
                "org.graphstream.util"
            ],
            [
                "FilteredEdgeIterator",
                "org.graphstream.util"
            ],
            [
                "Parser",
                "org.graphstream.util.parser"
            ],
            [
                "ParserFactory",
                "org.graphstream.util.parser"
            ],
            [
                "TokenMgrError",
                "org.graphstream.util.parser"
            ],
            [
                "ParseException",
                "org.graphstream.util.parser"
            ],
            [
                "SimpleCharStream",
                "org.graphstream.util.parser"
            ],
            [
                "Token",
                "org.graphstream.util.parser"
            ],
            [
                "ISODateIO",
                "org.graphstream.util.time"
            ],
            [
                "ISODateComponent",
                "org.graphstream.util.time"
            ],
            [
                "FilteredNodeIterator",
                "org.graphstream.util"
            ],
            [
                "FixedArrayList",
                "org.graphstream.util.set"
            ],
            [
                "StepCounter",
                "org.graphstream.util"
            ],
            [
                "GraphSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeAttributes",
                "org.graphstream.util.cumulative"
            ],
            [
                "CumulativeSpells",
                "org.graphstream.util.cumulative"
            ],
            [
                "Filter",
                "org.graphstream.util"
            ],
            [
                "PipeAdapter",
                "org.graphstream.stream"
            ],
            [
                "GraphParseException",
                "org.graphstream.stream"
            ],
            [
                "ElementSink",
                "org.graphstream.stream"
            ],
            [
                "URLSource",
                "org.graphstream.stream.net"
            ],
            [
                "HTTPSource",
                "org.graphstream.stream.net"
            ],
            [
                "SourceAdapter",
                "org.graphstream.stream"
            ],
            [
                "AttributeSink",
                "org.graphstream.stream"
            ],
            [
                "GMLParserConstants",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParserTokenManager",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLContext",
                "org.graphstream.stream.file.gml"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.gml"
            ],
            [
                "KeyValues",
                "org.graphstream.stream.file.gml"
            ],
            [
                "GMLParser",
                "org.graphstream.stream.file.gml"
            ],
            [
                "FileSinkGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "TLPParserConstants",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParser",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "TLPParserTokenManager",
                "org.graphstream.stream.file.tlp"
            ],
            [
                "FileSinkFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceEdge",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkTikZ",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "DOTParser",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserConstants",
                "org.graphstream.stream.file.dot"
            ],
            [
                "DOTParserTokenManager",
                "org.graphstream.stream.file.dot"
            ],
            [
                "FileSink",
                "org.graphstream.stream.file"
            ],
            [
                "PajekContext",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "Graphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "NodeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeGraphics",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "EdgeMatrix",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserTokenManager",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "PajekParserConstants",
                "org.graphstream.stream.file.pajek"
            ],
            [
                "FileSourceXML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkBaseFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceParser",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSFiltered",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDOT",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS1And2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGraphML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceFactory",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkImages",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDynamicGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG",
                "org.graphstream.stream.file"
            ],
            [
                "GEXFSpell",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "SmartXMLWriter",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFElement",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdges",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValues",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFEdge",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFSpells",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttValue",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNodes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFNode",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFMeta",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttributes",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXF",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFGraph",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "GEXFAttribute",
                "org.graphstream.stream.file.gexf"
            ],
            [
                "OldFileSourceDGS",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "DGSParser",
                "org.graphstream.stream.file.dgs"
            ],
            [
                "FileSourceBase",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceDGS",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGSUtility",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceTLP",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkSVG2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSource",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceNCol",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourcePajek",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGPX",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceLGL",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF2",
                "org.graphstream.stream.file"
            ],
            [
                "FileSourceGML",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkGEXF",
                "org.graphstream.stream.file"
            ],
            [
                "FileSinkDGS",
                "org.graphstream.stream.file"
            ],
            [
                "ProxyPipe",
                "org.graphstream.stream"
            ],
            [
                "Sink",
                "org.graphstream.stream"
            ],
            [
                "Timeline",
                "org.graphstream.stream"
            ],
            [
                "Pipe",
                "org.graphstream.stream"
            ],
            [
                "SinkAdapter",
                "org.graphstream.stream"
            ],
            [
                "Replayable",
                "org.graphstream.stream"
            ],
            [
                "Source",
                "org.graphstream.stream"
            ],
            [
                "AnnotatedSink",
                "org.graphstream.stream"
            ],
            [
                "GraphReplay",
                "org.graphstream.stream"
            ],
            [
                "AttributePipe",
                "org.graphstream.stream"
            ],
            [
                "SinkTime",
                "org.graphstream.stream.sync"
            ],
            [
                "SourceTime",
                "org.graphstream.stream.sync"
            ],
            [
                "PipeBase",
                "org.graphstream.stream"
            ],
            [
                "ThreadProxyPipe",
                "org.graphstream.stream.thread"
            ],
            [
                "ThreadProxyPipeOld",
                "org.graphstream.stream.thread"
            ],
            [
                "RMISource",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterOut",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMISink",
                "org.graphstream.stream.rmi"
            ],
            [
                "RMIAdapterIn",
                "org.graphstream.stream.rmi"
            ],
            [
                "SourceBase",
                "org.graphstream.stream"
            ],
            [
                "NetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamReceiver",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamConstants",
                "org.graphstream.stream.netstream"
            ],
            [
                "NetStreamSender",
                "org.graphstream.stream.netstream"
            ],
            [
                "DefaultNetStreamDecoder",
                "org.graphstream.stream.netstream"
            ],
            [
                "Base64",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamUnpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Packer",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "Base64Unpacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "NetStreamPacker",
                "org.graphstream.stream.netstream.packing"
            ],
            [
                "AttributePredicate",
                "org.graphstream.stream"
            ],
            [
                "Element",
                "org.graphstream.graph"
            ],
            [
                "Node",
                "org.graphstream.graph"
            ],
            [
                "BreadthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "Graph",
                "org.graphstream.graph"
            ],
            [
                "EdgeRejectedException",
                "org.graphstream.graph"
            ],
            [
                "CompoundAttribute",
                "org.graphstream.graph"
            ],
            [
                "Structure",
                "org.graphstream.graph"
            ],
            [
                "DepthFirstIterator",
                "org.graphstream.graph"
            ],
            [
                "NullAttributeException",
                "org.graphstream.graph"
            ],
            [
                "IdAlreadyInUseException",
                "org.graphstream.graph"
            ],
            [
                "EdgeFactory",
                "org.graphstream.graph"
            ],
            [
                "ElementNotFoundException",
                "org.graphstream.graph"
            ],
            [
                "OneAttributeElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractElement",
                "org.graphstream.graph.implementations"
            ],
            [
                "AdjacencyListGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "DefaultGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "Graphs",
                "org.graphstream.graph.implementations"
            ],
            [
                "SingleGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "MultiNode",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractGraph",
                "org.graphstream.graph.implementations"
            ],
            [
                "AbstractEdge",
                "org.graphstream.graph.implementations"
            ],
            [
                "GraphFactory",
                "org.graphstream.graph"
            ],
            [
                "NodeFactory",
                "org.graphstream.graph"
            ],
            [
                "Edge",
                "org.graphstream.graph"
            ],
            [
                "Path",
                "org.graphstream.graph"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "gradientInArea",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a gradient in the given pixel area following the given style.\n * This produces a gradient only if the style fill-mode is compatible.\n *\n * @param x0\n *            The left corner of the area.\n * @param y0\n *            The bottom corner of the area.\n * @param width\n *            The area width.\n * @param height\n *            The area height.\n * @param style\n *            The style.\n * @return A gradient paint or null if the style does not specify a\n *         gradient.\n */\npublic static Paint gradientInArea(int x0, int y0, int width, int height, Style style) {\n    switch(style.getFillMode()) {\n        case GRADIENT_VERTICAL:\n            return linearGradientFromStyle(x0, y0, x0, y0 + height, style);\n        case GRADIENT_HORIZONTAL:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0, style);\n        case GRADIENT_DIAGONAL1:\n            return linearGradientFromStyle(x0, y0, x0 + width, y0 + height, style);\n        case GRADIENT_DIAGONAL2:\n            return linearGradientFromStyle(x0 + width, y0, x0, y0 + height, style);\n        case GRADIENT_RADIAL:\n            return radialGradientFromStyle(x0 + (width / 2), y0 + (height / 2), width > height ? width / 2 : height / 2, style);\n        default:\n            return null;\n    }\n}"
            ],
            [
                "linearGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a linear gradient between two given points corresponding to the\n * given style.\n *\n * @param x0\n *            The start point abscissa.\n * @param y0\n *            The start point ordinate.\n * @param x1\n *            The end point abscissa.\n * @param y1\n *            The end point ordinate.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a linear gradient or there is only\n *         one fill colour).\n */\npublic static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style) {\n    Paint paint = null;\n    if (style.getFillColorCount() > 1) {\n        switch(style.getFillMode()) {\n            case GRADIENT_DIAGONAL1:\n            case GRADIENT_DIAGONAL2:\n            case GRADIENT_HORIZONTAL:\n            case GRADIENT_VERTICAL:\n                if (version16)\n                    paint = new LinearGradientPaint(x0, y0, x1, y1, createFractions(style), createColors(style));\n                else\n                    paint = new GradientPaint(x0, y0, style.getFillColor(0), x1, y1, style.getFillColor(1));\n                break;\n            default:\n                break;\n        }\n    }\n    return paint;\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style) {\n    return radialGradientFromStyle(cx, cy, radius, cx, cy, style);\n}"
            ],
            [
                "radialGradientFromStyle",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "/**\n * Generate a radial gradient between whose center is at (cx,cy) with the\n * given radius. The focus (fx,fy) is the start position of the gradient in\n * the circle.\n *\n * @param cx\n *            The center point abscissa.\n * @param cy\n *            The center point ordinate.\n * @param fx\n *            The start point abscissa.\n * @param fy\n *            The start point ordinate.\n * @param radius\n *            The gradient radius.\n * @param style\n *            The style.\n * @return A paint for the gradient or null if the style specifies no\n *         gradient (the fill mode is not a radial gradient or there is only\n *         one fill colour).\n */\npublic static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style) {\n    Paint paint = null;\n    if (version16) {\n        if (style.getFillColorCount() > 1 && style.getFillMode() == FillMode.GRADIENT_RADIAL) {\n            float[] fractions = createFractions(style);\n            Color[] colors = createColors(style);\n            paint = new RadialGradientPaint(cx, cy, radius, fx, fy, fractions, colors, MultipleGradientPaint.CycleMethod.REFLECT);\n        }\n    }\n    return paint;\n}"
            ],
            [
                "createFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static float[] createFractions(Style style) {\n    int n = style.getFillColorCount();\n    if (n < predefFractions.length)\n        return predefFractions[n];\n    float[] fractions = new float[n];\n    float div = 1f / (n - 1);\n    for (int i = 1; i < (n - 1); i++) fractions[i] = div * i;\n    fractions[0] = 0f;\n    fractions[n - 1] = 1f;\n    return fractions;\n}"
            ],
            [
                "createColors",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "protected static Color[] createColors(Style style) {\n    int n = style.getFillColorCount();\n    Color[] colors = new Color[n];\n    for (int i = 0; i < n; i++) colors[i] = style.getFillColor(i);\n    return colors;\n}"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * Default singleton image cache instance that can be shared. This method\n * and singleton must be used only in the Swing thread.\n *\n * @return The default singleton image cache instance.\n */\npublic static ImageCache defaultImageCache() {\n    if (defaultImageCache == null)\n        defaultImageCache = new ImageCache();\n    return defaultImageCache;\n}"
            ],
            [
                "generateStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "/**\n * Generate a stroke of the appropriate width and style according to the\n * given style and metrics.\n *\n * @param style\n *            The style to use.\n * @param metrics\n *            The metrics to use.\n * @return The stroke or null if the style specifies a \"none\" stroke mode.\n */\npublic static Stroke generateStroke(Style style, GraphMetrics metrics) {\n    if (style.getStrokeWidth().value == 0)\n        return null;\n    switch(style.getStrokeMode()) {\n        case PLAIN:\n            return generatePlainStroke(style, metrics);\n        case DOTS:\n            return generateDotsStroke(style, metrics);\n        case DASHES:\n            return generateDashesStroke(style, metrics);\n        default:\n        case NONE:\n            return null;\n    }\n}"
            ],
            [
                "generatePlainStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return plainLine1px; // XXX Not a good optimisation\n\t\t * else if( width == 2f ) return plainLine2px; // We draw the whole\n\t\t * graph in GU else if( width == 3f ) return plainLine3px; // In graph\n\t\t * units the width is never exactly 1,2, 5 ... else if( width == 5f )\n\t\t * return plainLine5px; else if( width == 10f ) return plainLine10px;\n\t\t * else\n\t\t */\n    {\n        return new BasicStroke(width);\n    }\n}"
            ],
            [
                "generateDotsStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dotsLine1px; else if( width == 2f ) return\n\t\t * dotsLine2px; else if( width == 3f ) return dotsLine3px; else if(\n\t\t * width == 5f ) return dotsLine5px; else if( width == 10f ) return\n\t\t * dotsLine10px; else\n\t\t */\n    {\n        dots[0] = (float) metrics.lengthToGu(1f, Units.PX);\n        dots[1] = dots[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dots, 0);\n    }\n}"
            ],
            [
                "generateDashesStroke",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics) {\n    float width = (float) metrics.lengthToGu(style.getStrokeWidth());\n    /*\n\t\t * if( width == 1f ) return dashesLine1px; else if( width == 2f ) return\n\t\t * dashesLine2px; else if( width == 3f ) return dashesLine3px; else if(\n\t\t * width == 5f ) return dashesLine5px; else if( width == 10f ) return\n\t\t * dashesLine10px; else\n\t\t */\n    {\n        dashes[0] = (float) metrics.lengthToGu(3f, Units.PX);\n        dashes[1] = dashes[0];\n        return new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1f, dashes, 0);\n    }\n}"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * Default singleton instance for shared font cache. This method and cache\n * can only be used in the Swing thread.\n *\n * @return The default singleton font cache instance.\n */\npublic static FontCache defaultFontCache() {\n    if (defaultFontCache == null)\n        defaultFontCache = new FontCache();\n    return defaultFontCache;\n}"
            ],
            [
                "newLayoutAlgorithm",
                "org.graphstream.ui.layout",
                "Layouts",
                "/**\n * Creates a layout according to the \"org.graphstream.ui.layout\" system property.\n *\n * @return The new layout or the default GraphStream \"Spring-Box\" layout if\n *         the \"gs.ui.layout\" system property is either not set or contains\n *         a class that cannot be found.\n */\npublic static Layout newLayoutAlgorithm() {\n    String layoutClassName;\n    try {\n        layoutClassName = System.getProperty(\"gs.ui.layout\");\n        if (layoutClassName != null) {\n            logger.log(Level.WARNING, \"\\\"gs.ui.layout\\\" is deprecated, use \\\"org.graphstream.ui.layout\\\" instead.\");\n        } else {\n            layoutClassName = System.getProperty(\"org.graphstream.ui.layout\");\n        }\n    } catch (AccessControlException e) {\n        layoutClassName = null;\n    }\n    if (layoutClassName != null) {\n        try {\n            Class<?> c = Class.forName(layoutClassName);\n            Object object = c.newInstance();\n            if (object instanceof Layout) {\n                return (Layout) object;\n            } else {\n                logger.warning(String.format(\"class '%s' is not a 'GraphRenderer'%n\", object));\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Cannot create layout.\", e);\n        }\n    }\n    return new org.graphstream.ui.layout.springbox.implementations.SpringBox(false);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `x0`, `x1`,\n * `x2` and `x3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The coordinate at parametric position `t` on the curve.\n */\npublic static double eval(double x0, double x1, double x2, double x3, double t) {\n    double tt = (1f - t);\n    return x0 * (tt * tt * tt) + 3f * x1 * t * (tt * tt) + 3f * x2 * (t * t) * tt + x3 * (t * t * t);\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Point2(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and return the position at parametric position `t` of the\n * curve.\n *\n * @return The point at parametric position `t` on the curve.\n */\npublic static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "eval",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Evaluate a cubic B\u00e9zier curve according to control points `p0`, `p1`,\n * `p2` and `p3` and store the position at parametric position `t` of the\n * curve in `result`.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result) {\n    result.set(eval(p0.x, p1.x, p2.x, p3.x, t), eval(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative of a cubic B\u00e9zier curve according to control points `x0`,\n * `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative at parametric position `t` on the curve.\n */\npublic static double derivative(double x0, double x1, double x2, double x3, double t) {\n    return 3 * (x3 - 3 * x2 + 3 * x1 - x0) * t * t + 2 * (3 * x2 - 6 * x1 + 3 * x0) * t + (3 * x1 - 3 * x0);\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Derivative point of a cubic B\u00e9zier curve according to control points\n * `x0`, `x1`, `x2` and `x3` at parametric position `t` of the curve.\n *\n * @return The derivative point at parametric position `t` on the curve.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t) {\n    return new Point2(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n}"
            ],
            [
                "derivative",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the derivative point of a cubic B\u00e9zier curve according\n * to control points `x0`, `x1`, `x2` and `x3` at parametric position `t` of\n * the curve.\n *\n * @return the given reference to `result`.\n */\npublic static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result) {\n    result.set(derivative(p0.x, p1.x, p2.x, p3.x, t), derivative(p0.y, p1.y, p2.y, p3.y, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t) {\n    return new Vector2(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * Store in `result` the perpendicular vector to the curve defined by\n * control points `p0`, `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return the given reference to `result`.\n */\npublic static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result) {\n    result.set(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n    return result;\n}"
            ],
            [
                "perpendicular",
                "org.graphstream.ui.view.util",
                "CubicCurve",
                "/**\n * The perpendicular vector to the curve defined by control points `p0`,\n * `p1`, `p2` and `p3` at parametric position `t`.\n *\n * @return A vector perpendicular to the curve at position `t`.\n */\npublic static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t) {\n    return new Point2D.Double(derivative(p0.y, p1.y, p2.y, p3.y, t), -derivative(p0.x, p1.x, p2.x, p3.x, t));\n}"
            ],
            [
                "newGraphRenderer",
                "org.graphstream.ui.view",
                "Viewer",
                "// Access\n/**\n * Create a new instance of the default graph renderer. The default graph\n * renderer class is given by the \"org.graphstream.ui.renderer\" system\n * property. If the class indicated by this property is not usable (not in\n * the class path, not of the correct type, etc.) or if the property is not\n * present a SwingBasicGraphRenderer is returned.\n */\npublic static GraphRenderer newGraphRenderer() {\n    String rendererClassName;\n    try {\n        rendererClassName = System.getProperty(\"gs.ui.renderer\");\n        if (rendererClassName != null) {\n            logger.warning(\"\\\"gs.ui.renderer\\\" is deprecated, use \\\"org.graphstream.ui.renderer\\\" instead.\");\n        } else {\n            rendererClassName = System.getProperty(\"org.graphstream.ui.renderer\");\n        }\n    } catch (AccessControlException e) {\n        rendererClassName = null;\n    }\n    if (rendererClassName == null)\n        return new SwingBasicGraphRenderer();\n    try {\n        Class<?> c = Class.forName(rendererClassName);\n        Object object = c.newInstance();\n        if (object instanceof GraphRenderer) {\n            return (GraphRenderer) object;\n        } else {\n            logger.warning(String.format(\"Class '%s' is not a 'GraphRenderer'.\", object));\n        }\n    } catch (Exception e) {\n        logger.log(Level.WARNING, \"Cannot create graph renderer.\", e);\n    }\n    return new SwingBasicGraphRenderer();\n}"
            ],
            [
                "getPositionValue",
                "org.graphstream.ui.spriteManager",
                "SpriteManager",
                "// Utility\nprotected static Values getPositionValue(Object value) {\n    if (value instanceof Object[]) {\n        Object[] values = (Object[]) value;\n        if (values.length == 4) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number && values[3] instanceof Style.Units) {\n                return new Values((Style.Units) values[3], ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[4] for sprite position.\");\n            }\n        } else if (values.length == 3) {\n            if (values[0] instanceof Number && values[1] instanceof Number && values[2] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue(), ((Number) values[1]).floatValue(), ((Number) values[2]).floatValue());\n            } else {\n                logger.warning(\"Cannot parse values[3] for sprite position.\");\n            }\n        } else if (values.length == 1) {\n            if (values[0] instanceof Number) {\n                return new Values(Units.GU, ((Number) values[0]).floatValue());\n            } else {\n                logger.warning(String.format(\"Sprite position percent is not a number.\"));\n            }\n        } else {\n            logger.warning(String.format(\"Cannot transform value '%s' (length=%d) into a position.\", Arrays.toString(values), values.length));\n        }\n    } else if (value instanceof Number) {\n        return new Values(Units.GU, ((Number) value).floatValue());\n    } else if (value instanceof Value) {\n        return new Values((Value) value);\n    } else if (value instanceof Values) {\n        return new Values((Values) value);\n    } else {\n        System.err.printf(\"GraphicGraph : cannot place sprite with posiiton '%s' (instance of %s)%n\", value, value.getClass().getName());\n    }\n    return null;\n}"
            ],
            [
                "convertColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert the given string value to a colour. It understands the 600\n * colour names of the X11 RGB data base. It also understands colours given\n * in the \"#FFFFFF\" format and the hexadecimal \"0xFFFFFF\" format. Finally,\n * it understands colours given as a \"rgb(1,10,100)\", CSS-like format. If\n * the input value is null, the result is null.\n *\n * @param anyValue\n *            The value to convert.\n * @return the converted colour or null if the conversion failed.\n */\npublic static Color convertColor(Object anyValue) {\n    if (anyValue == null)\n        return null;\n    if (anyValue instanceof Color)\n        return (Color) anyValue;\n    if (anyValue instanceof String) {\n        Color c = null;\n        String value = (String) anyValue;\n        if (value.startsWith(\"#\")) {\n            Matcher m = sharpColor1.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 7) {\n                    try {\n                        c = Color.decode(value);\n                        return c;\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 9) {\n                    int r = Integer.parseInt(m.group(1), 16);\n                    int g = Integer.parseInt(m.group(2), 16);\n                    int b = Integer.parseInt(m.group(3), 16);\n                    int a = Integer.parseInt(m.group(4), 16);\n                    return new Color(r, g, b, a);\n                }\n            }\n            m = sharpColor2.matcher(value);\n            if (m.matches()) {\n                if (value.length() >= 4) {\n                    int r = Integer.parseInt(m.group(1), 16) * 16;\n                    int g = Integer.parseInt(m.group(2), 16) * 16;\n                    int b = Integer.parseInt(m.group(3), 16) * 16;\n                    int a = 255;\n                    if (value.length() == 5)\n                        a = Integer.parseInt(m.group(4), 16) * 16;\n                    return new Color(r, g, b, a);\n                }\n            }\n        } else if (value.startsWith(\"rgb\")) {\n            Matcher m = cssColorA.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                int a = Integer.parseInt(m.group(4));\n                return new Color(r, g, b, a);\n            }\n            m = cssColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        } else if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n            Matcher m = hexaColor.matcher(value);\n            if (m.matches()) {\n                if (value.length() == 8) {\n                    try {\n                        return Color.decode(value);\n                    } catch (NumberFormatException e) {\n                        c = null;\n                    }\n                } else if (value.length() == 10) {\n                    String r = m.group(1);\n                    String g = m.group(2);\n                    String b = m.group(3);\n                    String a = m.group(4);\n                    return new Color(Integer.parseInt(r, 16), Integer.parseInt(g, 16), Integer.parseInt(b, 16), Integer.parseInt(a, 16));\n                }\n            }\n        } else if (value.startsWith(\"java.awt.Color[\")) {\n            Matcher m = awtColor.matcher(value);\n            if (m.matches()) {\n                int r = Integer.parseInt(m.group(1));\n                int g = Integer.parseInt(m.group(2));\n                int b = Integer.parseInt(m.group(3));\n                return new Color(r, g, b);\n            }\n        }\n        return colorMap.get(value.toLowerCase());\n    }\n    // TODO throw an exception instead ??\n    return null;\n}"
            ],
            [
                "convertLabel",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Check if the given value is an instance of CharSequence (String is) and\n * return it as a string. Else return null. If the input value is null, the\n * return value is null. If the value returned is larger than 128\n * characters, this method cuts it to 128 characters. TODO: allow to set the\n * max length of these strings.\n *\n * @param value\n *            The value to convert.\n * @return The corresponding string, or null.\n */\npublic static String convertLabel(Object value) {\n    String label = null;\n    if (value != null) {\n        if (value instanceof CharSequence)\n            label = ((CharSequence) value).toString();\n        else\n            label = value.toString();\n        if (label.length() > 128)\n            label = String.format(\"%s...\", label.substring(0, 128));\n    }\n    return label;\n}"
            ],
            [
                "convertWidth",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Try to convert an arbitrary value to a float. If it is a descendant of\n * Number, the float value is returned. If it is a string, a conversion is\n * tried to change it into a number and if successful, this number is\n * returned as a float. Else, the -1 value is returned as no width can be\n * negative to indicate the conversion failed. If the input is null, the\n * return value is -1.\n *\n * @param value\n *            The input to convert.\n * @return The value or -1 if the conversion failed. TODO should be named\n *         convertNumber\n */\npublic static float convertWidth(Object value) {\n    if (value instanceof CharSequence) {\n        try {\n            float val = Float.parseFloat(((CharSequence) value).toString());\n            return val;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    } else if (value instanceof Number) {\n        return ((Number) value).floatValue();\n    }\n    return -1;\n}"
            ],
            [
                "convertValue",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert an object to a value with units. The object can be a number, in\n * which case the value returned contains this number in pixel units. The\n * object can be a string. In this case the strings understood by this\n * method are of the form (spaces, number, spaces, unit, spaces). For\n * example \"3px\", \"45gu\", \"5.5%\", \" 25.3  gu \", \"4\", \"   28.1  \".\n *\n * @param value\n *            A Number or a CharSequence.\n * @return A value.\n */\npublic static Value convertValue(Object value) {\n    if (value instanceof CharSequence) {\n        CharSequence string = (CharSequence) value;\n        //\t\t\tif (string == null)\n        //\t\t\t\tthrow new RuntimeException(\"null size string ...\");\n        if (string.length() < 0)\n            throw new RuntimeException(\"empty size string ...\");\n        Matcher m = numberUnit.matcher(string);\n        if (m.matches())\n            return new Value(convertUnit(m.group(2)), Float.parseFloat(m.group(1)));\n        m = number.matcher(string);\n        if (m.matches())\n            return new Value(Units.PX, Float.parseFloat(m.group(1)));\n        throw new RuntimeException(String.format(\"string is not convertible to a value (%s)\", string));\n    } else if (value instanceof Number) {\n        return new Value(Units.PX, ((Number) value).floatValue());\n    }\n    if (value == null)\n        throw new RuntimeException(\"cannot convert null value\");\n    throw new RuntimeException(String.format(\"value is of class %s%n\", value.getClass().getName()));\n}"
            ],
            [
                "convertUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Convert \"gu\", \"px\" and \"%\" to Units.GU, Units.PX, Units.PERCENTS.\n */\nprotected static Units convertUnit(String unit) {\n    if (unit.equals(\"gu\"))\n        return Units.GU;\n    else if (unit.equals(\"px\"))\n        return Units.PX;\n    else if (unit.equals(\"%\"))\n        return Units.PERCENTS;\n    return Units.PX;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static double[] nodePosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePosition(node);\n    return null;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Retrieve a node position from its attributes (\"x\", \"y\", \"z\", or \"xy\", or\n * \"xyz\").\n *\n * @param id\n *            The node identifier.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node, or null if the node is not part of the\n *         graph.\n */\npublic static Point3 nodePointPosition(Graph graph, String id) {\n    Node node = graph.getNode(id);\n    if (node != null)\n        return nodePointPosition(node);\n    return null;\n}"
            ],
            [
                "nodePosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated array of three floats containing the (x,y,z)\n *         position of the node.\n */\npublic static double[] nodePosition(Node node) {\n    double[] xyz = new double[3];\n    nodePosition(node, xyz);\n    return xyz;\n}"
            ],
            [
                "nodePointPosition",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #nodePointPosition(Graph,String)} but use an existing node as\n * argument.\n *\n * @param node\n *            The node to consider.\n * @return A newly allocated point containing the (x,y,z)\n *         position of the node.\n */\npublic static Point3 nodePointPosition(Node node) {\n    Point3 pos = new Point3();\n    nodePosition(node, pos);\n    return pos;\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Compute the edge length of the given edge according to its two nodes\n * positions.\n *\n * @param id\n *            The identifier of the edge.\n * @return The edge length or -1 if the nodes of the edge have no positions.\n * @throws RuntimeException\n *             If the edge cannot be found.\n */\npublic static double edgeLength(Graph graph, String id) {\n    Edge edge = graph.getEdge(id);\n    if (edge != null)\n        return edgeLength(edge);\n    throw new RuntimeException(\"edge '\" + id + \"' cannot be found\");\n}"
            ],
            [
                "edgeLength",
                "org.graphstream.ui.graphicGraph",
                "GraphPosLengthUtils",
                "/**\n * Like {@link #edgeLength(Graph,String)} but use an existing edge as\n * argument.\n *\n * @param edge\n * @return The edge length or -1 if the nodes of the edge have no positions.\n */\npublic static double edgeLength(Edge edge) {\n    double[] xyz0 = nodePosition(edge.getNode0());\n    double[] xyz1 = nodePosition(edge.getNode1());\n    if (xyz0 == null || xyz1 == null)\n        return -1;\n    xyz0[0] = xyz1[0] - xyz0[0];\n    xyz0[1] = xyz1[1] - xyz0[1];\n    xyz0[2] = xyz1[2] - xyz0[2];\n    return Math.sqrt(xyz0[0] * xyz0[0] + xyz0[1] * xyz0[1] + xyz0[2] * xyz0[2]);\n}"
            ],
            [
                "getGlobalEnvironment",
                "org.graphstream.util",
                "Environment",
                "// --------- Static methods -----------\n/**\n * Access to the global shared environment for the whole JVM. This method\n * allows to access a shared environment, that can be read and written from\n * anywhere.\n * @return A singleton instance of the global environment.\n */\npublic static Environment getGlobalEnvironment() {\n    if (GLOBAL_ENV == null)\n        GLOBAL_ENV = new Environment();\n    return GLOBAL_ENV;\n}"
            ],
            [
                "falseFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> falseFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return false;\n        }\n    };\n}"
            ],
            [
                "trueFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> trueFilter() {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return true;\n        }\n    };\n}"
            ],
            [
                "byAttributeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue) {\n    return new ByAttributeFilter<T>(key, expectedValue);\n}"
            ],
            [
                "separateNodeAndEdgeFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter) {\n    return new SeparateNodeEdgeFilter<T, U>(nodeFilter, edgeFilter);\n}"
            ],
            [
                "byExtremitiesFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f) {\n    return new ExtremitiesFilter<T, U>(f);\n}"
            ],
            [
                "byIdFilter",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> byIdFilter(String idPattern) {\n    return new ByIdFilter<T>(idPattern);\n}"
            ],
            [
                "isContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e);\n        }\n    };\n}"
            ],
            [
                "isIdContained",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set) {\n    return new Filter<T>() {\n\n        public boolean isAvailable(T e) {\n            return set.contains(e.getId());\n        }\n    };\n}"
            ],
            [
                "and",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2) {\n    return new AndFilter<T>(f1, f2);\n}"
            ],
            [
                "or",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2) {\n    return new OrFilter<T>(f1, f2);\n}"
            ],
            [
                "xor",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2) {\n    return new XorFilter<T>(f1, f2);\n}"
            ],
            [
                "not",
                "org.graphstream.util",
                "Filters",
                "public static <T extends Element> Filter<T> not(Filter<T> f) {\n    return new NotFilter<T>(f);\n}"
            ],
            [
                "addEscapes",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Replaces unprintable characters by their escaped (or unicode escaped)\n * equivalents in the given string\n */\nprotected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "LexicalError",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Returns a detailed message for the Error when it is thrown by the token\n * manager to indicate a lexical error. Parameters : EOFSeen : indicates if\n * EOF caused the lexical error curLexState : lexical state in which this\n * error occurred errorLine : line number when the error occurred\n * errorColumn : column number when the error occurred errorAfter : prefix\n * that was seen before this error occurred curchar : the offending\n * character Note: You can customize the lexical error message by modifying\n * this method.\n */\nprotected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return (\"Lexical error at line \" + errorLine + \", column \" + errorColumn + \".  Encountered: \" + (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int) curChar + \"), \") + \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n}"
            ],
            [
                "add_escapes",
                "org.graphstream.util.parser",
                "ParseException",
                "/**\n * Used to convert raw characters to their escaped version when these raw\n * version cannot be used as part of an ASCII string literal.\n */\nstatic String add_escapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n        switch(str.charAt(i)) {\n            case 0:\n                continue;\n            case '\\b':\n                retval.append(\"\\\\b\");\n                continue;\n            case '\\t':\n                retval.append(\"\\\\t\");\n                continue;\n            case '\\n':\n                retval.append(\"\\\\n\");\n                continue;\n            case '\\f':\n                retval.append(\"\\\\f\");\n                continue;\n            case '\\r':\n                retval.append(\"\\\\r\");\n                continue;\n            case '\\\"':\n                retval.append(\"\\\\\\\"\");\n                continue;\n            case '\\'':\n                retval.append(\"\\\\\\'\");\n                continue;\n            case '\\\\':\n                retval.append(\"\\\\\\\\\");\n                continue;\n            default:\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                    String s = \"0000\" + Integer.toString(ch, 16);\n                    retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n                } else {\n                    retval.append(ch);\n                }\n                continue;\n        }\n    }\n    return retval.toString();\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "/**\n * Returns a new Token object, by default. However, if you want, you can\n * create and return subclass objects based on the value of ofKind. Simply\n * add the cases to the switch for all those special cases. For example, if\n * you have a subclass of Token called IDToken that you want to create if\n * ofKind is ID, simply add something like :\n *\n * case MyParserConstants.ID : return new IDToken(ofKind, image);\n *\n * to the following switch statement. Then you can cast matchedToken\n * variable to the appropriate type and use sit in your lexical actions.\n */\npublic static Token newToken(int ofKind, String image) {\n    switch(ofKind) {\n        default:\n            return new Token(ofKind, image);\n    }\n}"
            ],
            [
                "newToken",
                "org.graphstream.util.parser",
                "Token",
                "public static Token newToken(int ofKind) {\n    return newToken(ofKind, null);\n}"
            ],
            [
                "countStepInFile",
                "org.graphstream.util",
                "StepCounter",
                "/**\n * Count step contains in a file.\n *\n * @param path\n *            path to the file\n * @return count of step event in the file\n * @throws IOException\n * @see org.graphstream.stream.file.FileSourceFactory\n */\npublic static int countStepInFile(String path) throws IOException {\n    StepCounter counter = new StepCounter();\n    FileSource source = FileSourceFactory.sourceFor(path);\n    source.addElementSink(counter);\n    source.readAll(path);\n    return counter.getStepCount();\n}"
            ],
            [
                "GET",
                "org.graphstream.stream.net",
                "HTTPSource",
                "@SuppressWarnings(\"unchecked\")\nprotected static HashMap<String, Object> GET(HttpExchange ex) {\n    HashMap<String, Object> get = new HashMap<String, Object>();\n    String[] args = ex.getRequestURI().getRawQuery().split(\"[&]\");\n    for (String arg : args) {\n        String[] kv = arg.split(\"[=]\");\n        String k, v;\n        k = null;\n        v = null;\n        try {\n            if (kv.length > 0)\n                k = URLDecoder.decode(kv[0], System.getProperty(\"file.encoding\"));\n            if (kv.length > 1)\n                v = URLDecoder.decode(kv[1], System.getProperty(\"file.encoding\"));\n            if (get.containsKey(k)) {\n                Object o = get.get(k);\n                if (o instanceof LinkedList<?>)\n                    ((LinkedList<Object>) o).add(v);\n                else {\n                    LinkedList<Object> l = new LinkedList<Object>();\n                    l.add(o);\n                    l.add(v);\n                    get.put(k, l);\n                }\n            } else {\n                get.put(k, v);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n    return get;\n}"
            ],
            [
                "sinkFor",
                "org.graphstream.stream.file",
                "FileSinkFactory",
                "/**\n * Looks at the file name given and its extension and propose a file output\n * for the format that match this extension.\n *\n * @param filename\n *            The file name where the graph will be written.\n * @return A file sink or null.\n */\npublic static FileSink sinkFor(String filename) {\n    if (filename.indexOf('.') > 0) {\n        String ext = filename.substring(filename.lastIndexOf('.') + 1);\n        ext = ext.toLowerCase();\n        if (ext2sink.containsKey(ext)) {\n            Class<? extends FileSink> fsink = ext2sink.get(ext);\n            try {\n                return fsink.newInstance();\n            } catch (InstantiationException e) {\n                e.printStackTrace();\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return null;\n}"
            ],
            [
                "formatId",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "protected static String formatId(String id) {\n    return \"node\" + id.replaceAll(\"\\\\W\", \"_\");\n}"
            ],
            [
                "getInt",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static int getInt(Token nb) throws ParseException {\n    try {\n        return Integer.parseInt(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not an integer\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "getReal",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "protected static double getReal(Token nb) throws ParseException {\n    try {\n        return Double.parseDouble(nb.image);\n    } catch (Exception e) {\n        throw new ParseException(String.format(\"%d:%d: %s not a real\", nb.beginLine, nb.beginColumn, nb.image));\n    }\n}"
            ],
            [
                "toColorValue",
                "org.graphstream.stream.file.pajek",
                "PajekContext",
                "public static String toColorValue(Token R, Token G, Token B) throws ParseException {\n    double r = getReal(R);\n    double g = getReal(G);\n    double b = getReal(B);\n    return String.format(\"rgb(%d, %d, %d)\", (int) (r * 255), (int) (g * 255), (int) (b * 255));\n}"
            ],
            [
                "sourceFor",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "/**\n * Create a file input for the given file name.\n *\n * <p>\n * This method first tests if the file is a regular file and is readable. If\n * so, it opens it and reads the magic cookie to test the known file formats\n * that can be inferred from their header. If it works, it returns a file\n * input for the format. Else it looks at the file name extension, and\n * returns a file input for the extension. Finally if all fail, it throws a\n * NotFoundException.\n * </p>\n *\n * <p>\n * Notice that this method only creates the file input and does not connect\n * it to a graph.\n * </p>\n *\n * @param fileName\n *            Name of the graph file.\n * @return A graph reader suitable for the fileName graph format.\n * @throws IOException\n *             If the file is not readable or accessible.\n */\npublic static FileSource sourceFor(String fileName) throws IOException {\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}"
            ],
            [
                "getXMLRootElement",
                "org.graphstream.stream.file",
                "FileSourceFactory",
                "public static String getXMLRootElement(String fileName) throws IOException {\n    FileReader stream = new FileReader(fileName);\n    XMLEventReader reader;\n    XMLEvent e;\n    String root;\n    try {\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        do {\n            e = reader.nextEvent();\n        } while (!e.isStartElement() && !e.isEndDocument());\n        if (e.isEndDocument())\n            throw new IOException(\"document ended before catching root element\");\n        root = e.asStartElement().getName().getLocalPart();\n        reader.close();\n        stream.close();\n        return root;\n    } catch (XMLStreamException ex) {\n        throw new IOException(ex);\n    } catch (FactoryConfigurationError ex) {\n        throw new IOException(ex);\n    }\n}"
            ],
            [
                "formatStringForQuoting",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String formatStringForQuoting(String str) {\n    return str.replaceAll(\"(^|[^\\\\\\\\])\\\"\", \"$1\\\\\\\\\\\"\");\n}"
            ],
            [
                "attributeString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String attributeString(String key, Object value, boolean remove) {\n    if (key == null || key.length() == 0)\n        return null;\n    if (remove) {\n        return String.format(\" -\\\"%s\\\"\", key);\n    } else {\n        if (value != null && value.getClass().isArray())\n            return String.format(\" \\\"%s\\\":%s\", key, arrayString(value));\n        else\n            return String.format(\" \\\"%s\\\":%s\", key, valueString(value));\n    }\n}"
            ],
            [
                "arrayString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String arrayString(Object value) {\n    if (value != null && value.getClass().isArray()) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        if (Array.getLength(value) == 0)\n            sb.append(\"\\\"\\\"\");\n        else\n            sb.append(arrayString(Array.get(value, 0)));\n        for (int i = 1; i < Array.getLength(value); ++i) sb.append(String.format(\",%s\", arrayString(Array.get(value, i))));\n        sb.append(\"}\");\n        return sb.toString();\n    } else {\n        return valueString(value);\n    }\n}"
            ],
            [
                "valueString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String valueString(Object value) {\n    if (value == null)\n        return \"\\\"\\\"\";\n    if (value instanceof CharSequence) {\n        if (value instanceof String)\n            return String.format(\"\\\"%s\\\"\", formatStringForQuoting((String) value));\n        else\n            return String.format(\"\\\"%s\\\"\", (CharSequence) value);\n    } else if (value instanceof Number) {\n        Number nval = (Number) value;\n        if (value instanceof Integer || value instanceof Short || value instanceof Byte || value instanceof Long)\n            return String.format(Locale.US, \"%d\", nval.longValue());\n        else\n            return String.format(Locale.US, \"%f\", nval.doubleValue());\n    } else if (value instanceof Boolean) {\n        return String.format(Locale.US, \"%b\", ((Boolean) value));\n    } else if (value instanceof Character) {\n        return String.format(\"\\\"%c\\\"\", ((Character) value).charValue());\n    } else if (value instanceof Object[]) {\n        Object[] array = (Object[]) value;\n        int n = array.length;\n        StringBuffer sb = new StringBuffer();\n        if (array.length > 0)\n            sb.append(valueString(array[0]));\n        for (int i = 1; i < n; i++) {\n            sb.append(\",\");\n            sb.append(valueString(array[i]));\n        }\n        return sb.toString();\n    } else if (value instanceof HashMap<?, ?> || value instanceof CompoundAttribute) {\n        HashMap<?, ?> hash;\n        if (value instanceof CompoundAttribute)\n            hash = ((CompoundAttribute) value).toHashMap();\n        else\n            hash = (HashMap<?, ?>) value;\n        return hashToString(hash);\n    } else if (value instanceof Color) {\n        Color c = (Color) value;\n        return String.format(\"#%02X%02X%02X%02X\", c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());\n    } else {\n        return String.format(\"\\\"%s\\\"\", value.toString());\n    }\n}"
            ],
            [
                "hashToString",
                "org.graphstream.stream.file",
                "FileSinkDGSUtility",
                "protected static String hashToString(HashMap<?, ?> hash) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[ \");\n    for (Object key : hash.keySet()) {\n        sb.append(attributeString(key.toString(), hash.get(key), false));\n        sb.append(\",\");\n    }\n    sb.append(']');\n    return sb.toString();\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n *\n * @param serializableObject The object to encode\n * @return The Base64-encoded object\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if serializedObject is null\n * @since 1.4\n */\npublic static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {\n    return encodeObject(serializableObject, NO_OPTIONS);\n}"
            ],
            [
                "encodeObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeObject\n/**\n * Serializes an object and returns the Base64-encoded\n * version of that serialized object.\n *\n * <p>As of v 2.3, if the object\n * cannot be serialized or there is another error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * The object is not GZip-compressed before being encoded.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n * </pre>\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * @param serializableObject The object to encode\n * @param options Specified options\n * @return The Base64-encoded object\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @since 2.0\n */\npublic static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {\n    if (serializableObject == null) {\n        throw new NullPointerException(\"Cannot serialize a null object.\");\n    }\n    // end if: null\n    // Streams\n    java.io.ByteArrayOutputStream baos = null;\n    java.io.OutputStream b64os = null;\n    java.util.zip.GZIPOutputStream gzos = null;\n    java.io.ObjectOutputStream oos = null;\n    try {\n        // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n        baos = new java.io.ByteArrayOutputStream();\n        b64os = new Base64.OutputStream(baos, ENCODE | options);\n        if ((options & GZIP) != 0) {\n            // Gzip\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            oos = new java.io.ObjectOutputStream(gzos);\n        } else {\n            // Not gzipped\n            oos = new java.io.ObjectOutputStream(b64os);\n        }\n        oos.writeObject(serializableObject);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch it and then throw it immediately so that\n        // the finally{} block is called for cleanup.\n        throw e;\n    } finally // end catch\n    {\n        try {\n            oos.close();\n        } catch (Exception e) {\n        }\n        try {\n            gzos.close();\n        } catch (Exception e) {\n        }\n        try {\n            b64os.close();\n        } catch (Exception e) {\n        }\n        try {\n            baos.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    // Return value according to relevant encoding.\n    try {\n        return new String(baos.toByteArray(), PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        // Fall back to some Java default\n        return new String(baos.toByteArray());\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encode\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * @param source The data to convert\n * @return The data in Base64-encoded form\n * @throws NullPointerException if source array is null\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int options) throws java.io.IOException {\n    return encodeBytes(source, 0, source.length, options);\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * Does not GZip-compress data.\n *\n * <p>As of v 2.3, if there is an error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @return The Base64-encoded data as a String\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 1.4\n */\npublic static String encodeBytes(byte[] source, int off, int len) {\n    // Since we're not going to have the GZIP encoding turned on,\n    // we're not going to have an java.io.IOException thrown, so\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n        encoded = encodeBytes(source, off, len, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : ex.getMessage();\n    }\n    // end catch\n    assert encoded != null;\n    return encoded;\n}"
            ],
            [
                "encodeBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Encodes a byte array into Base64 notation.\n * <p>\n * Example options:<pre>\n *   GZIP: gzip-compresses object before encoding it.\n *   DO_BREAK_LINES: break lines at 76 characters\n *     <i>Note: Technically, this makes your encoding non-compliant.</i>\n * </pre>\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or\n * <p>\n * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>\n *\n * <p>As of v 2.3, if there is an error with the GZIP stream,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned a null value, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.0\n */\npublic static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    byte[] encoded = encodeBytesToBytes(source, off, len, options);\n    // Return value according to relevant encoding.\n    try {\n        return new String(encoded, PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uue) {\n        return new String(encoded);\n    }\n    // end catch\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end encodeBytes\n/**\n * Similar to {@link #encodeBytes(byte[])} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @return The Base64-encoded data as a byte[] (of ASCII characters)\n * @throws NullPointerException if source array is null\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source) {\n    byte[] encoded = null;\n    try {\n        encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n        assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    }\n    return encoded;\n}"
            ],
            [
                "encodeBytesToBytes",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns\n * a byte array instead of instantiating a String. This is more efficient\n * if you're working with I/O streams and have large data sets to encode.\n *\n * @param source The data to convert\n * @param off Offset in array where conversion should begin\n * @param len Length of data to convert\n * @param options Specified options\n * @return The Base64-encoded data as a String\n * @see Base64#GZIP\n * @see Base64#DO_BREAK_LINES\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if source array is null\n * @throws IllegalArgumentException if source array, offset, or length are invalid\n * @since 2.3.1\n */\npublic static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {\n    if (source == null) {\n        throw new NullPointerException(\"Cannot serialize a null array.\");\n    }\n    // end if: null\n    if (off < 0) {\n        throw new IllegalArgumentException(\"Cannot have negative offset: \" + off);\n    }\n    // end if: off < 0\n    if (len < 0) {\n        throw new IllegalArgumentException(\"Cannot have length offset: \" + len);\n    }\n    // end if: len < 0\n    if (off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Cannot have offset of %d and length of %d with array of length %d\", off, len, source.length));\n    }\n    // end if: off < 0\n    // Compress?\n    if ((options & GZIP) != 0) {\n        java.io.ByteArrayOutputStream baos = null;\n        java.util.zip.GZIPOutputStream gzos = null;\n        Base64.OutputStream b64os = null;\n        try {\n            // GZip -> Base64 -> ByteArray\n            baos = new java.io.ByteArrayOutputStream();\n            b64os = new Base64.OutputStream(baos, ENCODE | options);\n            gzos = new java.util.zip.GZIPOutputStream(b64os);\n            gzos.write(source, off, len);\n            gzos.close();\n        }// end try\n         catch (java.io.IOException e) {\n            // Catch it and then throw it immediately so that\n            // the finally{} block is called for cleanup.\n            throw e;\n        } finally // end catch\n        {\n            try {\n                gzos.close();\n            } catch (Exception e) {\n            }\n            try {\n                b64os.close();\n            } catch (Exception e) {\n            }\n            try {\n                baos.close();\n            } catch (Exception e) {\n            }\n        }\n        // end finally\n        return baos.toByteArray();\n    } else // end if: compress\n    // Else, don't compress. Better not to use streams at all then.\n    {\n        boolean breakLines = (options & DO_BREAK_LINES) != 0;\n        //int    len43   = len * 4 / 3;\n        //byte[] outBuff = new byte[   ( len43 )                      // Main 4:3\n        //                           + ( (len % 3) > 0 ? 4 : 0 )      // Account for padding\n        //                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines\n        // Try to determine more precisely how big the array needs to be.\n        // If we get it right, we don't have to do an array copy, and\n        // we save a bunch of memory.\n        // Bytes needed for actual encoding\n        int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);\n        if (breakLines) {\n            // Plus extra newline characters\n            encLen += encLen / MAX_LINE_LENGTH;\n        }\n        byte[] outBuff = new byte[encLen];\n        int d = 0;\n        int e = 0;\n        int len2 = len - 2;\n        int lineLength = 0;\n        for (; d < len2; d += 3, e += 4) {\n            encode3to4(source, d + off, 3, outBuff, e, options);\n            lineLength += 4;\n            if (breakLines && lineLength >= MAX_LINE_LENGTH) {\n                outBuff[e + 4] = NEW_LINE;\n                e++;\n                lineLength = 0;\n            }\n            // end if: end of line\n        }\n        // en dfor: each piece of array\n        if (d < len) {\n            encode3to4(source, d + off, len - d, outBuff, e, options);\n            e += 4;\n        }\n        // end if: some padding needed\n        // Only resize array if we didn't guess it right.\n        if (e <= outBuff.length - 1) {\n            // If breaking lines and the last byte falls right at\n            // the line length (76 bytes per line), there will be\n            // one extra byte, and the array will need to be resized.\n            // Not too bad of an estimate on array size, I'd say.\n            byte[] finalOut = new byte[e];\n            System.arraycopy(outBuff, 0, finalOut, 0, e);\n            //System.err.println(\"Having to resize array from \" + outBuff.length + \" to \" + e );\n            return finalOut;\n        } else {\n            //System.err.println(\"No need to resize array.\");\n            return outBuff;\n        }\n    }\n    // end else: don't compress\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToBytes\n/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @return decoded data\n * @since 2.3.1\n */\npublic static byte[] decode(byte[] source) throws java.io.IOException {\n    byte[] decoded = null;\n    //        try {\n    decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);\n    //        } catch( java.io.IOException ex ) {\n    //            assert false : \"IOExceptions only come from GZipping, which is turned off: \" + ex.getMessage();\n    //        }\n    return decoded;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Low-level access to decoding ASCII characters in\n * the form of a byte array. <strong>Ignores GUNZIP option, if\n * it's set.</strong> This is not generally a recommended method,\n * although it is used internally as part of the decoding process.\n * Special case: if len = 0, an empty array is returned. Still,\n * if you need more speed and reduced memory footprint (and aren't\n * gzipping), consider this method.\n *\n * @param source The Base64 encoded data\n * @param off    The offset of where to begin decoding\n * @param len    The length of characters to decode\n * @param options Can specify options such as alphabet type to use\n * @return decoded data\n * @throws java.io.IOException If bogus characters exist in source data\n * @since 1.3\n */\npublic static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {\n    // Lots of error checking and exception throwing\n    if (source == null) {\n        throw new NullPointerException(\"Cannot decode null source array.\");\n    }\n    // end if\n    if (off < 0 || off + len > source.length) {\n        throw new IllegalArgumentException(String.format(\"Source array with length %d cannot have offset of %d and process %d bytes.\", source.length, off, len));\n    }\n    // end if\n    if (len == 0) {\n        return new byte[0];\n    } else if (len < 4) {\n        throw new IllegalArgumentException(\"Base64-encoded string must have at least four characters, but length specified was \" + len);\n    }\n    // end if\n    byte[] DECODABET = getDecodabet(options);\n    // Estimate on array size\n    int len34 = len * 3 / 4;\n    // Upper limit on size of output\n    byte[] outBuff = new byte[len34];\n    // Keep track of where we're writing\n    int outBuffPosn = 0;\n    // Four byte buffer from source, eliminating white space\n    byte[] b4 = new byte[4];\n    // Keep track of four byte input buffer\n    int b4Posn = 0;\n    // Source array counter\n    int i = 0;\n    // Special value from DECODABET\n    byte sbiDecode = 0;\n    for (i = off; i < off + len; i++) {\n        // Loop through source\n        sbiDecode = DECODABET[source[i] & 0xFF];\n        // White space, Equals sign, or legit Base64 character\n        // Note the values such as -5 and -9 in the\n        // DECODABETs at the top of the file.\n        if (sbiDecode >= WHITE_SPACE_ENC) {\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\n                // Save non-whitespace\n                b4[b4Posn++] = source[i];\n                if (b4Posn > 3) {\n                    // Time to decode?\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);\n                    b4Posn = 0;\n                    // If that was the equals sign, break out of 'for' loop\n                    if (source[i] == EQUALS_SIGN) {\n                        break;\n                    }\n                    // end if: equals sign\n                }\n                // end if: quartet built\n            }\n            // end if: equals sign or better\n        } else // end if: white space, equals sign or better\n        {\n            // There's a bad input character in the Base64 stream.\n            throw new java.io.IOException(String.format(\"Bad Base64 input character decimal %d in array position %d\", ((int) source[i]) & 0xFF, i));\n        }\n        // end else:\n    }\n    // each input character\n    byte[] out = new byte[outBuffPosn];\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\n    return out;\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @return the decoded data\n * @throws java.io.IOException If there is a problem\n * @since 1.4\n */\npublic static byte[] decode(String s) throws java.io.IOException {\n    return decode(s, NO_OPTIONS);\n}"
            ],
            [
                "decode",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Decodes data from Base64 notation, automatically\n * detecting gzip-compressed data and decompressing it.\n *\n * @param s the string to decode\n * @param options encode options such as URL_SAFE\n * @return the decoded data\n * @throws java.io.IOException if there is an error\n * @throws NullPointerException if <tt>s</tt> is null\n * @since 1.4\n */\npublic static byte[] decode(String s, int options) throws java.io.IOException {\n    if (s == null) {\n        throw new NullPointerException(\"Input string was null.\");\n    }\n    // end if\n    byte[] bytes;\n    try {\n        bytes = s.getBytes(PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.UnsupportedEncodingException uee) {\n        bytes = s.getBytes();\n    }\n    // end catch\n    //</change>\n    // Decode\n    bytes = decode(bytes, 0, bytes.length, options);\n    // Check to see if it's gzip-compressed\n    // GZIP Magic Two-Byte Number: 0x8b1f (35615)\n    boolean dontGunzip = (options & DONT_GUNZIP) != 0;\n    if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {\n        int head = ((int) bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);\n        if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {\n            java.io.ByteArrayInputStream bais = null;\n            java.util.zip.GZIPInputStream gzis = null;\n            java.io.ByteArrayOutputStream baos = null;\n            byte[] buffer = new byte[2048];\n            int length = 0;\n            try {\n                baos = new java.io.ByteArrayOutputStream();\n                bais = new java.io.ByteArrayInputStream(bytes);\n                gzis = new java.util.zip.GZIPInputStream(bais);\n                while ((length = gzis.read(buffer)) >= 0) {\n                    baos.write(buffer, 0, length);\n                }\n                // end while: reading input\n                // No error? Get new bytes.\n                bytes = baos.toByteArray();\n            }// end try\n             catch (java.io.IOException e) {\n                e.printStackTrace();\n                // Just return originally-decoded bytes\n            } finally // end catch\n            {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                }\n                try {\n                    gzis.close();\n                } catch (Exception e) {\n                }\n                try {\n                    bais.close();\n                } catch (Exception e) {\n                }\n            }\n            // end finally\n        }\n        // end if: gzipped\n    }\n    // end if: bytes.length >= 2\n    return bytes;\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decode\n/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n *\n * @param encodedObject The Base64 data to decode\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 1.5\n */\npublic static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException {\n    return decodeToObject(encodedObject, NO_OPTIONS, null);\n}"
            ],
            [
                "decodeToObject",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Attempts to decode Base64 data and deserialize a Java\n * Object within. Returns <tt>null</tt> if there was an error.\n * If <tt>loader</tt> is not null, it will be the class loader\n * used when deserializing.\n *\n * @param encodedObject The Base64 data to decode\n * @param options Various parameters related to decoding\n * @param loader Optional class loader to use in deserializing classes.\n * @return The decoded and deserialized object\n * @throws NullPointerException if encodedObject is null\n * @throws java.io.IOException if there is a general error\n * @throws ClassNotFoundException if the decoded object is of a\n *         class that cannot be found by the JVM\n * @since 2.3.4\n */\npublic static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException {\n    // Decode and gunzip if necessary\n    byte[] objBytes = decode(encodedObject, options);\n    java.io.ByteArrayInputStream bais = null;\n    java.io.ObjectInputStream ois = null;\n    Object obj = null;\n    try {\n        bais = new java.io.ByteArrayInputStream(objBytes);\n        // If no custom class loader is provided, use Java's builtin OIS.\n        if (loader == null) {\n            ois = new java.io.ObjectInputStream(bais);\n        } else // end if: no loader provided\n        // Else make a customized object input stream that uses\n        // the provided class loader.\n        {\n            ois = new java.io.ObjectInputStream(bais) {\n\n                @Override\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\n                    if (c == null) {\n                        return super.resolveClass(streamClass);\n                    } else {\n                        // Class loader knows of this class.\n                        return c;\n                    }\n                    // end else: not null\n                }\n            };\n            // end ois\n        }\n        // end else: no custom class loader\n        obj = ois.readObject();\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    }// end catch\n     catch (java.lang.ClassNotFoundException e) {\n        // Catch and throw in order to execute finally{}\n        throw e;\n    } finally // end catch\n    {\n        try {\n            bais.close();\n        } catch (Exception e) {\n        }\n        try {\n            ois.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return obj;\n}"
            ],
            [
                "decodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeToFile\n/**\n * Convenience method for reading a base64-encoded\n * file and decoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading encoded data\n * @return decoded byte array\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static byte[] decodeFromFile(String filename) throws java.io.IOException {\n    byte[] decodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        byte[] buffer = null;\n        int length = 0;\n        int numBytes = 0;\n        // Check for size of file\n        if (file.length() > Integer.MAX_VALUE) {\n            throw new java.io.IOException(\"File is too big for this convenience method (\" + file.length() + \" bytes).\");\n        }\n        // end if: file too big for int index\n        buffer = new byte[(int) file.length()];\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.DECODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        decodedData = new byte[length];\n        System.arraycopy(buffer, 0, decodedData, 0, length);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return decodedData;\n}"
            ],
            [
                "encodeFromFile",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "// end decodeFromFile\n/**\n * Convenience method for reading a binary file\n * and base64-encoding it.\n *\n * <p>As of v 2.3, if there is a error,\n * the method will throw an java.io.IOException. <b>This is new to v2.3!</b>\n * In earlier versions, it just returned false, but\n * in retrospect that's a pretty poor way to handle it.</p>\n *\n * @param filename Filename for reading binary data\n * @return base64-encoded string\n * @throws java.io.IOException if there is an error\n * @since 2.1\n */\npublic static String encodeFromFile(String filename) throws java.io.IOException {\n    String encodedData = null;\n    Base64.InputStream bis = null;\n    try {\n        // Set up some useful variables\n        java.io.File file = new java.io.File(filename);\n        // Need max() for math on small files (v2.2.1); Need +1 for a few corner cases (v2.3.5)\n        byte[] buffer = new byte[Math.max((int) (file.length() * 1.4 + 1), 40)];\n        int length = 0;\n        int numBytes = 0;\n        // Open a stream\n        bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)), Base64.ENCODE);\n        // Read until done\n        while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {\n            length += numBytes;\n        }\n        // end while\n        // Save in a variable to return\n        encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);\n    }// end try\n     catch (java.io.IOException e) {\n        // Catch and release to execute finally{}\n        throw e;\n    } finally // end catch: java.io.IOException\n    {\n        try {\n            bis.close();\n        } catch (Exception e) {\n        }\n    }\n    // end finally\n    return encodedData;\n}"
            ],
            [
                "unmutableGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "public static Graph unmutableGraph(Graph g) {\n    return null;\n}"
            ],
            [
                "synchronizedGraph",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Synchronizes a graph. The returned graph can be accessed and modified by\n * several threads. You lose genericity in methods returning edge or node\n * because each element (graph, nodes and edges) is wrapped into a\n * synchronized wrapper which breaks original elements class.\n *\n * @param g\n *            the graph to synchronize\n * @return a synchronized wrapper for g\n */\npublic static Graph synchronizedGraph(Graph g) {\n    return new SynchronizedGraph(g);\n}"
            ],
            [
                "merge",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Merge several graphs in one. A new graph is created, that will contain\n * the result. The method will try to create a graph of the same class that\n * the first graph to merge (it needs to have a constructor with a String).\n * Else, a MultiGraph is used.\n *\n * @param graphs\n *            graphs to merge\n * @return merge result\n */\npublic static Graph merge(Graph... graphs) {\n    if (graphs == null)\n        return new DefaultGraph(\"void-merge\");\n    String id = \"merge\";\n    for (Graph g : graphs) id += \"-\" + g.getId();\n    Graph result;\n    try {\n        Class<? extends Graph> cls = graphs[0].getClass();\n        result = cls.getConstructor(String.class).newInstance(id);\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", graphs[0].getClass().getName()));\n        result = new MultiGraph(id);\n    }\n    mergeIn(result, graphs);\n    return result;\n}"
            ],
            [
                "clone",
                "org.graphstream.graph.implementations",
                "Graphs",
                "/**\n * Clone a given graph with same node/edge structure and same attributes.\n *\n * @param g\n *            the graph to clone\n * @return a copy of g\n */\npublic static Graph clone(Graph g) {\n    Graph copy;\n    try {\n        Class<? extends Graph> cls = g.getClass();\n        copy = cls.getConstructor(String.class).newInstance(g.getId());\n    } catch (Exception e) {\n        logger.warning(String.format(\"Cannot create a graph of %s.\", g.getClass().getName()));\n        copy = new AdjacencyListGraph(g.getId());\n    }\n    copyAttributes(g, copy);\n    for (int i = 0; i < g.getNodeCount(); i++) {\n        Node source = g.getNode(i);\n        Node target = copy.addNode(source.getId());\n        copyAttributes(source, target);\n    }\n    for (int i = 0; i < g.getEdgeCount(); i++) {\n        Edge source = g.getEdge(i);\n        Edge target = copy.addEdge(source.getId(), source.getSourceNode().getId(), source.getTargetNode().getId(), source.isDirected());\n        copyAttributes(source, target);\n    }\n    return copy;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "version16",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static boolean version16 = false;"
            ],
            [
                "predefFractions",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[][] predefFractions = new float[11][];"
            ],
            [
                "predefFractions2",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions2 = { 0f, 1f };"
            ],
            [
                "predefFractions3",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions3 = { 0f, 0.5f, 1f };"
            ],
            [
                "predefFractions4",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };"
            ],
            [
                "predefFractions5",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };"
            ],
            [
                "predefFractions6",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };"
            ],
            [
                "predefFractions7",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };"
            ],
            [
                "predefFractions8",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };"
            ],
            [
                "predefFractions9",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };"
            ],
            [
                "predefFractions10",
                "org.graphstream.ui.swingViewer.util",
                "GradientFactory",
                "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };"
            ],
            [
                "defaultImageCache",
                "org.graphstream.ui.swingViewer.util",
                "ImageCache",
                "/**\n * The default singleton image cache instance.\n */\nprotected static ImageCache defaultImageCache;"
            ],
            [
                "dots",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dots = { 1f, 1f };"
            ],
            [
                "dashes",
                "org.graphstream.ui.swingViewer.util",
                "StrokeFactory",
                "protected static float[] dashes = { 3f, 3f };"
            ],
            [
                "defaultFontCache",
                "org.graphstream.ui.swingViewer.util",
                "FontCache",
                "/**\n * The default font cache.\n */\npublic static FontCache defaultFontCache;"
            ],
            [
                "NULL_POINT2",
                "org.graphstream.ui.geom",
                "Point2",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0).\n */\npublic static final Point2 NULL_POINT2 = new Point2(0, 0);"
            ],
            [
                "NULL_POINT3",
                "org.graphstream.ui.geom",
                "Point3",
                "// Attributes -- Shared\n/**\n * Specific point at (0,0,0).\n */\npublic static final Point3 NULL_POINT3 = new Point3(0, 0, 0);"
            ],
            [
                "DEFAULT_VIEW_ID",
                "org.graphstream.ui.view",
                "Viewer",
                "// Attributes\n/**\n * Name of the default view.\n */\npublic static String DEFAULT_VIEW_ID = \"defaultView\";"
            ],
            [
                "jjbitVec0",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.ui.graphicGraph.stylesheet.parser",
                "StyleSheetParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };"
            ],
            [
                "colorMap",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "// Static\n/**\n * A set of colour names mapped to real AWT Colour objects.\n */\nprotected static HashMap<String, Color> colorMap;"
            ],
            [
                "sharpColor1",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "sharpColor2",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a \"#FFFFFF\" colour is recognised.\n */\nprotected static Pattern sharpColor1, sharpColor2;"
            ],
            [
                "cssColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgb(1,2,3)\" colour is recognised.\n */\nprotected static Pattern cssColor;"
            ],
            [
                "cssColorA",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a CSS style \"rgba(1,2,3,4)\" colour is recognised.\n */\nprotected static Pattern cssColorA;"
            ],
            [
                "awtColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure that java.awt.Color.toString() strings are recognised\n * as colour.\n */\nprotected static Pattern awtColor;"
            ],
            [
                "hexaColor",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure an hexadecimal number is a recognised colour.\n */\nprotected static Pattern hexaColor;"
            ],
            [
                "numberUnit",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "number",
                "org.graphstream.ui.graphicGraph.stylesheet",
                "StyleConstants",
                "/**\n * Pattern to ensure a string is a Value in various units.\n */\nprotected static Pattern numberUnit, number;"
            ],
            [
                "acceptedAttribute",
                "org.graphstream.ui.graphicGraph",
                "GraphicElement",
                "// Overriding of standard attribute changing to filter them.\nprotected static Pattern acceptedAttribute;"
            ],
            [
                "DEFAULT_AN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CNA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CNR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DN_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_AE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CEA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CEC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CER_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_DE_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CGA_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGC_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";"
            ],
            [
                "DEFAULT_CGR_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";"
            ],
            [
                "DEFAULT_CL_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";"
            ],
            [
                "DEFAULT_ST_FORMAT",
                "org.graphstream.util",
                "VerboseSink",
                "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";"
            ],
            [
                "GLOBAL_ENV",
                "org.graphstream.util",
                "Environment",
                "// --------- Static attributes ---------\n/**\n * Global environment for the whole JVM. This global environment is\n * available <b>and editable</b> from everywhere. It is create as soon as\n * the {@link #getGlobalEnvironment()} static method is called if this field\n * was not yet initialized by any other mean.\n * @see #getGlobalEnvironment()\n */\npublic static Environment GLOBAL_ENV;"
            ],
            [
                "LEXICAL_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/*\n\t * Ordinals for various reasons why an Error of this type can be thrown.\n\t */\n/**\n * Lexical error occurred.\n */\npublic static final int LEXICAL_ERROR = 0;"
            ],
            [
                "STATIC_LEXER_ERROR",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * An attempt was made to create a second instance of a static token\n * manager.\n */\npublic static final int STATIC_LEXER_ERROR = 1;"
            ],
            [
                "INVALID_LEXICAL_STATE",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Tried to change to an invalid lexical state.\n */\npublic static final int INVALID_LEXICAL_STATE = 2;"
            ],
            [
                "LOOP_DETECTED",
                "org.graphstream.util.parser",
                "TokenMgrError",
                "/**\n * Detected (and bailed out of) an infinite loop in the token manager.\n */\npublic static final int LOOP_DETECTED = 3;"
            ],
            [
                "staticFlag",
                "org.graphstream.util.parser",
                "SimpleCharStream",
                "/**\n * Whether parser is static.\n */\npublic static final boolean staticFlag = false;"
            ],
            [
                "ABBREVIATED_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_WEEKDAY_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");"
            ],
            [
                "FULL_MONTH_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");"
            ],
            [
                "LOCALE_DATE_AND_TIME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);"
            ],
            [
                "CENTURY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");"
            ],
            [
                "DAY_OF_MONTH_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");"
            ],
            [
                "DATE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");"
            ],
            [
                "DAY_OF_MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");"
            ],
            [
                "DATE_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");"
            ],
            [
                "WEEK_BASED_YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "WEEK_BASED_YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "ABBREVIATED_MONTH_NAME_ALIAS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");"
            ],
            [
                "HOUR_OF_DAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");"
            ],
            [
                "HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");"
            ],
            [
                "DAY_OF_YEAR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");"
            ],
            [
                "MILLISECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");"
            ],
            [
                "EPOCH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent EPOCH = new EpochComponent();"
            ],
            [
                "MONTH",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");"
            ],
            [
                "MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");"
            ],
            [
                "NEW_LINE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");"
            ],
            [
                "AM_PM",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent AM_PM = new AMPMComponent();"
            ],
            [
                "LOCALE_CLOCK_TIME_12_HOUR",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");"
            ],
            [
                "HOUR_AND_MINUTE",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");"
            ],
            [
                "SECOND",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");"
            ],
            [
                "TABULATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");"
            ],
            [
                "TIME_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");"
            ],
            [
                "DAY_OF_WEEK_1_7",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_SUNDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");"
            ],
            [
                "WEEK_NUMBER_ISO8601",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");"
            ],
            [
                "DAY_OF_WEEK_0_6",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");"
            ],
            [
                "WEEK_OF_YEAR_FROM_MONDAY",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");"
            ],
            [
                "LOCALE_DATE_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");"
            ],
            [
                "LOCALE_TIME_REPRESENTATION",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");"
            ],
            [
                "YEAR_2_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");"
            ],
            [
                "YEAR_4_DIGITS",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");"
            ],
            [
                "UTC_OFFSET",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();"
            ],
            [
                "LOCALE_TIME_ZONE_NAME",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");"
            ],
            [
                "PERCENT",
                "org.graphstream.util.time",
                "ISODateComponent",
                "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoToken = { 0xff01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.gml",
                "GMLParserTokenManager",
                "static final long[] jjtoSkip = { 0x1eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoToken = { 0xffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.tlp",
                "TLPParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "XYZ_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Node attribute storing coordinates.\n */\npublic static final String XYZ_ATTR = \"xyz\";"
            ],
            [
                "WIDTH_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing width of the TikZ picture.\n */\npublic static final String WIDTH_ATTR = \"ui.tikz.width\";"
            ],
            [
                "HEIGHT_ATTR",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Graph attribute storing height of the TikZ picture.\n */\npublic static final String HEIGHT_ATTR = \"ui.tikz.height\";"
            ],
            [
                "DEFAULT_WIDTH",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_WIDTH = 10;"
            ],
            [
                "DEFAULT_HEIGHT",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "public static final double DEFAULT_HEIGHT = 10;"
            ],
            [
                "DISPLAY_MIN_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default minimum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MIN_SIZE_IN_MM = 2;"
            ],
            [
                "DISPLAY_MAX_SIZE_IN_MM",
                "org.graphstream.stream.file",
                "FileSinkTikZ",
                "/**\n * Define the default maximum size of nodes when using a dynamic size. This\n * size is in millimeter.\n */\npublic static final double DISPLAY_MAX_SIZE_IN_MM = 10;"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoToken = { 0x3ffffffc01L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.dot",
                "DOTParserTokenManager",
                "static final long[] jjtoSkip = { 0x7eL };"
            ],
            [
                "jjbitVec0",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };"
            ],
            [
                "jjnextStates",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };"
            ],
            [
                "jjstrLiteralImages",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Token literal values.\n */\npublic static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };"
            ],
            [
                "lexStateNames",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "/**\n * Lexer state names.\n */\npublic static final String[] lexStateNames = { \"DEFAULT\" };"
            ],
            [
                "jjtoToken",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoToken = { 0x3fffffffffffc9L };"
            ],
            [
                "jjtoSkip",
                "org.graphstream.stream.file.pajek",
                "PajekParserTokenManager",
                "static final long[] jjtoSkip = { 0x6L };"
            ],
            [
                "XMLNS",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";"
            ],
            [
                "XMLNS_XSI",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";"
            ],
            [
                "XMLNS_SL",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";"
            ],
            [
                "XMLNS_VIZ",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";"
            ],
            [
                "VERSION",
                "org.graphstream.stream.file.gexf",
                "GEXF",
                "public static final String VERSION = \"1.2\";"
            ],
            [
                "BUFFER_SIZE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "protected static final int BUFFER_SIZE = 4096;"
            ],
            [
                "ARRAY_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_OPEN = '{';"
            ],
            [
                "ARRAY_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int ARRAY_CLOSE = '}';"
            ],
            [
                "MAP_OPEN",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_OPEN = '[';"
            ],
            [
                "MAP_CLOSE",
                "org.graphstream.stream.file.dgs",
                "DGSParser",
                "public static final int MAP_CLOSE = ']';"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "FileSinkSVG2",
                "static int gradientId = 0;"
            ],
            [
                "gradientId",
                "org.graphstream.stream.file",
                "SVGStyle",
                "static int gradientId = 0;"
            ],
            [
                "TIME_PREFIX",
                "org.graphstream.stream",
                "Timeline",
                "public static final String TIME_PREFIX = \"time\";"
            ],
            [
                "SYNC_DISABLE_KEY",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Key used to disable synchro. Just run : java -DSYNC_DISABLE_KEY ...\n */\npublic static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";"
            ],
            [
                "disableSync",
                "org.graphstream.stream.sync",
                "SinkTime",
                "/**\n * Flag used to disable sync.\n */\nprotected static final boolean disableSync;"
            ],
            [
                "LIGHT_YELLOW",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String LIGHT_YELLOW = \"\u001b[33;1m\";"
            ],
            [
                "RESET",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "protected static final String RESET = \"\u001b[0m\";"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "NetStreamReceiver",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "BUFFER_INITIAL_SIZE",
                "org.graphstream.stream.netstream",
                "IncomingBuffer",
                "// Attributes\n// 65535, 4096\nprotected static final int BUFFER_INITIAL_SIZE = 8192;"
            ],
            [
                "EVENT_GETVERSION",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer for this protocol version. Certainly\n * useless.\n */\npublic static int EVENT_GETVERSION = 0x00;"
            ],
            [
                "EVENT_START",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Not used.\n */\npublic static int EVENT_START = 0x01;"
            ],
            [
                "EVENT_END",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Constant indicating that the client has disconnected.\n */\npublic static int EVENT_END = 0x02;"
            ],
            [
                "EVENT_ADD_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "//\n// ----------------------------------\n// GraphStream's graph events\n// ----------------------------------\n//\n/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_ADD_NODE = 0x10;"
            ],
            [
                "EVENT_DEL_NODE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a node id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE = 0x11;"
            ],
            [
                "EVENT_ADD_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an edge id (TYPE_STRING format), - an source node id\n * (TYPE_STRING format), - a target node id (TYPE_STRING format - a boolean\n * indicating if directed (TYPE_BOOLEAN format)\n */\npublic static int EVENT_ADD_EDGE = 0x12;"
            ],
            [
                "EVENT_DEL_EDGE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an edge id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE = 0x13;"
            ],
            [
                "EVENT_STEP",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by double (TYPE_DOUBLE format)\n */\npublic static int EVENT_STEP = 0x14;"
            ],
            [
                "EVENT_CLEARED",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n */\npublic static int EVENT_CLEARED = 0x15;"
            ],
            [
                "EVENT_ADD_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_GRAPH_ATTR = 0x16;"
            ],
            [
                "EVENT_CHG_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_GRAPH_ATTR = 0x17;"
            ],
            [
                "EVENT_DEL_GRAPH_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the attribute id (TYPE_STRING format)\n */\npublic static int EVENT_DEL_GRAPH_ATTR = 0x18;"
            ],
            [
                "EVENT_ADD_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_NODE_ATTR = 0x19;"
            ],
            [
                "EVENT_CHG_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_NODE_ATTR = 0x1a;"
            ],
            [
                "EVENT_DEL_NODE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the node id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_NODE_ATTR = 0x1b;"
            ],
            [
                "EVENT_ADD_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute value\n */\npublic static int EVENT_ADD_EDGE_ATTR = 0x1c;"
            ],
            [
                "EVENT_CHG_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - an attribute id (TYPE_STRING format) - the attribute TYPE -\n * the attribute old value - the attribute new value\n */\npublic static int EVENT_CHG_EDGE_ATTR = 0x1d;"
            ],
            [
                "EVENT_DEL_EDGE_ATTR",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by - the edge id (TYPE_STRING format) - the attribute id\n * (TYPE_STRING format)\n */\npublic static int EVENT_DEL_EDGE_ATTR = 0x1e;"
            ],
            [
                "TYPE_UNKNOWN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "// Values types\npublic static int TYPE_UNKNOWN = 0x00;"
            ],
            [
                "TYPE_BOOLEAN",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a byte who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN = 0x50;"
            ],
            [
                "TYPE_BOOLEAN_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of booleans. Followed by first, a 16-bits integer for the number\n * of booleans and then, a list of bytes who's value is 0 or 1\n */\npublic static int TYPE_BOOLEAN_ARRAY = 0x51;"
            ],
            [
                "TYPE_BYTE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a signed byte [-127,127]\n */\npublic static int TYPE_BYTE = 0x52;"
            ],
            [
                "TYPE_BYTE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of bytes. Followed by first, a 16-bits integer for the number of\n * integers and then, a list of signed bytes.\n */\npublic static int TYPE_BYTE_ARRAY = 0x53;"
            ],
            [
                "TYPE_SHORT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 16-bit signed integer (a short)\n */\npublic static int TYPE_SHORT = 0x54;"
            ],
            [
                "TYPE_SHORT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of shorts. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 16-bit signed shorts\n */\npublic static int TYPE_SHORT_ARRAY = 0x55;"
            ],
            [
                "TYPE_INT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 32-bit signed integer\n */\npublic static int TYPE_INT = 0x56;"
            ],
            [
                "TYPE_INT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of integers. Followed by first, a 16-bits integer for the number\n * of integers and then, a list of 32-bit signed integers\n */\npublic static int TYPE_INT_ARRAY = 0x57;"
            ],
            [
                "TYPE_LONG",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by an 64-bit signed integer\n */\npublic static int TYPE_LONG = 0x58;"
            ],
            [
                "TYPE_LONG_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An array of longs. Followed by first, a 16-bits integer for the number of\n * longs and then, a list of 62-bit signed integers\n */\npublic static int TYPE_LONG_ARRAY = 0x59;"
            ],
            [
                "TYPE_FLOAT",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a single precision 32-bits floating point number\n */\npublic static int TYPE_FLOAT = 0x5a;"
            ],
            [
                "TYPE_FLOAT_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * floats and then, a list of 32-bit floats\n */\npublic static int TYPE_FLOAT_ARRAY = 0x5b;"
            ],
            [
                "TYPE_DOUBLE",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Followed by a double precision 64-bits floating point number\n */\npublic static int TYPE_DOUBLE = 0x5c;"
            ],
            [
                "TYPE_DOUBLE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of double. Followed by first, a 16-bits integer for the number of\n * doubles and then, a list of 64-bit doubles\n */\npublic static int TYPE_DOUBLE_ARRAY = 0x5d;"
            ],
            [
                "TYPE_STRING",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Array of characters. Followed by first, a 16-bits integer for the size in\n * bytes (not in number of characters) of the string, then by the unicode\n * string\n */\npublic static int TYPE_STRING = 0x5e;"
            ],
            [
                "TYPE_RAW",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * Raw data, good for serialization. Followed by first, a 16-bits integer\n * indicating the length in bytes of the dataset, and then the data itself.\n */\npublic static int TYPE_RAW = 0x5f;"
            ],
            [
                "TYPE_ARRAY",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n * An type-unspecified array. Followed by first, a 16-bits integer\n * indicating the number of elements, and then, the elements themselves. The\n * elements themselves have to give their type.\n */\npublic static byte TYPE_ARRAY = 0x60;"
            ],
            [
                "TYPE_NULL",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "public static int TYPE_NULL = 0x61;"
            ],
            [
                "COMMAND",
                "org.graphstream.stream.netstream",
                "NetStreamConstants",
                "/**\n *  Constant that indicates that this message is a COMMAND, not and EVENT.\n *\n *  For now it is followed by a string that has to be parssed at the application level.\n *\n *  THIS IS EXPERIMENTAL AND MAY (WILL) CHANGE !\n */\npublic static int COMMAND = 0x70;"
            ],
            [
                "NO_OPTIONS",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/* ********  P U B L I C   F I E L D S  ******** */\n/**\n * No options specified. Value is zero.\n */\npublic final static int NO_OPTIONS = 0;"
            ],
            [
                "ENCODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify encoding in first bit. Value is one.\n */\npublic final static int ENCODE = 1;"
            ],
            [
                "DECODE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify decoding in first bit. Value is zero.\n */\npublic final static int DECODE = 0;"
            ],
            [
                "GZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that data should be gzip-compressed in second bit. Value is two.\n */\npublic final static int GZIP = 2;"
            ],
            [
                "DONT_GUNZIP",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Specify that gzipped data should <em>not</em> be automatically gunzipped.\n */\npublic final static int DONT_GUNZIP = 4;"
            ],
            [
                "DO_BREAK_LINES",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Do break lines when encoding. Value is 8.\n */\npublic final static int DO_BREAK_LINES = 8;"
            ],
            [
                "URL_SAFE",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using Base64-like encoding that is URL- and Filename-safe as described\n * in Section 4 of RFC3548:\n * <a href=\"http://www.faqs.org/rfcs/rfc3548.html\">http://www.faqs.org/rfcs/rfc3548.html</a>.\n * It is important to note that data encoded this way is <em>not</em> officially valid Base64,\n * or at the very least should not be called Base64 without also specifying that is\n * was encoded using the URL- and Filename-safe dialect.\n */\npublic final static int URL_SAFE = 16;"
            ],
            [
                "ORDERED",
                "org.graphstream.stream.netstream.packing",
                "Base64",
                "/**\n * Encode using the special \"ordered\" dialect of Base64 described here:\n * <a href=\"http://www.faqs.org/qa/rfcc-1940.html\">http://www.faqs.org/qa/rfcc-1940.html</a>.\n */\npublic final static int ORDERED = 32;"
            ],
            [
                "INITIAL_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final int INITIAL_EDGE_CAPACITY;"
            ],
            [
                "GROWTH_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final double GROWTH_FACTOR = 1.1;"
            ],
            [
                "I_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char I_EDGE = 0;"
            ],
            [
                "IO_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char IO_EDGE = 1;"
            ],
            [
                "O_EDGE",
                "org.graphstream.graph.implementations",
                "AdjacencyListNode",
                "protected static final char O_EDGE = 2;"
            ],
            [
                "GROW_FACTOR",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final double GROW_FACTOR = 1.1;"
            ],
            [
                "DEFAULT_NODE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_NODE_CAPACITY = 128;"
            ],
            [
                "DEFAULT_EDGE_CAPACITY",
                "org.graphstream.graph.implementations",
                "AdjacencyListGraph",
                "public static final int DEFAULT_EDGE_CAPACITY = 1024;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "64",
                "int"
            ],
            [
                "3",
                "int"
            ],
            [
                "4",
                "int"
            ],
            [
                "1.3",
                "double"
            ]
        ],
        "tokensMethodArguments": [
            [
                "source",
                "",
                "byte[]"
            ],
            [
                "srcOffset",
                "",
                "int"
            ],
            [
                "numSigBytes",
                "",
                "int"
            ],
            [
                "destination",
                "",
                "byte[]"
            ],
            [
                "destOffset",
                "",
                "int"
            ],
            [
                "options",
                "",
                "int"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "",
                "byte[]",
                "public boolean equals(Object);"
            ],
            [
                "toString",
                "",
                "byte[]",
                "public String toString()"
            ],
            [
                "hashCode",
                "",
                "byte[]",
                "public native int hashCode()"
            ],
            [
                "getClass",
                "",
                "byte[]",
                "public final native Class getClass();"
            ],
            [
                "clone",
                "",
                "byte[]",
                "public T[] clone();"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "length",
                "",
                "byte[]",
                "public final int length;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]